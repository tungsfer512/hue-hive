{"version":3,"file":"calcite-parser~dasksql-parser~flink-parser~generic-parser~-1419606629-chunk-a2a4f8506cb55bb7.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///./desktop/core/src/desktop/js/parse/sql/sqlParseUtils.js"],"sourcesContent":["function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport stringDistance from \"../../sql/stringDistance\";\n\n// endsWith polyfill from hue_utils.js, needed as workers live in their own js environment\nif (!String.prototype.endsWith) {\n  String.prototype.endsWith = function (searchString, position) {\n    var subjectString = this.toString();\n    if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {\n      position = subjectString.length;\n    }\n    position -= searchString.length;\n    var lastIndex = subjectString.lastIndexOf(searchString, position);\n    return lastIndex !== -1 && lastIndex === position;\n  };\n}\nexport var identifierEquals = function identifierEquals(a, b) {\n  return a && b && a.replace(/^\\s*`/, '').replace(/`\\s*$/, '').toLowerCase() === b.replace(/^\\s*`/, '').replace(/`\\s*$/, '').toLowerCase();\n};\nexport var equalIgnoreCase = function equalIgnoreCase(a, b) {\n  return a && b && a.toLowerCase() === b.toLowerCase();\n};\nexport var SIMPLE_TABLE_REF_SUGGESTIONS = ['suggestJoinConditions', 'suggestAggregateFunctions', 'suggestFilters', 'suggestGroupBys', 'suggestOrderBys'];\nexport var LOCATION_TYPES = {\n  ALIAS: 'alias',\n  ASTERISK: 'asterisk',\n  COLUMN: 'column',\n  DATABASE: 'database',\n  FILE: 'file',\n  FUNCTION: 'function',\n  FUNCTION_ARGUMENT: 'functionArgument',\n  STATEMENT: 'statement',\n  STATEMENT_TYPE: 'statementType',\n  TABLE: 'table',\n  UNKNOWN: 'unknown',\n  VARIABLE: 'variable'\n};\nvar APPEND_BACKTICK_SUGGESTIONS = ['suggestColumns', 'suggestCommonTableExpressions', 'suggestDatabases', 'suggestTables'];\nexport var adjustForPartialBackticks = function adjustForPartialBackticks(parser) {\n  var partials = parser.yy.partialLengths;\n  if (parser.yy.result && partials.backtickBefore && !partials.backtickAfter) {\n    APPEND_BACKTICK_SUGGESTIONS.forEach(function (suggestionType) {\n      if (parser.yy.result[suggestionType]) {\n        parser.yy.result[suggestionType].appendBacktick = true;\n      }\n    });\n  }\n};\nexport var initSharedAutocomplete = function initSharedAutocomplete(parser) {\n  parser.SELECT_FIRST_OPTIONAL_KEYWORDS = [{\n    value: 'ALL',\n    weight: 2\n  }, {\n    value: 'DISTINCT',\n    weight: 2\n  }];\n  var adjustLocationForCursor = function adjustLocationForCursor(location) {\n    // columns are 0-based and lines not, so add 1 to cols\n    var newLocation = {\n      first_line: location.first_line,\n      last_line: location.last_line,\n      first_column: location.first_column + 1,\n      last_column: location.last_column + 1\n    };\n    if (parser.yy.cursorFound) {\n      if (parser.yy.cursorFound.first_line === newLocation.first_line && parser.yy.cursorFound.last_column <= newLocation.first_column) {\n        var additionalSpace = parser.yy.partialLengths.left + parser.yy.partialLengths.right;\n        additionalSpace -= parser.yy.partialCursor ? 1 : 3; // For some reason the normal cursor eats 3 positions.\n        newLocation.first_column = newLocation.first_column + additionalSpace;\n        newLocation.last_column = newLocation.last_column + additionalSpace;\n      }\n    }\n    return newLocation;\n  };\n  parser.addAsteriskLocation = function (location, identifierChain) {\n    parser.yy.locations.push({\n      type: LOCATION_TYPES.ASTERISK,\n      location: adjustLocationForCursor(location),\n      identifierChain: identifierChain\n    });\n  };\n  parser.addClauseLocation = function (type, precedingLocation, locationIfPresent, isCursor) {\n    var location;\n    if (isCursor) {\n      if (parser.yy.partialLengths.left === 0 && parser.yy.partialLengths.right === 0) {\n        location = {\n          type: type,\n          missing: true,\n          location: adjustLocationForCursor({\n            first_line: precedingLocation.last_line,\n            first_column: precedingLocation.last_column,\n            last_line: precedingLocation.last_line,\n            last_column: precedingLocation.last_column\n          })\n        };\n      } else {\n        location = {\n          type: type,\n          missing: false,\n          location: {\n            first_line: locationIfPresent.last_line,\n            first_column: locationIfPresent.last_column - 1,\n            last_line: locationIfPresent.last_line,\n            last_column: locationIfPresent.last_column - 1 + parser.yy.partialLengths.right + parser.yy.partialLengths.left\n          }\n        };\n      }\n    } else {\n      location = {\n        type: type,\n        missing: !locationIfPresent,\n        location: adjustLocationForCursor(locationIfPresent || {\n          first_line: precedingLocation.last_line,\n          first_column: precedingLocation.last_column,\n          last_line: precedingLocation.last_line,\n          last_column: precedingLocation.last_column\n        })\n      };\n    }\n    if (parser.isInSubquery()) {\n      location.subquery = true;\n    }\n    parser.yy.locations.push(location);\n  };\n  parser.addColumnAliasLocation = function (location, alias, parentLocation) {\n    var aliasLocation = {\n      type: LOCATION_TYPES.ALIAS,\n      source: 'column',\n      alias: alias,\n      location: adjustLocationForCursor(location),\n      parentLocation: adjustLocationForCursor(parentLocation)\n    };\n    if (parser.yy.locations.length && parser.yy.locations[parser.yy.locations.length - 1].type === 'column') {\n      var closestColumn = parser.yy.locations[parser.yy.locations.length - 1];\n      if (closestColumn.location.first_line === aliasLocation.parentLocation.first_line && closestColumn.location.last_line === aliasLocation.parentLocation.last_line && closestColumn.location.first_column === aliasLocation.parentLocation.first_column && closestColumn.location.last_column === aliasLocation.parentLocation.last_column) {\n        parser.yy.locations[parser.yy.locations.length - 1].alias = alias;\n      }\n    }\n    parser.yy.locations.push(aliasLocation);\n  };\n  parser.addColumnLocation = function (location, identifierChain) {\n    var isVariable = identifierChain.length && /\\${[^}]*}/.test(identifierChain[identifierChain.length - 1].name);\n    if (isVariable) {\n      parser.yy.locations.push({\n        type: LOCATION_TYPES.VARIABLE,\n        location: adjustLocationForCursor(location),\n        value: identifierChain[identifierChain.length - 1].name\n      });\n    } else {\n      parser.yy.locations.push({\n        type: LOCATION_TYPES.COLUMN,\n        location: adjustLocationForCursor(location),\n        identifierChain: identifierChain,\n        qualified: identifierChain.length > 1\n      });\n    }\n  };\n  parser.addCteAliasLocation = function (location, alias) {\n    parser.yy.locations.push({\n      type: LOCATION_TYPES.ALIAS,\n      source: 'cte',\n      alias: alias,\n      location: adjustLocationForCursor(location)\n    });\n  };\n  parser.addDatabaseLocation = function (location, identifierChain) {\n    parser.yy.locations.push({\n      type: LOCATION_TYPES.DATABASE,\n      location: adjustLocationForCursor(location),\n      identifierChain: identifierChain\n    });\n  };\n  parser.addFileLocation = function (location, path) {\n    parser.yy.locations.push({\n      type: LOCATION_TYPES.FILE,\n      location: adjustLocationForCursor(location),\n      path: path\n    });\n  };\n  parser.addFunctionLocation = function (location, functionName) {\n    // Remove trailing '(' from location\n    var adjustedLocation = {\n      first_line: location.first_line,\n      last_line: location.last_line,\n      first_column: location.first_column,\n      last_column: location.last_column - 1\n    };\n    parser.yy.locations.push({\n      type: LOCATION_TYPES.FUNCTION,\n      location: adjustLocationForCursor(adjustedLocation),\n      \"function\": functionName.toLowerCase()\n    });\n  };\n  parser.addFunctionArgumentLocations = function (functionName, expressions, identifierChain) {\n    if (!expressions || !expressions.length) {\n      return;\n    }\n    expressions.forEach(function (details, idx) {\n      var location = {\n        type: LOCATION_TYPES.FUNCTION_ARGUMENT,\n        location: adjustLocationForCursor(details.location),\n        \"function\": functionName.toLowerCase(),\n        argumentPosition: idx,\n        identifierChain: identifierChain || [{\n          name: functionName\n        }],\n        expression: details.expression\n      };\n      if (details.suffix) {\n        location.suffix = details.suffix;\n      }\n      parser.yy.locations.push(location);\n    });\n  };\n  parser.addNewDatabaseLocation = function (location, identifierChain) {\n    parser.yy.definitions.push({\n      type: LOCATION_TYPES.DATABASE,\n      location: adjustLocationForCursor(location),\n      identifierChain: identifierChain\n    });\n  };\n  parser.addNewTableLocation = function (location, identifierChain, colSpec) {\n    var columns = [];\n    if (colSpec) {\n      colSpec.forEach(function (col) {\n        columns.push({\n          identifierChain: [col.identifier],\n          // TODO: Complex\n          type: col.type,\n          location: adjustLocationForCursor(col.location)\n        });\n      });\n    }\n    parser.yy.definitions.push({\n      type: LOCATION_TYPES.TABLE,\n      location: adjustLocationForCursor(location),\n      identifierChain: identifierChain,\n      columns: columns\n    });\n  };\n  parser.addStatementLocation = function (location) {\n    // Don't report lonely cursor as a statement\n    if (location.first_line === location.last_line && Math.abs(location.last_column - location.first_column) === 1) {\n      return;\n    }\n    var adjustedLocation;\n    if (parser.yy.cursorFound && parser.yy.cursorFound.last_line === location.last_line && parser.yy.cursorFound.first_column >= location.first_column && parser.yy.cursorFound.last_column <= location.last_column) {\n      var additionalSpace = parser.yy.partialLengths.left + parser.yy.partialLengths.right;\n      adjustedLocation = {\n        first_line: location.first_line,\n        last_line: location.last_line,\n        first_column: location.first_column + 1,\n        last_column: location.last_column + additionalSpace - (parser.yy.partialCursor ? 0 : 2)\n      };\n    } else {\n      adjustedLocation = {\n        first_line: location.first_line,\n        last_line: location.last_line,\n        first_column: location.first_column + 1,\n        last_column: location.last_column + 1\n      };\n    }\n    parser.yy.locations.push({\n      type: LOCATION_TYPES.STATEMENT,\n      location: adjustedLocation\n    });\n  };\n  parser.addStatementTypeLocation = function (identifier, location, additionalText) {\n    // Don't add if already there except for SELECT\n    if (identifier !== 'SELECT' && parser.yy.allLocations) {\n      for (var i = parser.yy.allLocations.length - 1; i >= 0; i--) {\n        if (parser.yy.allLocations[i] && parser.yy.allLocations[i].type === LOCATION_TYPES.STATEMENT) {\n          break;\n        }\n        if (parser.yy.allLocations[i] && parser.yy.allLocations[i].type === LOCATION_TYPES.STATEMENT_TYPE) {\n          return;\n        }\n      }\n    }\n    var loc = {\n      type: LOCATION_TYPES.STATEMENT_TYPE,\n      location: adjustLocationForCursor(location),\n      identifier: identifier\n    };\n    if (typeof additionalText !== 'undefined') {\n      switch (identifier) {\n        case 'ALTER':\n          if (/ALTER\\s+VIEW/i.test(additionalText)) {\n            loc.identifier = 'ALTER VIEW';\n          } else {\n            loc.identifier = 'ALTER TABLE';\n          }\n          break;\n        case 'COMPUTE':\n          loc.identifier = 'COMPUTE STATS';\n          break;\n        case 'CREATE':\n          if (/CREATE\\s+VIEW/i.test(additionalText)) {\n            loc.identifier = 'CREATE VIEW';\n          } else if (/CREATE\\s+TABLE/i.test(additionalText)) {\n            loc.identifier = 'CREATE TABLE';\n          } else if (/CREATE\\s+DATABASE/i.test(additionalText)) {\n            loc.identifier = 'CREATE DATABASE';\n          } else if (/CREATE\\s+ROLE/i.test(additionalText)) {\n            loc.identifier = 'CREATE ROLE';\n          } else if (/CREATE\\s+FUNCTION/i.test(additionalText)) {\n            loc.identifier = 'CREATE FUNCTION';\n          } else {\n            loc.identifier = 'CREATE TABLE';\n          }\n          break;\n        case 'DROP':\n          if (/DROP\\s+VIEW/i.test(additionalText)) {\n            loc.identifier = 'DROP VIEW';\n          } else if (/DROP\\s+TABLE/i.test(additionalText)) {\n            loc.identifier = 'DROP TABLE';\n          } else if (/DROP\\s+DATABASE/i.test(additionalText)) {\n            loc.identifier = 'DROP DATABASE';\n          } else if (/DROP\\s+ROLE/i.test(additionalText)) {\n            loc.identifier = 'DROP ROLE';\n          } else if (/DROP\\s+STATS/i.test(additionalText)) {\n            loc.identifier = 'DROP STATS';\n          } else if (/DROP\\s+FUNCTION/i.test(additionalText)) {\n            loc.identifier = 'DROP FUNCTION';\n          } else {\n            loc.identifier = 'DROP TABLE';\n          }\n          break;\n        case 'INVALIDATE':\n          loc.identifier = 'INVALIDATE METADATA';\n          break;\n        case 'LOAD':\n          loc.identifier = 'LOAD DATA';\n          break;\n        case 'TRUNCATE':\n          loc.identifier = 'TRUNCATE TABLE';\n          break;\n        default:\n      }\n    }\n    parser.yy.locations.push(loc);\n  };\n  parser.addSubqueryAliasLocation = function (location, alias) {\n    parser.yy.locations.push({\n      type: LOCATION_TYPES.ALIAS,\n      source: 'subquery',\n      alias: alias,\n      location: adjustLocationForCursor(location)\n    });\n  };\n  parser.addTableAliasLocation = function (location, alias, identifierChain) {\n    parser.yy.locations.push({\n      type: LOCATION_TYPES.ALIAS,\n      source: 'table',\n      alias: alias,\n      location: adjustLocationForCursor(location),\n      identifierChain: identifierChain\n    });\n  };\n  parser.addTableLocation = function (location, identifierChain) {\n    parser.yy.locations.push({\n      type: LOCATION_TYPES.TABLE,\n      location: adjustLocationForCursor(location),\n      identifierChain: identifierChain\n    });\n  };\n  parser.addVariableLocation = function (location, value) {\n    if (/\\${[^}]*}/.test(value)) {\n      parser.yy.locations.push({\n        type: LOCATION_TYPES.VARIABLE,\n        location: adjustLocationForCursor(location),\n        value: value\n      });\n    }\n  };\n  parser.addUnknownLocation = function (location, identifierChain) {\n    var isVariable = identifierChain.length && /\\${[^}]*}/.test(identifierChain[identifierChain.length - 1].name);\n    var loc;\n    if (isVariable) {\n      loc = {\n        type: LOCATION_TYPES.VARIABLE,\n        location: adjustLocationForCursor(location),\n        value: identifierChain[identifierChain.length - 1].name\n      };\n    } else {\n      loc = {\n        type: LOCATION_TYPES.UNKNOWN,\n        location: adjustLocationForCursor(location),\n        identifierChain: identifierChain,\n        qualified: identifierChain.length > 1\n      };\n    }\n    parser.yy.locations.push(loc);\n    return loc;\n  };\n  parser.applyTypes = function (suggestion, typeDetails) {\n    suggestion.types = typeDetails.types;\n    if (typeDetails.types && typeDetails.types[0] === 'UDFREF') {\n      if (typeDetails[\"function\"]) {\n        suggestion.udfRef = typeDetails[\"function\"];\n      } else {\n        suggestion.types = ['T'];\n      }\n    }\n  };\n  parser.applyTypeToSuggestions = function (details) {\n    if (!details.types) {\n      console.trace();\n    }\n    if (details.types[0] === 'BOOLEAN') {\n      return;\n    }\n    if (parser.yy.result.suggestFunctions && !parser.yy.result.suggestFunctions.types) {\n      parser.applyTypes(parser.yy.result.suggestFunctions, details);\n    }\n    if (parser.yy.result.suggestColumns && !parser.yy.result.suggestColumns.types) {\n      parser.applyTypes(parser.yy.result.suggestColumns, details);\n    }\n  };\n  parser.extractExpressionText = function (result) {\n    var parts = [];\n    for (var _len = arguments.length, expressions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      expressions[_key - 1] = arguments[_key];\n    }\n    var fail = expressions.some(function (expression) {\n      if (typeof expression === 'undefined') {\n        // Skip undefined (optionals)\n        return false;\n      }\n      if (typeof expression === 'string' || typeof expression === 'number') {\n        parts.push(expression);\n      } else if (_typeof(expression) === 'object') {\n        if (expression.text) {\n          parts.push(expression.text);\n        } else if (expression.columnReference) {\n          parts.push(expression.columnReference.map(function (ref) {\n            return ref.name;\n          }).join('.'));\n        } else {\n          return true;\n        }\n      }\n    });\n    if (!fail) {\n      result.text = parts.join(' ');\n    }\n  };\n  parser.getSubQuery = function (cols) {\n    var columns = [];\n    cols.selectList.forEach(function (col) {\n      var result = {};\n      if (col.alias) {\n        result.alias = col.alias;\n      }\n      if (col.valueExpression && col.valueExpression.columnReference) {\n        result.identifierChain = col.valueExpression.columnReference;\n      } else if (col.asterisk) {\n        result.identifierChain = [{\n          asterisk: true\n        }];\n      }\n      if (col.valueExpression && col.valueExpression.types && col.valueExpression.types.length === 1) {\n        result.type = col.valueExpression.types[0];\n        if (result.type === 'UDFREF') {\n          if (col.valueExpression[\"function\"]) {\n            result.udfRef = col.valueExpression[\"function\"];\n          } else {\n            result.type = ['T'];\n          }\n        }\n      }\n      columns.push(result);\n    });\n    return {\n      columns: columns\n    };\n  };\n  var PARTIAL_BEFORE_REGEX = /[0-9a-zA-Z_`]*$/;\n  var PARTIAL_AFTER_REGEX = /^[0-9a-zA-Z_`]*(?:\\((?:[^)]*\\))?)?/;\n  parser.identifyPartials = function (beforeCursor, afterCursor) {\n    var beforeMatch = beforeCursor.match(PARTIAL_BEFORE_REGEX);\n    var afterMatch = afterCursor.match(PARTIAL_AFTER_REGEX);\n    return {\n      left: beforeMatch ? beforeMatch[0].length : 0,\n      right: afterMatch ? afterMatch[0].length : 0,\n      backtickBefore: beforeMatch && beforeMatch[0].indexOf('`') !== -1,\n      backtickAfter: afterMatch && afterMatch[0].indexOf('`') !== -1\n    };\n  };\n  parser.suggestKeywords = function (keywords) {\n    if (typeof keywords === 'string') {\n      keywords = parser.KEYWORDS && parser.KEYWORDS[keywords] || [];\n    }\n    var weightedKeywords = [];\n    if (keywords.length === 0) {\n      return;\n    }\n    keywords.forEach(function (keyword) {\n      if (typeof keyword.weight !== 'undefined') {\n        weightedKeywords.push(keyword);\n      } else {\n        weightedKeywords.push({\n          value: keyword,\n          weight: -1\n        });\n      }\n    });\n    weightedKeywords.sort(function (a, b) {\n      if (a.weight !== b.weight) {\n        return b.weight - a.weight;\n      }\n      return a.value.localeCompare(b.value);\n    });\n    parser.yy.result.suggestKeywords = weightedKeywords;\n  };\n  parser.valueExpressionSuggest = function (oppositeValueExpression, operator) {\n    if (oppositeValueExpression && oppositeValueExpression.columnReference) {\n      parser.suggestValues();\n      parser.yy.result.colRef = {\n        identifierChain: oppositeValueExpression.columnReference\n      };\n    }\n    parser.suggestColumns();\n    parser.suggestFunctions();\n    var keywords = [{\n      value: 'CASE',\n      weight: 450\n    }, {\n      value: 'FALSE',\n      weight: 450\n    }, {\n      value: 'NULL',\n      weight: 450\n    }, {\n      value: 'TRUE',\n      weight: 450\n    }];\n    if (typeof oppositeValueExpression === 'undefined' || typeof operator === 'undefined') {\n      keywords = keywords.concat(['EXISTS', 'NOT']);\n    }\n    if (oppositeValueExpression && oppositeValueExpression.types[0] === 'NUMBER') {\n      parser.applyTypeToSuggestions(oppositeValueExpression);\n    }\n    parser.suggestKeywords(keywords);\n  };\n};\nvar SYNTAX_PARSER_NOOP_FUNCTIONS = ['addAsteriskLocation', 'addClauseLocation', 'addColRefIfExists', 'addColRefToVariableIfExists', 'addColumnAliasLocation', 'addColumnLocation', 'addCommonTableExpressions', 'addCteAliasLocation', 'addDatabaseLocation', 'addFileLocation', 'addFunctionArgumentLocations', 'addFunctionLocation', 'addNewDatabaseLocation', 'addNewTableLocation', 'addStatementLocation', 'addStatementTypeLocation', 'addSubqueryAliasLocation', 'addTableAliasLocation', 'addTableLocation', 'addTablePrimary', 'addUnknownLocation', 'addVariableLocation', 'applyArgumentTypesToSuggestions', 'applyTypeToSuggestions', 'checkForKeywords', 'checkForSelectListKeywords', 'commitLocations', 'extractExpressionText', 'firstDefined', 'getSelectListKeywords', 'getSubQuery', 'getValueExpressionKeywords', 'identifyPartials', 'popQueryState', 'prepareNewStatement', 'pushQueryState', 'selectListNoTableSuggest', 'suggestAggregateFunctions', 'suggestAnalyticFunctions', 'suggestColRefKeywords', 'suggestColumns', 'suggestDatabases', 'suggestDdlAndDmlKeywords', 'suggestFileFormats', 'suggestFilters', 'suggestFunctions', 'suggestGroupBys', 'suggestHdfs', 'suggestIdentifiers', 'suggestJoinConditions', 'suggestJoins', 'suggestKeyValues', 'suggestKeywords', 'suggestOrderBys', 'suggestSelectListAliases', 'suggestTables', 'suggestTablesOrColumns', 'suggestValueExpressionKeywords', 'suggestValues', 'valueExpressionSuggest'];\nvar SYNTAX_PARSER_NOOP = function SYNTAX_PARSER_NOOP() {};\nexport var initSyntaxParser = function initSyntaxParser(parser) {\n  // Noop functions for compatibility with the autocomplete parser as the grammar is shared\n  SYNTAX_PARSER_NOOP_FUNCTIONS.forEach(function (noopFn) {\n    parser[noopFn] = SYNTAX_PARSER_NOOP;\n  });\n  parser.yy.locations = [{}];\n  parser.determineCase = function (text) {\n    if (!parser.yy.caseDetermined) {\n      parser.yy.lowerCase = text.toLowerCase() === text;\n      parser.yy.caseDetermined = true;\n    }\n  };\n  parser.getKeywordsForOptionalsLR = function () {\n    return [];\n  };\n  parser.mergeSuggestKeywords = function () {\n    return {};\n  };\n  parser.getTypeKeywords = function () {\n    return [];\n  };\n  parser.getColumnDataTypeKeywords = function () {\n    return [];\n  };\n  parser.findCaseType = function () {\n    return {\n      types: ['T']\n    };\n  };\n  parser.expandIdentifierChain = function () {\n    return [];\n  };\n  parser.createWeightedKeywords = function () {\n    return [];\n  };\n  parser.handleQuotedValueWithCursor = function (lexer, yytext, yylloc, quoteChar) {\n    if (yytext.indexOf(\"\\u2020\") !== -1 || yytext.indexOf(\"\\u2021\") !== -1) {\n      parser.yy.partialCursor = yytext.indexOf(\"\\u2021\") !== -1;\n      var cursorIndex = parser.yy.partialCursor ? yytext.indexOf(\"\\u2021\") : yytext.indexOf(\"\\u2020\");\n      parser.yy.cursorFound = {\n        first_line: yylloc.first_line,\n        last_line: yylloc.last_line,\n        first_column: yylloc.first_column + cursorIndex,\n        last_column: yylloc.first_column + cursorIndex + 1\n      };\n      var remainder = yytext.substring(cursorIndex + 1);\n      var remainingQuotes = (lexer.upcomingInput().match(new RegExp(quoteChar, 'g')) || []).length;\n      if (remainingQuotes > 0 && (remainingQuotes & 1) !== 0) {\n        parser.yy.missingEndQuote = false;\n        lexer.input();\n      } else {\n        parser.yy.missingEndQuote = true;\n        lexer.unput(remainder);\n      }\n      lexer.popState();\n      return true;\n    }\n    return false;\n  };\n  parser.yy.parseError = function (str, hash) {\n    parser.yy.error = hash;\n  };\n  var IGNORED_EXPECTED = {\n    ';': true,\n    '.': true,\n    CREATE_REMOTE: true,\n    EOF: true,\n    UNSIGNED_INTEGER: true,\n    UNSIGNED_INTEGER_E: true,\n    REGULAR_IDENTIFIER: true,\n    CURSOR: true,\n    PARTIAL_CURSOR: true,\n    HDFS_START_QUOTE: true,\n    HDFS_PATH: true,\n    HDFS_END_QUOTE: true,\n    COMPARISON_OPERATOR: true,\n    // TODO: Expand in results when found\n    ARITHMETIC_OPERATOR: true,\n    // TODO: Expand in results when found\n    VARIABLE_REFERENCE: true,\n    BACKTICK: true,\n    VALUE: true,\n    PARTIAL_VALUE: true,\n    SINGLE_QUOTE: true,\n    DOUBLE_QUOTE: true\n  };\n  var CLEAN_EXPECTED = {\n    BETWEEN_AND: 'AND',\n    OVERWRITE_DIRECTORY: 'OVERWRITE',\n    STORED_AS_DIRECTORIES: 'STORED',\n    LIKE_PARQUET: 'LIKE',\n    PARTITION_VALUE: 'PARTITION'\n  };\n  parser.parseSyntax = function (beforeCursor, afterCursor, debug) {\n    parser.yy.caseDetermined = false;\n    parser.yy.error = undefined;\n    parser.yy.latestTablePrimaries = [];\n    parser.yy.subQueries = [];\n    parser.yy.selectListAliases = [];\n    parser.yy.latestTablePrimaries = [];\n    parser.yy.activeDialect = 'generic';\n\n    // TODO: Find a way around throwing an exception when the parser finds a syntax error\n    try {\n      parser.yy.error = false;\n      parser.parse(beforeCursor + afterCursor);\n    } catch (err) {\n      if (debug) {\n        console.warn(parser.yy.error);\n        throw err;\n      }\n    }\n    if (parser.yy.error && (parser.yy.error.loc.last_column < beforeCursor.length || !beforeCursor.endsWith(parser.yy.error.text))) {\n      var weightedExpected = [];\n      var addedExpected = {};\n      var isLowerCase = parser.yy.caseDetermined && parser.yy.lowerCase || parser.yy.error.text.toLowerCase() === parser.yy.error.text;\n      if (parser.yy.error.expected.length === 2 && parser.yy.error.expected.indexOf(\"';'\") !== -1 && parser.yy.error.expected.indexOf(\"'EOF'\") !== -1) {\n        parser.yy.error.expected = [];\n        parser.yy.error.expectedStatementEnd = true;\n        return parser.yy.error;\n      }\n      for (var i = 0; i < parser.yy.error.expected.length; i++) {\n        var expected = parser.yy.error.expected[i];\n        // Strip away the surrounding ' chars\n        expected = expected.substring(1, expected.length - 1);\n        // TODO: Only suggest alphanumeric?\n        if (expected === 'REGULAR_IDENTIFIER') {\n          parser.yy.error.expectedIdentifier = true;\n          if (/^<[a-z]+>/.test(parser.yy.error.token)) {\n            var text = '`' + parser.yy.error.text + '`';\n            weightedExpected.push({\n              text: text,\n              distance: stringDistance(parser.yy.error.text, text, true)\n            });\n            parser.yy.error.possibleReserved = true;\n          }\n        } else if (!IGNORED_EXPECTED[expected] && /[a-z_]+/i.test(expected)) {\n          // Skip mixed-case expected\n          if (expected.toUpperCase() !== expected) {\n            continue;\n          }\n          expected = CLEAN_EXPECTED[expected] || expected;\n          if (expected === parser.yy.error.text.toUpperCase()) {\n            // Can happen when the lexer entry for a rule contains multiple words like 'stored' in 'stored as parquet'\n            return false;\n          }\n          var _text = isLowerCase ? expected.toLowerCase() : expected;\n          if (_text && !addedExpected[_text]) {\n            addedExpected[_text] = true;\n            weightedExpected.push({\n              text: _text,\n              distance: stringDistance(parser.yy.error.text, _text, true)\n            });\n          }\n        }\n      }\n      if (weightedExpected.length === 0) {\n        parser.yy.error.expected = [];\n        parser.yy.error.incompleteStatement = true;\n        return parser.yy.error;\n      }\n      weightedExpected.sort(function (a, b) {\n        if (a.distance === b.distance) {\n          return a.text.localeCompare(b.text);\n        }\n        return a.distance - b.distance;\n      });\n      parser.yy.error.expected = weightedExpected;\n      parser.yy.error.incompleteStatement = true;\n      return parser.yy.error;\n    } else if (parser.yy.error) {\n      parser.yy.error.expected = [];\n      parser.yy.error.incompleteStatement = true;\n      return parser.yy.error;\n    }\n    return false;\n  };\n};"],"names":[],"sourceRoot":""}
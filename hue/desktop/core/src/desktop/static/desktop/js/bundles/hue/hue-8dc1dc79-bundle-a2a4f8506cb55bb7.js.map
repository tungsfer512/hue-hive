{"version":3,"file":"hue-8dc1dc79-bundle-a2a4f8506cb55bb7.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC/ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACr+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///./desktop/core/src/desktop/js/catalog/catalogUtils.ts","webpack:///./desktop/core/src/desktop/js/catalog/contextCatalog.ts","webpack:///./desktop/core/src/desktop/js/catalog/dataCatalog.ts","webpack:///./desktop/core/src/desktop/js/catalog/events.ts"],"sourcesContent":["// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * Helper function that adds sets the silence errors option to true if not specified\n */\nexport var forceSilencedErrors = function forceSilencedErrors(options) {\n  if (!options) {\n    options = {};\n  }\n  if (typeof options.silenceErrors === 'undefined') {\n    options.silenceErrors = true;\n  }\n  return options;\n};\n\n/**\n * Helper function to apply the cancellable option to an existing or new promise\n */\nexport var applyCancellable = function applyCancellable(promise, options) {\n  if (promise && promise.preventCancel && (!options || !options.cancellable)) {\n    promise.preventCancel();\n  }\n  return promise;\n};","function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport localforage from 'localforage';\nimport { fetchClusters, fetchComputes, fetchNamespaces } from \"./api\";\nimport huePubSub from 'utils/huePubSub';\nimport noop from 'utils/timing/noop';\nimport { CONTEXT_CATALOG_REFRESHED_TOPIC, NAMESPACES_REFRESHED_TOPIC, REFRESH_CONTEXT_CATALOG_TOPIC } from \"./events\";\nvar ContextTypes = /*#__PURE__*/function (ContextTypes) {\n  ContextTypes[\"Namespace\"] = \"namespace\";\n  ContextTypes[\"Compute\"] = \"compute\";\n  ContextTypes[\"Cluster\"] = \"cluster\";\n  return ContextTypes;\n}(ContextTypes || {});\nvar STORAGE_POSTFIX = window.LOGGED_USERNAME;\nvar CONTEXT_CATALOG_VERSION = 4;\nvar DISABLE_CACHE = true;\nvar store = localforage.createInstance({\n  name: \"HueContextCatalog_\".concat(STORAGE_POSTFIX)\n});\nvar namespacePromises = new Map();\nvar computePromises = new Map();\nvar clusterPromises = new Map();\nhuePubSub.subscribe(REFRESH_CONTEXT_CATALOG_TOPIC, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n  var namespacesToRefresh;\n  return _regeneratorRuntime().wrap(function _callee$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        namespacesToRefresh = _toConsumableArray(namespacePromises.keys());\n        namespacePromises.clear();\n        computePromises.clear();\n        clusterPromises.clear();\n        _context.prev = 4;\n        _context.next = 7;\n        return store.clear();\n      case 7:\n        _context.next = 11;\n        break;\n      case 9:\n        _context.prev = 9;\n        _context.t0 = _context[\"catch\"](4);\n      case 11:\n        huePubSub.publish(CONTEXT_CATALOG_REFRESHED_TOPIC);\n        namespacesToRefresh.forEach(function (connectorId) {\n          huePubSub.publish(NAMESPACES_REFRESHED_TOPIC, connectorId);\n        });\n      case 13:\n      case \"end\":\n        return _context.stop();\n    }\n  }, _callee, null, [[4, 9]]);\n})));\nvar saveLaterToCache = function saveLaterToCache(type, connector, entry) {\n  if (entry) {\n    window.setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _context2.next = 3;\n            return store.setItem(\"\".concat(type, \"_\").concat(connector.id), {\n              version: CONTEXT_CATALOG_VERSION,\n              entry: entry\n            });\n          case 3:\n            _context2.next = 7;\n            break;\n          case 5:\n            _context2.prev = 5;\n            _context2.t0 = _context2[\"catch\"](0);\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2, null, [[0, 5]]);\n    })), 1000);\n  }\n};\nvar deleteFromCache = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(type, connector) {\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return store.removeItem(\"\".concat(type, \"_\").concat(connector.id));\n        case 2:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return function deleteFromCache(_x, _x2) {\n    return _ref3.apply(this, arguments);\n  };\n}();\nvar getCached = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(type, connector) {\n    var storedItem;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          if (DISABLE_CACHE) {\n            _context4.next = 12;\n            break;\n          }\n          _context4.prev = 1;\n          _context4.next = 4;\n          return store.getItem(\"\".concat(type, \"_\").concat(connector.id));\n        case 4:\n          storedItem = _context4.sent;\n          if (!(storedItem && storedItem.version === CONTEXT_CATALOG_VERSION)) {\n            _context4.next = 7;\n            break;\n          }\n          return _context4.abrupt(\"return\", storedItem.entry);\n        case 7:\n          _context4.next = 12;\n          break;\n        case 9:\n          _context4.prev = 9;\n          _context4.t0 = _context4[\"catch\"](1);\n          console.warn(_context4.t0);\n        case 12:\n          return _context4.abrupt(\"return\", undefined);\n        case 13:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4, null, [[1, 9]]);\n  }));\n  return function getCached(_x3, _x4) {\n    return _ref4.apply(this, arguments);\n  };\n}();\nexport var getNamespaces = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref5) {\n    var connector, clearCache, silenceErrors, notifyForRefresh;\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) switch (_context6.prev = _context6.next) {\n        case 0:\n          connector = _ref5.connector, clearCache = _ref5.clearCache, silenceErrors = _ref5.silenceErrors;\n          notifyForRefresh = namespacePromises.has(connector.id) && clearCache;\n          if (!clearCache) {\n            _context6.next = 6;\n            break;\n          }\n          namespacePromises[\"delete\"](connector.id);\n          _context6.next = 6;\n          return deleteFromCache(ContextTypes.Namespace, connector);\n        case 6:\n          if (!namespacePromises.has(connector.id)) {\n            namespacePromises.set(connector.id, new Promise( /*#__PURE__*/function () {\n              var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(resolve, reject) {\n                var cached, fetchedNamespaces, namespaces, dynamic, connectorNamespaces;\n                return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                  while (1) switch (_context5.prev = _context5.next) {\n                    case 0:\n                      _context5.prev = 0;\n                      _context5.next = 3;\n                      return getCached(ContextTypes.Namespace, connector);\n                    case 3:\n                      cached = _context5.sent;\n                      if (!cached) {\n                        _context5.next = 7;\n                        break;\n                      }\n                      resolve(cached);\n                      return _context5.abrupt(\"return\");\n                    case 7:\n                      _context5.next = 11;\n                      break;\n                    case 9:\n                      _context5.prev = 9;\n                      _context5.t0 = _context5[\"catch\"](0);\n                    case 11:\n                      _context5.next = 13;\n                      return fetchNamespaces(connector, silenceErrors);\n                    case 13:\n                      fetchedNamespaces = _context5.sent;\n                      namespaces = fetchedNamespaces[connector.id];\n                      if (namespaces) {\n                        dynamic = fetchedNamespaces.dynamicClusters;\n                        namespaces.forEach(function (namespace) {\n                          // Adapt computes, TODO: Still needed?\n                          namespace.computes.forEach(function (compute) {\n                            if (!compute.id && compute.crn) {\n                              compute.id = compute.crn;\n                            }\n                            if (!compute.name && compute.clusterName) {\n                              compute.name = compute.clusterName;\n                            }\n                          });\n                        });\n                        connectorNamespaces = {\n                          namespaces: namespaces.filter(function (namespace) {\n                            return namespace.name;\n                          }),\n                          dynamic: dynamic,\n                          hueTimestamp: Date.now()\n                        };\n                        resolve(connectorNamespaces);\n                        if (notifyForRefresh) {\n                          huePubSub.publish(NAMESPACES_REFRESHED_TOPIC, connector.id);\n                        }\n                        if (connectorNamespaces.namespaces.length) {\n                          saveLaterToCache(ContextTypes.Namespace, connector, connectorNamespaces);\n                        } else {\n                          deleteFromCache(ContextTypes.Namespace, connector)[\"catch\"](noop);\n                        }\n                      } else {\n                        reject();\n                      }\n                    case 16:\n                    case \"end\":\n                      return _context5.stop();\n                  }\n                }, _callee5, null, [[0, 9]]);\n              }));\n              return function (_x6, _x7) {\n                return _ref7.apply(this, arguments);\n              };\n            }()));\n          }\n          return _context6.abrupt(\"return\", namespacePromises.get(connector.id));\n        case 8:\n        case \"end\":\n          return _context6.stop();\n      }\n    }, _callee6);\n  }));\n  return function getNamespaces(_x5) {\n    return _ref6.apply(this, arguments);\n  };\n}();\nexport var getComputes = /*#__PURE__*/function () {\n  var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(_ref8) {\n    var connector, clearCache, silenceErrors;\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) switch (_context8.prev = _context8.next) {\n        case 0:\n          connector = _ref8.connector, clearCache = _ref8.clearCache, silenceErrors = _ref8.silenceErrors;\n          if (!clearCache) {\n            _context8.next = 5;\n            break;\n          }\n          computePromises[\"delete\"](connector.id);\n          _context8.next = 5;\n          return deleteFromCache(ContextTypes.Compute, connector);\n        case 5:\n          if (!computePromises.has(connector.id)) {\n            computePromises.set(connector.id, new Promise( /*#__PURE__*/function () {\n              var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(resolve, reject) {\n                var cached, fetchedComputes, computes;\n                return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n                  while (1) switch (_context7.prev = _context7.next) {\n                    case 0:\n                      _context7.prev = 0;\n                      _context7.next = 3;\n                      return getCached(ContextTypes.Compute, connector);\n                    case 3:\n                      cached = _context7.sent;\n                      if (!cached) {\n                        _context7.next = 7;\n                        break;\n                      }\n                      resolve(cached);\n                      return _context7.abrupt(\"return\");\n                    case 7:\n                      _context7.next = 11;\n                      break;\n                    case 9:\n                      _context7.prev = 9;\n                      _context7.t0 = _context7[\"catch\"](0);\n                    case 11:\n                      _context7.next = 13;\n                      return fetchComputes(connector, silenceErrors);\n                    case 13:\n                      fetchedComputes = _context7.sent;\n                      computes = fetchedComputes[connector.id];\n                      if (computes) {\n                        resolve(computes);\n                        if (computes.length) {\n                          saveLaterToCache(ContextTypes.Compute, connector, computes);\n                        } else {\n                          deleteFromCache(ContextTypes.Compute, connector)[\"catch\"](noop);\n                        }\n                      } else {\n                        reject();\n                      }\n                    case 16:\n                    case \"end\":\n                      return _context7.stop();\n                  }\n                }, _callee7, null, [[0, 9]]);\n              }));\n              return function (_x9, _x10) {\n                return _ref10.apply(this, arguments);\n              };\n            }()));\n          }\n          return _context8.abrupt(\"return\", computePromises.get(connector.id));\n        case 7:\n        case \"end\":\n          return _context8.stop();\n      }\n    }, _callee8);\n  }));\n  return function getComputes(_x8) {\n    return _ref9.apply(this, arguments);\n  };\n}();\nexport var getClusters = /*#__PURE__*/function () {\n  var _ref12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(_ref11) {\n    var connector, clearCache, silenceErrors;\n    return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n      while (1) switch (_context10.prev = _context10.next) {\n        case 0:\n          connector = _ref11.connector, clearCache = _ref11.clearCache, silenceErrors = _ref11.silenceErrors;\n          if (!clearCache) {\n            _context10.next = 5;\n            break;\n          }\n          clusterPromises[\"delete\"](connector.id);\n          _context10.next = 5;\n          return deleteFromCache(ContextTypes.Cluster, connector);\n        case 5:\n          if (!clusterPromises.has(connector.id)) {\n            clusterPromises.set(connector.id, new Promise( /*#__PURE__*/function () {\n              var _ref13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(resolve, reject) {\n                var cached, fetchedClusters, clusters;\n                return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n                  while (1) switch (_context9.prev = _context9.next) {\n                    case 0:\n                      _context9.prev = 0;\n                      _context9.next = 3;\n                      return getCached(ContextTypes.Cluster, connector);\n                    case 3:\n                      cached = _context9.sent;\n                      if (!cached) {\n                        _context9.next = 7;\n                        break;\n                      }\n                      resolve(cached);\n                      return _context9.abrupt(\"return\");\n                    case 7:\n                      _context9.next = 11;\n                      break;\n                    case 9:\n                      _context9.prev = 9;\n                      _context9.t0 = _context9[\"catch\"](0);\n                    case 11:\n                      _context9.next = 13;\n                      return fetchClusters(connector, silenceErrors);\n                    case 13:\n                      fetchedClusters = _context9.sent;\n                      clusters = fetchedClusters[connector.id];\n                      if (clusters) {\n                        resolve(clusters);\n                        if (clusters.length) {\n                          saveLaterToCache(ContextTypes.Cluster, connector, clusters);\n                        } else {\n                          deleteFromCache(ContextTypes.Cluster, connector)[\"catch\"](noop);\n                        }\n                      } else {\n                        reject();\n                      }\n                    case 16:\n                    case \"end\":\n                      return _context9.stop();\n                  }\n                }, _callee9, null, [[0, 9]]);\n              }));\n              return function (_x12, _x13) {\n                return _ref13.apply(this, arguments);\n              };\n            }()));\n          }\n          return _context10.abrupt(\"return\", clusterPromises.get(connector.id));\n        case 7:\n        case \"end\":\n          return _context10.stop();\n      }\n    }, _callee10);\n  }));\n  return function getClusters(_x11) {\n    return _ref12.apply(this, arguments);\n  };\n}();\nexport default {\n  getNamespaces: getNamespaces,\n  getComputes: getComputes,\n  getClusters: getClusters\n};","function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport localforage from 'localforage';\nimport { CancellablePromise } from 'api/cancellablePromise';\nimport { applyCancellable } from 'catalog/catalogUtils';\nimport DataCatalogEntry from 'catalog/DataCatalogEntry';\nimport GeneralDataCatalog from 'catalog/GeneralDataCatalog';\nimport MultiTableEntry from 'catalog/MultiTableEntry';\nimport { SqlAnalyzerMode } from \"./analyzer/types\";\nvar STORAGE_POSTFIX = window.LOGGED_USERNAME || '';\nvar DATA_CATALOG_VERSION = 5;\nvar _cacheEnabled = true;\n\n/**\n * Creates a cache identifier given a namespace and path(s)\n */\nvar generateEntryCacheId = function generateEntryCacheId(options) {\n  var id = options.namespace.id;\n  if (options.path) {\n    if (typeof options.path === 'string') {\n      id += '_' + options.path;\n    } else if (options.path.length) {\n      id += '_' + options.path.join('.');\n    }\n  } else if (options.paths && options.paths.length) {\n    var pathSet = {};\n    options.paths.forEach(function (path) {\n      pathSet[path.join('.')] = true;\n    });\n    var uniquePaths = Object.keys(pathSet);\n    uniquePaths.sort();\n    id += '_' + uniquePaths.join(',');\n  }\n  return id;\n};\nvar isFresh = function isFresh(storeEntryValue, ttl) {\n  var confTtl = window.CACHEABLE_TTL || {};\n  var ttlToCheck = typeof ttl !== 'undefined' ? ttl : confTtl[\"default\"];\n  if (!storeEntryValue.hueTimestamp || typeof ttlToCheck === 'undefined') {\n    return true;\n  }\n  return Date.now() - storeEntryValue.hueTimestamp < ttlToCheck;\n};\n\n/**\n * Helper function to fill a catalog entry with cached metadata.\n */\nvar mergeEntry = function mergeEntry(dataCatalogEntry, storeEntry) {\n  if (storeEntry.version !== DATA_CATALOG_VERSION) {\n    return;\n  }\n  if (storeEntry.definition && isFresh(storeEntry.definition)) {\n    dataCatalogEntry.definition = storeEntry.definition;\n  }\n  if (storeEntry.sourceMeta && isFresh(storeEntry.sourceMeta)) {\n    dataCatalogEntry.sourceMeta = storeEntry.sourceMeta;\n    dataCatalogEntry.sourceMetaPromise = CancellablePromise.resolve(dataCatalogEntry.sourceMeta);\n  }\n  if (storeEntry.analysis && isFresh(storeEntry.analysis)) {\n    dataCatalogEntry.analysis = storeEntry.analysis;\n    dataCatalogEntry.analysisPromise = CancellablePromise.resolve(dataCatalogEntry.analysis);\n  }\n  if (storeEntry.partitions && isFresh(storeEntry.partitions)) {\n    dataCatalogEntry.partitions = storeEntry.partitions;\n    dataCatalogEntry.partitionsPromise = CancellablePromise.resolve(dataCatalogEntry.partitions);\n  }\n  if (storeEntry.sample && isFresh(storeEntry.sample)) {\n    dataCatalogEntry.sample = storeEntry.sample;\n    dataCatalogEntry.samplePromise = CancellablePromise.resolve(dataCatalogEntry.sample);\n  }\n  if (storeEntry.navigatorMeta && isFresh(storeEntry.navigatorMeta)) {\n    dataCatalogEntry.navigatorMeta = storeEntry.navigatorMeta;\n    dataCatalogEntry.navigatorMetaPromise = CancellablePromise.resolve(dataCatalogEntry.navigatorMeta);\n  }\n  if (dataCatalogEntry.getConnector().optimizer !== SqlAnalyzerMode.local) {\n    var confTtl = window.CACHEABLE_TTL || {};\n    if (storeEntry.sqlAnalyzerMeta && isFresh(storeEntry.sqlAnalyzerMeta, confTtl.sqlAnalyzer)) {\n      dataCatalogEntry.sqlAnalyzerMeta = storeEntry.sqlAnalyzerMeta;\n      dataCatalogEntry.sqlAnalyzerMetaPromise = CancellablePromise.resolve(dataCatalogEntry.sqlAnalyzerMeta);\n    }\n    if (storeEntry.sqlAnalyzerPopularity && isFresh(storeEntry.sqlAnalyzerPopularity, confTtl.sqlAnalyzer)) {\n      dataCatalogEntry.sqlAnalyzerPopularity = storeEntry.sqlAnalyzerPopularity;\n    }\n  }\n};\n\n/**\n * Helper function to fill a multi table catalog entry with cached metadata.\n */\nvar mergeMultiTableEntry = function mergeMultiTableEntry(multiTableEntry, storeEntry) {\n  if (multiTableEntry.getConnector().optimizer === SqlAnalyzerMode.local || storeEntry.version !== DATA_CATALOG_VERSION) {\n    return;\n  }\n  var confTtl = window.CACHEABLE_TTL || {};\n  if (storeEntry.topAggs && isFresh(storeEntry.topAggs, confTtl.sqlAnalyzer)) {\n    multiTableEntry.topAggs = storeEntry.topAggs;\n    multiTableEntry.topAggsPromise = CancellablePromise.resolve(multiTableEntry.topAggs);\n  }\n  if (storeEntry.topColumns && isFresh(storeEntry.topColumns, confTtl.sqlAnalyzer)) {\n    multiTableEntry.topColumns = storeEntry.topColumns;\n    multiTableEntry.topColumnsPromise = CancellablePromise.resolve(multiTableEntry.topColumns);\n  }\n  if (storeEntry.topFilters && isFresh(storeEntry.topFilters, confTtl.sqlAnalyzer)) {\n    multiTableEntry.topFilters = storeEntry.topFilters;\n    multiTableEntry.topFiltersPromise = CancellablePromise.resolve(multiTableEntry.topFilters);\n  }\n  if (storeEntry.topJoins && isFresh(storeEntry.topJoins, confTtl.sqlAnalyzer)) {\n    multiTableEntry.topJoins = storeEntry.topJoins;\n    multiTableEntry.topJoinsPromise = CancellablePromise.resolve(multiTableEntry.topJoins);\n  }\n};\nexport var DataCatalog = /*#__PURE__*/function () {\n  function DataCatalog(connector) {\n    _classCallCheck(this, DataCatalog);\n    this.connector = void 0;\n    this.entries = {};\n    this.temporaryEntries = {};\n    this.multiTableEntries = {};\n    this.store = void 0;\n    this.multiTableStore = void 0;\n    this.invalidatePromise = void 0;\n    if (!connector || !connector.id) {\n      throw new Error('DataCatalog created without connector or id');\n    }\n    this.connector = connector;\n    this.store = localforage.createInstance({\n      name: 'HueDataCatalog_' + this.connector.id + '_' + STORAGE_POSTFIX\n    });\n    this.multiTableStore = localforage.createInstance({\n      name: 'HueDataCatalog_' + this.connector.id + '_multiTable_' + STORAGE_POSTFIX\n    });\n  }\n\n  /**\n   * Disables the caching for subsequent operations, mainly used for test purposes\n   */\n  return _createClass(DataCatalog, [{\n    key: \"canHaveSqlAnalyzerMeta\",\n    value:\n    /**\n     * Returns true if the catalog can have SQL Analyzer metadata\n     */\n    function canHaveSqlAnalyzerMeta() {\n      return !!(window.HAS_SQL_ANALYZER && this.connector && this.connector.optimizer && this.connector.optimizer !== SqlAnalyzerMode.off);\n    }\n\n    /**\n     * Clears the data catalog and cache for the given path and any children thereof.\n     */\n  }, {\n    key: \"clearStorageCascade\",\n    value: (function () {\n      var _clearStorageCascade = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(namespace, compute, pathToClear) {\n        var _this = this;\n        var keyPrefix, deletePromises, keys;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(!namespace || !compute)) {\n                _context.next = 5;\n                break;\n              }\n              if (!(!pathToClear || pathToClear.length === 0)) {\n                _context.next = 4;\n                break;\n              }\n              this.entries = {};\n              return _context.abrupt(\"return\", this.store.clear());\n            case 4:\n              return _context.abrupt(\"return\");\n            case 5:\n              keyPrefix = generateEntryCacheId({\n                namespace: namespace,\n                path: pathToClear\n              });\n              Object.keys(this.entries).forEach(function (key) {\n                if (key.indexOf(keyPrefix) === 0) {\n                  delete _this.entries[key];\n                }\n              });\n              deletePromises = [];\n              _context.prev = 8;\n              _context.next = 11;\n              return this.store.keys();\n            case 11:\n              keys = _context.sent;\n              keys.forEach(function (key) {\n                if (key.indexOf(keyPrefix) === 0) {\n                  deletePromises.push(_this.store.removeItem(key));\n                }\n              });\n              _context.next = 15;\n              return Promise.all(deletePromises);\n            case 15:\n              _context.next = 19;\n              break;\n            case 17:\n              _context.prev = 17;\n              _context.t0 = _context[\"catch\"](8);\n            case 19:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[8, 17]]);\n      }));\n      function clearStorageCascade(_x, _x2, _x3) {\n        return _clearStorageCascade.apply(this, arguments);\n      }\n      return clearStorageCascade;\n    }()\n    /**\n     * Updates the cache for the given entry\n     */\n    )\n  }, {\n    key: \"persistCatalogEntry\",\n    value: (function () {\n      var _persistCatalogEntry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(dataCatalogEntry) {\n        var confTtl, identifier;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              confTtl = window.CACHEABLE_TTL || {};\n              if (!(!_cacheEnabled || !confTtl[\"default\"] || confTtl[\"default\"] <= 0)) {\n                _context2.next = 3;\n                break;\n              }\n              return _context2.abrupt(\"return\");\n            case 3:\n              identifier = generateEntryCacheId(dataCatalogEntry);\n              _context2.next = 6;\n              return this.store.setItem(identifier, {\n                version: DATA_CATALOG_VERSION,\n                definition: dataCatalogEntry.definition,\n                sourceMeta: dataCatalogEntry.sourceMeta,\n                analysis: dataCatalogEntry.analysis,\n                partitions: dataCatalogEntry.partitions,\n                sample: dataCatalogEntry.sample,\n                navigatorMeta: dataCatalogEntry.navigatorMeta,\n                sqlAnalyzerMeta: this.connector.optimizer !== SqlAnalyzerMode.local ? dataCatalogEntry.sqlAnalyzerMeta : undefined,\n                sqlAnalyzerPopularity: this.connector.optimizer !== SqlAnalyzerMode.local ? dataCatalogEntry.sqlAnalyzerPopularity : undefined\n              });\n            case 6:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function persistCatalogEntry(_x4) {\n        return _persistCatalogEntry.apply(this, arguments);\n      }\n      return persistCatalogEntry;\n    }()\n    /**\n     * Loads SQL Analyzer popularity for multiple tables in one go.\n     */\n    )\n  }, {\n    key: \"loadSqlAnalyzerPopularityForTables\",\n    value: function loadSqlAnalyzerPopularityForTables(options) {\n      var _this2 = this;\n      var cancellablePromises = [];\n      var popularEntries = [];\n      var pathsToLoad = [];\n      var existingPromises = [];\n      options.paths.forEach(function (path) {\n        var existingPromise = new Promise( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(resolve, reject) {\n            var tableEntry, existingPopularEntries, childPromise, childEntries;\n            return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n              while (1) switch (_context3.prev = _context3.next) {\n                case 0:\n                  _context3.prev = 0;\n                  _context3.next = 3;\n                  return _this2.getEntry({\n                    namespace: options.namespace,\n                    compute: options.compute,\n                    path: path\n                  });\n                case 3:\n                  tableEntry = _context3.sent;\n                  if (!tableEntry.sqlAnalyzerPopularityForChildrenPromise) {\n                    _context3.next = 11;\n                    break;\n                  }\n                  _context3.next = 7;\n                  return tableEntry.sqlAnalyzerPopularityForChildrenPromise;\n                case 7:\n                  existingPopularEntries = _context3.sent;\n                  popularEntries.push.apply(popularEntries, _toConsumableArray(existingPopularEntries));\n                  _context3.next = 21;\n                  break;\n                case 11:\n                  if (!(tableEntry.definition && tableEntry.definition.sqlAnalyzerLoaded)) {\n                    _context3.next = 20;\n                    break;\n                  }\n                  childPromise = tableEntry.getChildren(_objectSpread(_objectSpread({}, options), {}, {\n                    silenceErrors: true\n                  }));\n                  cancellablePromises.push(childPromise);\n                  _context3.next = 16;\n                  return childPromise;\n                case 16:\n                  childEntries = _context3.sent;\n                  childEntries.forEach(function (childEntry) {\n                    if (childEntry.sqlAnalyzerPopularity) {\n                      popularEntries.push(childEntry);\n                    }\n                  });\n                  _context3.next = 21;\n                  break;\n                case 20:\n                  pathsToLoad.push(path);\n                case 21:\n                  _context3.next = 26;\n                  break;\n                case 23:\n                  _context3.prev = 23;\n                  _context3.t0 = _context3[\"catch\"](0);\n                  reject(_context3.t0);\n                case 26:\n                  resolve();\n                case 27:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }, _callee3, null, [[0, 23]]);\n          }));\n          return function (_x5, _x6) {\n            return _ref.apply(this, arguments);\n          };\n        }());\n        existingPromises.push(existingPromise);\n      });\n      var popularityPromise = new CancellablePromise( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(resolve, reject, onCancel) {\n          var fetchPromise, data, perTable, splitSqlAnalyzerValuesPerTable, tablePromises;\n          return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n            while (1) switch (_context5.prev = _context5.next) {\n              case 0:\n                onCancel(function () {\n                  cancellablePromises.forEach(function (cancellable) {\n                    cancellable.cancel();\n                  });\n                });\n                _context5.prev = 1;\n                _context5.next = 4;\n                return Promise.all(existingPromises);\n              case 4:\n                _context5.next = 8;\n                break;\n              case 6:\n                _context5.prev = 6;\n                _context5.t0 = _context5[\"catch\"](1);\n              case 8:\n                if (pathsToLoad.length) {\n                  _context5.next = 11;\n                  break;\n                }\n                resolve(popularEntries);\n                return _context5.abrupt(\"return\");\n              case 11:\n                fetchPromise = options.sqlAnalyzer.fetchPopularity({\n                  silenceErrors: true,\n                  paths: pathsToLoad\n                });\n                cancellablePromises.push(fetchPromise);\n                _context5.prev = 13;\n                _context5.next = 16;\n                return fetchPromise;\n              case 16:\n                data = _context5.sent;\n                perTable = {};\n                splitSqlAnalyzerValuesPerTable = function splitSqlAnalyzerValuesPerTable(listName) {\n                  var values = data.values && data.values[listName];\n                  if (values) {\n                    values.forEach(function (column) {\n                      var tableMeta = perTable[column.dbName + '.' + column.tableName];\n                      if (!tableMeta) {\n                        tableMeta = {\n                          values: {}\n                        };\n                        perTable[column.dbName + '.' + column.tableName] = tableMeta;\n                      }\n                      if (tableMeta.values) {\n                        var valuesList = tableMeta.values[listName];\n                        if (!valuesList) {\n                          valuesList = [];\n                          tableMeta.values[listName] = valuesList;\n                        }\n                        valuesList.push(column);\n                      }\n                    });\n                  }\n                };\n                if (data.values) {\n                  splitSqlAnalyzerValuesPerTable('filterColumns');\n                  splitSqlAnalyzerValuesPerTable('groupbyColumns');\n                  splitSqlAnalyzerValuesPerTable('joinColumns');\n                  splitSqlAnalyzerValuesPerTable('orderbyColumns');\n                  splitSqlAnalyzerValuesPerTable('selectColumns');\n                }\n                tablePromises = Object.keys(perTable).map(function (path) {\n                  return new Promise( /*#__PURE__*/function () {\n                    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(resolve) {\n                      var entry, applyPromise;\n                      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                        while (1) switch (_context4.prev = _context4.next) {\n                          case 0:\n                            _context4.prev = 0;\n                            _context4.next = 3;\n                            return _this2.getEntry({\n                              namespace: options.namespace,\n                              compute: options.compute,\n                              path: path\n                            });\n                          case 3:\n                            entry = _context4.sent;\n                            applyPromise = entry.applySqlAnalyzerResponseToChildren(perTable[path], _objectSpread(_objectSpread({}, options), {}, {\n                              silenceErrors: true\n                            }));\n                            cancellablePromises.push(applyPromise);\n                            _context4.t0 = popularEntries.push;\n                            _context4.t1 = popularEntries;\n                            _context4.t2 = _toConsumableArray;\n                            _context4.next = 11;\n                            return applyPromise;\n                          case 11:\n                            _context4.t3 = _context4.sent;\n                            _context4.t4 = (0, _context4.t2)(_context4.t3);\n                            _context4.t0.apply.call(_context4.t0, _context4.t1, _context4.t4);\n                            _context4.next = 18;\n                            break;\n                          case 16:\n                            _context4.prev = 16;\n                            _context4.t5 = _context4[\"catch\"](0);\n                          case 18:\n                            resolve();\n                          case 19:\n                          case \"end\":\n                            return _context4.stop();\n                        }\n                      }, _callee4, null, [[0, 16]]);\n                    }));\n                    return function (_x10) {\n                      return _ref3.apply(this, arguments);\n                    };\n                  }());\n                });\n                Promise.all(tablePromises)[\"finally\"](function () {\n                  resolve(popularEntries);\n                });\n                _context5.next = 27;\n                break;\n              case 24:\n                _context5.prev = 24;\n                _context5.t1 = _context5[\"catch\"](13);\n                resolve(popularEntries);\n              case 27:\n              case \"end\":\n                return _context5.stop();\n            }\n          }, _callee5, null, [[1, 6], [13, 24]]);\n        }));\n        return function (_x7, _x8, _x9) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n      return applyCancellable(popularityPromise);\n    }\n  }, {\n    key: \"getKnownEntry\",\n    value: function () {\n      var _getKnownEntry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(options) {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              return _context6.abrupt(\"return\", this.entries[generateEntryCacheId(options)]);\n            case 1:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function getKnownEntry(_x11) {\n        return _getKnownEntry.apply(this, arguments);\n      }\n      return getKnownEntry;\n    }()\n    /**\n     * Adds a temporary table to the data catalog. This would allow autocomplete etc. of tables that haven't\n     * been created yet.\n     *\n     * Calling this returns a handle that allows deletion of any created entries by calling delete() on the handle.\n     */\n  }, {\n    key: \"addTemporaryTable\",\n    value: function addTemporaryTable(options) {\n      var _this3 = this;\n      var database = options.database || 'default';\n      var path = [database, options.name];\n      var identifiersToClean = [];\n      var addEntryMeta = function addEntryMeta(entry, sourceMeta) {\n        entry.sourceMeta = sourceMeta || entry.definition;\n        entry.sourceMetaPromise = CancellablePromise.resolve(entry.sourceMeta);\n      };\n      var sourceIdentifier = generateEntryCacheId({\n        namespace: options.namespace,\n        path: []\n      });\n\n      // Create the source entry if not already present\n      if (!this.temporaryEntries[sourceIdentifier]) {\n        var sourceEntry = new DataCatalogEntry({\n          isTemporary: true,\n          dataCatalog: this,\n          namespace: options.namespace,\n          compute: options.compute,\n          path: [],\n          definition: {\n            index: 0,\n            sqlAnalyzerLoaded: true,\n            type: 'source'\n          }\n        });\n        addEntryMeta(sourceEntry);\n        identifiersToClean.push(sourceIdentifier);\n        sourceEntry.childrenPromise = CancellablePromise.resolve([]);\n        this.temporaryEntries[sourceIdentifier] = Promise.resolve(sourceEntry);\n      }\n      this.temporaryEntries[sourceIdentifier].then( /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(sourceEntry) {\n          var existingTemporaryDatabases, databaseIdentifier, _databaseEntry, databaseEntry, existingTemporaryTables, tableIdentifier, _tableEntry, index, tableEntry, tableSourceMeta, columnEntries;\n          return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n            while (1) switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return sourceEntry.getChildren();\n              case 2:\n                existingTemporaryDatabases = _context7.sent;\n                databaseIdentifier = generateEntryCacheId({\n                  namespace: options.namespace,\n                  path: [database]\n                }); // Create the database entry if not already present\n                if (!_this3.temporaryEntries[databaseIdentifier]) {\n                  _databaseEntry = new DataCatalogEntry({\n                    isTemporary: true,\n                    dataCatalog: _this3,\n                    namespace: options.namespace,\n                    compute: options.compute,\n                    path: [database],\n                    definition: {\n                      index: 0,\n                      sqlAnalyzerLoaded: true,\n                      type: 'database'\n                    }\n                  });\n                  addEntryMeta(_databaseEntry);\n                  _databaseEntry.childrenPromise = CancellablePromise.resolve([]);\n                  identifiersToClean.push(databaseIdentifier);\n                  existingTemporaryDatabases.push(_databaseEntry);\n                  _this3.temporaryEntries[databaseIdentifier] = Promise.resolve(_databaseEntry);\n                }\n                _context7.next = 7;\n                return _this3.temporaryEntries[databaseIdentifier];\n              case 7:\n                databaseEntry = _context7.sent;\n                _context7.next = 10;\n                return databaseEntry.getChildren();\n              case 10:\n                existingTemporaryTables = _context7.sent;\n                tableIdentifier = generateEntryCacheId({\n                  namespace: options.namespace,\n                  path: path\n                }); // Unlink any existing table with the same identifier\n                if (!_this3.temporaryEntries[tableIdentifier]) {\n                  _context7.next = 18;\n                  break;\n                }\n                _context7.next = 15;\n                return _this3.temporaryEntries[tableIdentifier];\n              case 15:\n                _tableEntry = _context7.sent;\n                index = existingTemporaryTables.indexOf(_tableEntry);\n                if (index !== -1) {\n                  existingTemporaryTables.splice(index, 1);\n                }\n              case 18:\n                tableEntry = new DataCatalogEntry({\n                  isTemporary: true,\n                  dataCatalog: _this3,\n                  namespace: options.namespace,\n                  compute: options.compute,\n                  path: path,\n                  definition: {\n                    comment: '',\n                    index: existingTemporaryTables.length,\n                    name: options.name,\n                    sqlAnalyzerLoaded: true,\n                    type: 'table'\n                  }\n                });\n                existingTemporaryTables.push(tableEntry);\n                tableSourceMeta = {\n                  columns: (options.columns || []).map(function (col) {\n                    return col.name;\n                  }),\n                  extended_columns: options.columns || [],\n                  comment: '',\n                  notFound: false,\n                  is_view: false\n                };\n                addEntryMeta(tableEntry, tableSourceMeta);\n                tableEntry.sample = {\n                  data: options.sample,\n                  meta: options.columns,\n                  type: 'table'\n                };\n                tableEntry.samplePromise = CancellablePromise.resolve(tableEntry.sample);\n                identifiersToClean.push(tableIdentifier);\n                _this3.temporaryEntries[tableIdentifier] = Promise.resolve(tableEntry);\n                columnEntries = [];\n                tableEntry.childrenPromise = CancellablePromise.resolve(columnEntries);\n                options.columns.forEach(function (column, index) {\n                  var columnPath = [].concat(path, [column.name]);\n                  var columnEntry = new DataCatalogEntry({\n                    isTemporary: true,\n                    dataCatalog: _this3,\n                    namespace: options.namespace,\n                    compute: options.compute,\n                    path: columnPath,\n                    definition: {\n                      comment: '',\n                      index: index,\n                      name: column.name,\n                      partitionKey: false,\n                      type: column.type\n                    }\n                  });\n                  columnEntry.sample = {\n                    data: options.sample.map(function (sampleRow) {\n                      return [sampleRow[index]];\n                    }),\n                    meta: [column],\n                    type: 'table'\n                  };\n                  columnEntry.samplePromise = CancellablePromise.resolve(columnEntry.sample);\n                  tableSourceMeta.columns.push(column.name);\n                  tableSourceMeta.extended_columns.push(columnEntry.definition);\n                  addEntryMeta(columnEntry, {\n                    comment: '',\n                    name: column.name,\n                    notFound: false,\n                    sample: columnEntry.sample.data,\n                    type: column.type\n                  });\n                  var columnIdentifier = generateEntryCacheId({\n                    namespace: options.namespace,\n                    path: columnPath\n                  });\n                  identifiersToClean.push(columnIdentifier);\n                  _this3.temporaryEntries[columnIdentifier] = CancellablePromise.resolve(columnEntry);\n                });\n              case 29:\n              case \"end\":\n                return _context7.stop();\n            }\n          }, _callee7);\n        }));\n        return function (_x12) {\n          return _ref4.apply(this, arguments);\n        };\n      }());\n      return {\n        \"delete\": function _delete() {\n          while (identifiersToClean.length) {\n            var nextToDelete = identifiersToClean.pop();\n            if (nextToDelete) {\n              delete _this3.temporaryEntries[nextToDelete];\n            }\n          }\n        }\n      };\n    }\n  }, {\n    key: \"getEntry\",\n    value: function () {\n      var _getEntry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(options) {\n        var _this4 = this;\n        var identifier;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              identifier = generateEntryCacheId(options);\n              if (!options.temporaryOnly) {\n                _context8.next = 3;\n                break;\n              }\n              return _context8.abrupt(\"return\", this.temporaryEntries[identifier] || $.Deferred().reject().promise());\n            case 3:\n              if (!this.entries[identifier]) {\n                _context8.next = 5;\n                break;\n              }\n              return _context8.abrupt(\"return\", this.entries[identifier]);\n            case 5:\n              this.entries[identifier] = new Promise(function (resolve) {\n                if (!_cacheEnabled) {\n                  resolve(new DataCatalogEntry({\n                    dataCatalog: _this4,\n                    namespace: options.namespace,\n                    compute: options.compute,\n                    path: options.path,\n                    definition: options.definition\n                  }));\n                } else {\n                  _this4.store.getItem(identifier).then(function (storeEntry) {\n                    var definition = storeEntry ? storeEntry.definition : options.definition;\n                    var entry = new DataCatalogEntry({\n                      dataCatalog: _this4,\n                      namespace: options.namespace,\n                      compute: options.compute,\n                      path: options.path,\n                      definition: definition\n                    });\n                    if (storeEntry) {\n                      mergeEntry(entry, storeEntry);\n                    } else if (!options.cachedOnly && options.definition) {\n                      entry.saveLater();\n                    }\n                    resolve(entry);\n                  })[\"catch\"](function (error) {\n                    console.warn(error);\n                    var entry = new DataCatalogEntry({\n                      dataCatalog: _this4,\n                      namespace: options.namespace,\n                      compute: options.compute,\n                      path: options.path,\n                      definition: options.definition\n                    });\n                    if (!options.cachedOnly && options.definition) {\n                      entry.saveLater();\n                    }\n                    resolve(entry);\n                  });\n                }\n              });\n              return _context8.abrupt(\"return\", this.entries[identifier]);\n            case 7:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this);\n      }));\n      function getEntry(_x13) {\n        return _getEntry.apply(this, arguments);\n      }\n      return getEntry;\n    }()\n  }, {\n    key: \"getMultiTableEntry\",\n    value: function () {\n      var _getMultiTableEntry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(options) {\n        var _this5 = this;\n        var identifier, newEntry;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              identifier = generateEntryCacheId(options);\n              if (!this.multiTableEntries[identifier]) {\n                _context10.next = 3;\n                break;\n              }\n              return _context10.abrupt(\"return\", this.multiTableEntries[identifier]);\n            case 3:\n              newEntry = new MultiTableEntry({\n                identifier: identifier,\n                dataCatalog: this,\n                paths: options.paths\n              });\n              this.multiTableEntries[identifier] = new Promise( /*#__PURE__*/function () {\n                var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(resolve) {\n                  var storeEntry;\n                  return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n                    while (1) switch (_context9.prev = _context9.next) {\n                      case 0:\n                        if (_cacheEnabled) {\n                          _context9.next = 3;\n                          break;\n                        }\n                        resolve(newEntry);\n                        return _context9.abrupt(\"return\");\n                      case 3:\n                        _context9.prev = 3;\n                        _context9.next = 6;\n                        return _this5.multiTableStore.getItem(identifier);\n                      case 6:\n                        storeEntry = _context9.sent;\n                        if (storeEntry) {\n                          mergeMultiTableEntry(newEntry, storeEntry);\n                        }\n                        _context9.next = 13;\n                        break;\n                      case 10:\n                        _context9.prev = 10;\n                        _context9.t0 = _context9[\"catch\"](3);\n                        console.warn(_context9.t0);\n                      case 13:\n                        resolve(newEntry);\n                      case 14:\n                      case \"end\":\n                        return _context9.stop();\n                    }\n                  }, _callee9, null, [[3, 10]]);\n                }));\n                return function (_x15) {\n                  return _ref5.apply(this, arguments);\n                };\n              }());\n              return _context10.abrupt(\"return\", this.multiTableEntries[identifier]);\n            case 6:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this);\n      }));\n      function getMultiTableEntry(_x14) {\n        return _getMultiTableEntry.apply(this, arguments);\n      }\n      return getMultiTableEntry;\n    }()\n    /**\n     * Updates the cache for the given multi table entry\n     */\n  }, {\n    key: \"persistMultiTableEntry\",\n    value: (function () {\n      var _persistMultiTableEntry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(multiTableEntry) {\n        var confTtl;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              confTtl = window.CACHEABLE_TTL || {};\n              if (!(!_cacheEnabled || confTtl[\"default\"] && confTtl[\"default\"] <= 0 || confTtl.sqlAnalyzer && confTtl.sqlAnalyzer <= 0 || multiTableEntry.getConnector().optimizer === SqlAnalyzerMode.local)) {\n                _context11.next = 3;\n                break;\n              }\n              return _context11.abrupt(\"return\");\n            case 3:\n              _context11.next = 5;\n              return this.multiTableStore.setItem(multiTableEntry.identifier, {\n                version: DATA_CATALOG_VERSION,\n                topAggs: multiTableEntry.topAggs,\n                topColumns: multiTableEntry.topColumns,\n                topFilters: multiTableEntry.topFilters,\n                topJoins: multiTableEntry.topJoins\n              });\n            case 5:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this);\n      }));\n      function persistMultiTableEntry(_x16) {\n        return _persistMultiTableEntry.apply(this, arguments);\n      }\n      return persistMultiTableEntry;\n    }())\n  }], [{\n    key: \"disableCache\",\n    value: function disableCache() {\n      _cacheEnabled = false;\n    }\n\n    /**\n     * Enables the cache for subsequent operations, mainly used for test purposes\n     */\n  }, {\n    key: \"enableCache\",\n    value: function enableCache() {\n      _cacheEnabled = true;\n    }\n  }, {\n    key: \"cacheEnabled\",\n    value: function cacheEnabled() {\n      return _cacheEnabled;\n    }\n  }]);\n}();\nvar generalDataCatalog = new GeneralDataCatalog();\nvar sourceBoundCatalogs = {};\n\n/**\n * Helper function to get the DataCatalog instance for a given data source.\n */\nvar getCatalog = function getCatalog(connector) {\n  if (!connector || !connector.id) {\n    throw new Error('getCatalog called without connector with id');\n  }\n  return sourceBoundCatalogs[connector.id] || (sourceBoundCatalogs[connector.id] = new DataCatalog(connector));\n};\nexport default {\n  /**\n   * Adds a detached (temporary) entry to the data catalog. This would allow autocomplete etc. of tables that haven't\n   * been created yet.\n   *\n   * Calling this returns a handle that allows deletion of any created entries by calling delete() on the handle.\n   */\n  addTemporaryTable: function addTemporaryTable(options) {\n    return getCatalog(options.connector).addTemporaryTable(options);\n  },\n  getEntry: function getEntry(options) {\n    return getCatalog(options.connector).getEntry(options);\n  },\n  getMultiTableEntry: function getMultiTableEntry(options) {\n    return getCatalog(options.connector).getMultiTableEntry(options);\n  },\n  /**\n   * This can be used as a shorthand function to get the child entries of the given path. Same as first calling\n   * getEntry then getChildren.\n   */\n  getChildren: function getChildren(options) {\n    return new CancellablePromise( /*#__PURE__*/function () {\n      var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(resolve, reject, onCancel) {\n        var entry, childPromise;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              _context12.prev = 0;\n              _context12.next = 3;\n              return getCatalog(options.connector).getEntry(options);\n            case 3:\n              entry = _context12.sent;\n              childPromise = entry.getChildren(options);\n              onCancel(function () {\n                childPromise.cancel();\n              });\n              resolve(applyCancellable(childPromise, options));\n              _context12.next = 12;\n              break;\n            case 9:\n              _context12.prev = 9;\n              _context12.t0 = _context12[\"catch\"](0);\n              reject(_context12.t0);\n            case 12:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, null, [[0, 9]]);\n      }));\n      return function (_x17, _x18, _x19) {\n        return _ref6.apply(this, arguments);\n      };\n    }());\n  },\n  getCatalog: getCatalog,\n  getAllNavigatorTags: generalDataCatalog.getAllNavigatorTags.bind(generalDataCatalog),\n  updateAllNavigatorTags: generalDataCatalog.updateAllNavigatorTags.bind(generalDataCatalog),\n  enableCache: function enableCache() {\n    _cacheEnabled = true;\n  },\n  disableCache: function disableCache() {\n    _cacheEnabled = false;\n  }\n};","// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nexport var REFRESH_CONTEXT_CATALOG_TOPIC = 'context.catalog.refresh';\nexport var CONTEXT_CATALOG_REFRESHED_TOPIC = 'context.catalog.refreshed';\nexport var NAMESPACES_REFRESHED_TOPIC = 'context.catalog.namespaces.refreshed';"],"names":[],"sourceRoot":""}
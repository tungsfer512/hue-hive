{"version":3,"file":"hue-7cb30146-bundle-a2a4f8506cb55bb7.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACpmEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///./desktop/core/src/desktop/js/catalog/DataCatalogEntry.ts","webpack:///./desktop/core/src/desktop/js/catalog/GeneralDataCatalog.ts","webpack:///./desktop/core/src/desktop/js/catalog/MultiTableEntry.ts"],"sourcesContent":["function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport * as ko from 'knockout';\nimport { CancellablePromise } from 'api/cancellablePromise';\nimport { addNavTags, deleteNavTags, fetchDescribe, fetchNavigatorMetadata, fetchPartitions, fetchSample, fetchSourceMetadata, searchEntities, updateNavigatorProperties, updateSourceMetadata } from 'catalog/api';\nimport { applyCancellable, forceSilencedErrors } from 'catalog/catalogUtils';\nimport huePubSub from 'utils/huePubSub';\nimport I18n from \"../utils/i18n\";\nimport { executeSingleStatement } from 'apps/editor/execution/api';\nimport { DataCatalog } from \"./dataCatalog\";\nvar cachedOnly = function cachedOnly(options) {\n  return !!(options && options.cachedOnly);\n};\nvar shouldReload = function shouldReload(options) {\n  return !!(!DataCatalog.cacheEnabled() || options && (options.refreshCache || options.refreshAnalysis));\n};\n\n/**\n * Helper function to get the multi table catalog version of a catalog entry\n */\nvar getMultiTableEntry = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(catalogEntry) {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (catalogEntry.isTableOrView()) {\n            _context.next = 2;\n            break;\n          }\n          return _context.abrupt(\"return\", Promise.reject());\n        case 2:\n          return _context.abrupt(\"return\", catalogEntry.dataCatalog.getMultiTableEntry({\n            namespace: catalogEntry.namespace,\n            compute: catalogEntry.compute,\n            paths: [catalogEntry.path]\n          }));\n        case 3:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function getMultiTableEntry(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nvar DataCatalogEntry = /*#__PURE__*/function () {\n  function DataCatalogEntry(options) {\n    _classCallCheck(this, DataCatalogEntry);\n    this.compute = void 0;\n    this.dataCatalog = void 0;\n    this.definition = void 0;\n    this.isTemporary = void 0;\n    this.name = void 0;\n    this.namespace = void 0;\n    this.path = void 0;\n    this.saveTimeout = -1;\n    this.commentObservable = void 0;\n    this.analysis = void 0;\n    this.analysisPromise = void 0;\n    this.childrenPromise = void 0;\n    this.navigatorMeta = void 0;\n    this.navigatorMetaForChildrenPromise = void 0;\n    this.navigatorMetaPromise = void 0;\n    this.sqlAnalyzerMeta = void 0;\n    this.sqlAnalyzerMetaPromise = void 0;\n    this.sqlAnalyzerPopularity = void 0;\n    this.sqlAnalyzerPopularityForChildrenPromise = void 0;\n    this.partitions = void 0;\n    this.partitionsPromise = void 0;\n    this.sample = void 0;\n    this.samplePromise = void 0;\n    this.sourceMeta = void 0;\n    this.sourceMetaPromise = void 0;\n    if (!options.dataCatalog.connector) {\n      throw new Error('DataCatalogEntry created without connector');\n    }\n    this.namespace = options.namespace;\n    this.compute = options.compute;\n    this.dataCatalog = options.dataCatalog;\n    this.path = typeof options.path === 'string' ? options.path.split('.') : options.path || [];\n    this.name = this.path.length ? this.path[this.path.length - 1] : this.getConnector().id;\n    this.isTemporary = options.isTemporary;\n    if (options.definition) {\n      this.definition = options.definition;\n    } else if (this.path.length === 0) {\n      this.definition = {\n        type: 'source'\n      };\n    } else if (this.path.length === 1) {\n      this.definition = {\n        type: 'database'\n      };\n    } else if (this.path.length === 2) {\n      this.definition = {\n        type: 'table'\n      };\n    }\n    this.reset();\n  }\n\n  /**\n   * Resets the entry to an empty state, it might still have some details cached\n   */\n  return _createClass(DataCatalogEntry, [{\n    key: \"reset\",\n    value: function reset() {\n      this.saveTimeout = -1;\n      this.analysis = undefined;\n      this.analysisPromise = undefined;\n      this.childrenPromise = undefined;\n      this.navigatorMeta = undefined;\n      this.navigatorMetaForChildrenPromise = undefined;\n      this.navigatorMetaPromise = undefined;\n      this.sqlAnalyzerMeta = undefined;\n      this.sqlAnalyzerMetaPromise = undefined;\n      this.sqlAnalyzerPopularity = undefined;\n      this.sqlAnalyzerPopularityForChildrenPromise = undefined;\n      this.partitions = undefined;\n      this.partitionsPromise = undefined;\n      this.sample = undefined;\n      this.samplePromise = undefined;\n      this.sourceMeta = undefined;\n      this.sourceMetaPromise = undefined;\n      if (this.path.length) {\n        this.dataCatalog.getKnownEntry({\n          namespace: this.namespace,\n          compute: this.compute,\n          path: this.path.slice(0, this.path.length - 1)\n        }).then(function (parent) {\n          if (parent) {\n            parent.navigatorMetaForChildrenPromise = undefined;\n            parent.sqlAnalyzerPopularityForChildrenPromise = undefined;\n          }\n        })[\"catch\"](function (err) {\n          console.warn(err);\n        });\n      }\n    }\n\n    /**\n     * Resets the entry and clears the cache\n     */\n  }, {\n    key: \"clearCache\",\n    value: (function () {\n      var _clearCache = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(options) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!options) {\n                options = {};\n              }\n              if (this.definition && this.definition.sqlAnalyzerLoaded) {\n                delete this.definition.sqlAnalyzerLoaded;\n              }\n              this.reset();\n              _context2.prev = 3;\n              if (!options.cascade) {\n                _context2.next = 9;\n                break;\n              }\n              _context2.next = 7;\n              return this.dataCatalog.clearStorageCascade(this.namespace, this.compute, this.path);\n            case 7:\n              _context2.next = 11;\n              break;\n            case 9:\n              _context2.next = 11;\n              return this.save();\n            case 11:\n              _context2.next = 15;\n              break;\n            case 13:\n              _context2.prev = 13;\n              _context2.t0 = _context2[\"catch\"](3);\n            case 15:\n              huePubSub.publish('data.catalog.entry.refreshed', {\n                entry: this,\n                cascade: !!options.cascade\n              });\n            case 16:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[3, 13]]);\n      }));\n      function clearCache(_x2) {\n        return _clearCache.apply(this, arguments);\n      }\n      return clearCache;\n    }())\n  }, {\n    key: \"reloadAnalysis\",\n    value: function reloadAnalysis(options) {\n      var _this = this;\n      this.analysisPromise = new CancellablePromise( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(resolve, reject, onCancel) {\n          var fetchPromise;\n          return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n            while (1) switch (_context3.prev = _context3.next) {\n              case 0:\n                fetchPromise = fetchDescribe(_objectSpread({\n                  entry: _this\n                }, options));\n                onCancel(function () {\n                  fetchPromise.cancel();\n                });\n                _context3.prev = 2;\n                _context3.next = 5;\n                return fetchPromise;\n              case 5:\n                _this.analysis = _context3.sent;\n                resolve(_this.analysis);\n                _context3.next = 13;\n                break;\n              case 9:\n                _context3.prev = 9;\n                _context3.t0 = _context3[\"catch\"](2);\n                reject(_context3.t0 || 'Fetch failed');\n                return _context3.abrupt(\"return\");\n              case 13:\n                _this.saveLater();\n              case 14:\n              case \"end\":\n                return _context3.stop();\n            }\n          }, _callee3, null, [[2, 9]]);\n        }));\n        return function (_x3, _x4, _x5) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n      return applyCancellable(this.analysisPromise, options);\n    }\n  }, {\n    key: \"reloadNavigatorMeta\",\n    value: function reloadNavigatorMeta(options) {\n      var _this2 = this;\n      if (this.canHaveNavigatorMetadata()) {\n        this.navigatorMetaPromise = new CancellablePromise( /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(resolve, reject) {\n            return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n              while (1) switch (_context4.prev = _context4.next) {\n                case 0:\n                  _context4.prev = 0;\n                  _context4.next = 3;\n                  return fetchNavigatorMetadata(_objectSpread(_objectSpread({}, options), {}, {\n                    entry: _this2\n                  }));\n                case 3:\n                  _this2.navigatorMeta = _context4.sent;\n                  resolve(_this2.navigatorMeta);\n                  _context4.next = 11;\n                  break;\n                case 7:\n                  _context4.prev = 7;\n                  _context4.t0 = _context4[\"catch\"](0);\n                  reject(_context4.t0 || 'Fetch failed');\n                  return _context4.abrupt(\"return\");\n                case 11:\n                  _this2.saveLater();\n                  if (_this2.commentObservable) {\n                    _this2.commentObservable(_this2.getResolvedComment());\n                  }\n                case 13:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }, _callee4, null, [[0, 7]]);\n          }));\n          return function (_x6, _x7) {\n            return _ref3.apply(this, arguments);\n          };\n        }());\n      } else {\n        this.navigatorMetaPromise = CancellablePromise.reject();\n      }\n      return applyCancellable(this.navigatorMetaPromise);\n    }\n\n    /**\n     * Helper function to reload the nav opt metadata for the given entry\n     */\n  }, {\n    key: \"reloadSqlAnalyzerMeta\",\n    value: function reloadSqlAnalyzerMeta(_ref4) {\n      var _this3 = this;\n      var cancellable = _ref4.cancellable,\n        silenceErrors = _ref4.silenceErrors,\n        sqlAnalyzer = _ref4.sqlAnalyzer;\n      if (this.dataCatalog.canHaveSqlAnalyzerMeta()) {\n        this.sqlAnalyzerMetaPromise = new CancellablePromise( /*#__PURE__*/function () {\n          var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(resolve, reject, onCancel) {\n            var fetchPromise;\n            return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n              while (1) switch (_context5.prev = _context5.next) {\n                case 0:\n                  fetchPromise = sqlAnalyzer.fetchSqlAnalyzerMeta({\n                    path: _this3.path,\n                    silenceErrors: silenceErrors\n                  });\n                  onCancel(function () {\n                    fetchPromise.cancel();\n                  });\n                  _context5.prev = 2;\n                  _context5.next = 5;\n                  return fetchPromise;\n                case 5:\n                  _this3.sqlAnalyzerMeta = _context5.sent;\n                  resolve(_this3.sqlAnalyzerMeta);\n                  _context5.next = 13;\n                  break;\n                case 9:\n                  _context5.prev = 9;\n                  _context5.t0 = _context5[\"catch\"](2);\n                  reject(_context5.t0 || 'Fetch failed');\n                  return _context5.abrupt(\"return\");\n                case 13:\n                  _this3.saveLater();\n                case 14:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }, _callee5, null, [[2, 9]]);\n          }));\n          return function (_x8, _x9, _x10) {\n            return _ref5.apply(this, arguments);\n          };\n        }());\n      } else {\n        this.sqlAnalyzerMetaPromise = CancellablePromise.reject();\n      }\n      return applyCancellable(this.sqlAnalyzerMetaPromise, {\n        cancellable: cancellable\n      });\n    }\n  }, {\n    key: \"reloadPartitions\",\n    value: function reloadPartitions(options) {\n      var _this4 = this;\n      this.partitionsPromise = new CancellablePromise( /*#__PURE__*/function () {\n        var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(resolve, reject) {\n          return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n            while (1) switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.prev = 0;\n                _context6.next = 3;\n                return fetchPartitions(_objectSpread(_objectSpread({}, options), {}, {\n                  entry: _this4\n                }));\n              case 3:\n                _this4.partitions = _context6.sent;\n                resolve(_this4.partitions);\n                _context6.next = 11;\n                break;\n              case 7:\n                _context6.prev = 7;\n                _context6.t0 = _context6[\"catch\"](0);\n                reject(_context6.t0 || 'Fetch failed');\n                return _context6.abrupt(\"return\");\n              case 11:\n                _this4.saveLater();\n              case 12:\n              case \"end\":\n                return _context6.stop();\n            }\n          }, _callee6, null, [[0, 7]]);\n        }));\n        return function (_x11, _x12) {\n          return _ref6.apply(this, arguments);\n        };\n      }());\n      return applyCancellable(this.partitionsPromise, options);\n    }\n  }, {\n    key: \"reloadSample\",\n    value: function reloadSample(options) {\n      var _this5 = this;\n      this.samplePromise = new CancellablePromise( /*#__PURE__*/function () {\n        var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(resolve, reject) {\n          return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n            while (1) switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.prev = 0;\n                _context7.next = 3;\n                return fetchSample(_objectSpread(_objectSpread({}, options), {}, {\n                  entry: _this5\n                }));\n              case 3:\n                _this5.sample = _context7.sent;\n                resolve(_this5.sample);\n                _context7.next = 11;\n                break;\n              case 7:\n                _context7.prev = 7;\n                _context7.t0 = _context7[\"catch\"](0);\n                reject(_context7.t0 || 'Fetch failed');\n                return _context7.abrupt(\"return\");\n              case 11:\n                _this5.saveLater();\n              case 12:\n              case \"end\":\n                return _context7.stop();\n            }\n          }, _callee7, null, [[0, 7]]);\n        }));\n        return function (_x13, _x14) {\n          return _ref7.apply(this, arguments);\n        };\n      }());\n      return applyCancellable(this.samplePromise, options);\n    }\n  }, {\n    key: \"reloadSourceMeta\",\n    value: function reloadSourceMeta(options) {\n      var _this6 = this;\n      this.sourceMetaPromise = new CancellablePromise( /*#__PURE__*/function () {\n        var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(resolve, reject) {\n          return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n            while (1) switch (_context8.prev = _context8.next) {\n              case 0:\n                if (!_this6.dataCatalog.invalidatePromise) {\n                  _context8.next = 8;\n                  break;\n                }\n                _context8.prev = 1;\n                _context8.next = 4;\n                return _this6.dataCatalog.invalidatePromise;\n              case 4:\n                _context8.next = 8;\n                break;\n              case 6:\n                _context8.prev = 6;\n                _context8.t0 = _context8[\"catch\"](1);\n              case 8:\n                _context8.prev = 8;\n                _context8.next = 11;\n                return fetchSourceMetadata(_objectSpread(_objectSpread({}, options), {}, {\n                  entry: _this6\n                }));\n              case 11:\n                _this6.sourceMeta = _context8.sent;\n                resolve(_this6.sourceMeta);\n                _context8.next = 19;\n                break;\n              case 15:\n                _context8.prev = 15;\n                _context8.t1 = _context8[\"catch\"](8);\n                reject(_context8.t1 || 'Fetch failed');\n                return _context8.abrupt(\"return\");\n              case 19:\n                _this6.saveLater();\n              case 20:\n              case \"end\":\n                return _context8.stop();\n            }\n          }, _callee8, null, [[1, 6], [8, 15]]);\n        }));\n        return function (_x15, _x16) {\n          return _ref8.apply(this, arguments);\n        };\n      }());\n      return applyCancellable(this.sourceMetaPromise, options);\n    }\n  }, {\n    key: \"drop\",\n    value: function drop(cascade) {\n      var _this7 = this;\n      if (!this.isDatabase() && !this.isTableOrView()) {\n        return CancellablePromise.reject('Drop is only possible for a database, table or view.');\n      }\n      var statement = \"DROP \".concat(this.isDatabase() ? 'DATABASE' : this.isView() ? 'VIEW' : 'TABLE', \" IF EXISTS `\").concat(this.path.join('`.`'), \"`\").concat(this.isDatabase() && cascade ? ' CASCADE;' : ';');\n      return new CancellablePromise(function (resolve, reject, onCancel) {\n        var executePromise = executeSingleStatement({\n          connector: _this7.getConnector(),\n          namespace: _this7.namespace,\n          compute: _this7.compute,\n          statement: statement\n        });\n        onCancel(function () {\n          executePromise.cancel();\n        });\n        executePromise.then(function () {\n          _this7.clearCache({\n            cascade: true\n          })[\"catch\"]();\n          resolve();\n        })[\"catch\"](reject);\n      });\n    }\n\n    /**\n     * Save the entry to cache\n     */\n  }, {\n    key: \"save\",\n    value: (function () {\n      var _save = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              window.clearTimeout(this.saveTimeout);\n              _context9.prev = 1;\n              _context9.next = 4;\n              return this.dataCatalog.persistCatalogEntry(this);\n            case 4:\n              _context9.next = 8;\n              break;\n            case 6:\n              _context9.prev = 6;\n              _context9.t0 = _context9[\"catch\"](1);\n            case 8:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this, [[1, 6]]);\n      }));\n      function save() {\n        return _save.apply(this, arguments);\n      }\n      return save;\n    }()\n    /**\n     * Save the entry at a later point of time\n     */\n    )\n  }, {\n    key: \"saveLater\",\n    value: function saveLater() {\n      var _CACHEABLE_TTL,\n        _this8 = this;\n      if ((((_CACHEABLE_TTL = window.CACHEABLE_TTL) === null || _CACHEABLE_TTL === void 0 ? void 0 : _CACHEABLE_TTL[\"default\"]) || 0) > 0) {\n        window.clearTimeout(this.saveTimeout);\n        this.saveTimeout = window.setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n          return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n            while (1) switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return _this8.save();\n              case 2:\n              case \"end\":\n                return _context10.stop();\n            }\n          }, _callee10);\n        })), 1000);\n      }\n    }\n\n    /**\n     * Gets the parent entry, rejected if there's no parent.\n     */\n  }, {\n    key: \"getParent\",\n    value: function getParent() {\n      if (!this.path.length) {\n        return Promise.reject();\n      }\n      return this.dataCatalog.getEntry({\n        namespace: this.namespace,\n        compute: this.compute,\n        path: this.path.slice(0, this.path.length - 1)\n      });\n    }\n\n    /**\n     * Get the children of the catalog entry, columns for a table entry etc.\n     */\n  }, {\n    key: \"getChildren\",\n    value: function getChildren(options) {\n      var _this9 = this;\n      if (this.childrenPromise && this.childrenPromise.cancelled) {\n        this.childrenPromise = undefined;\n      }\n      if (!this.childrenPromise && cachedOnly(options)) {\n        return CancellablePromise.reject();\n      }\n      if (this.childrenPromise && !shouldReload(options)) {\n        return applyCancellable(this.childrenPromise, options);\n      }\n      this.childrenPromise = new CancellablePromise( /*#__PURE__*/function () {\n        var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(resolve, reject, onCancel) {\n          var sourceMeta, cancelled, partitionKeys, tableSourceMeta, primaryKeys, foreignKeys, entities, promises, index, fieldSourceMeta, complexAttributes;\n          return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n            while (1) switch (_context11.prev = _context11.next) {\n              case 0:\n                cancelled = false;\n                onCancel(function () {\n                  cancelled = true;\n                });\n                _context11.prev = 2;\n                _context11.next = 5;\n                return _this9.getSourceMeta(options);\n              case 5:\n                sourceMeta = _context11.sent;\n                _context11.next = 10;\n                break;\n              case 8:\n                _context11.prev = 8;\n                _context11.t0 = _context11[\"catch\"](2);\n              case 10:\n                if (!cancelled) {\n                  _context11.next = 13;\n                  break;\n                }\n                reject('Cancelled');\n                return _context11.abrupt(\"return\");\n              case 13:\n                if (sourceMeta) {\n                  _context11.next = 16;\n                  break;\n                }\n                reject('No source meta found');\n                return _context11.abrupt(\"return\");\n              case 16:\n                if (!sourceMeta.notFound) {\n                  _context11.next = 19;\n                  break;\n                }\n                resolve([]);\n                return _context11.abrupt(\"return\");\n              case 19:\n                partitionKeys = {};\n                tableSourceMeta = sourceMeta;\n                if (tableSourceMeta.partition_keys) {\n                  tableSourceMeta.partition_keys.forEach(function (partitionKey) {\n                    partitionKeys[partitionKey.name] = true;\n                  });\n                }\n                primaryKeys = {};\n                if (tableSourceMeta.primary_keys) {\n                  tableSourceMeta.primary_keys.forEach(function (primaryKey) {\n                    primaryKeys[primaryKey.name] = true;\n                  });\n                }\n                foreignKeys = {};\n                if (tableSourceMeta.foreign_keys) {\n                  tableSourceMeta.foreign_keys.forEach(function (foreignKey) {\n                    foreignKeys[foreignKey.name] = foreignKey;\n                  });\n                }\n                entities = sourceMeta.databases || sourceMeta.tables_meta || sourceMeta.extended_columns || sourceMeta.fields || sourceMeta.columns || [];\n                promises = [];\n                index = 0;\n                entities.forEach(function (entity) {\n                  if (!sourceMeta.databases || entity !== '_impala_builtins') {\n                    var _name = entity.name || entity;\n                    var promise = _this9.dataCatalog.getEntry({\n                      namespace: _this9.namespace,\n                      compute: _this9.compute,\n                      path: [].concat(_toConsumableArray(_this9.path), [_name])\n                    });\n                    promise.then(function (catalogEntry) {\n                      if (!catalogEntry.definition || typeof catalogEntry.definition.index === 'undefined') {\n                        var definition = _typeof(entity) === 'object' ? entity : {\n                          name: entity\n                        };\n                        if (!definition.type) {\n                          if (_this9.path.length === 0) {\n                            definition.type = 'database';\n                          } else if (_this9.path.length === 1) {\n                            definition.type = 'table';\n                          } else if (_this9.path.length === 2) {\n                            definition.type = 'column';\n                          }\n                        }\n                        if (sourceMeta.partition_keys) {\n                          definition.partitionKey = partitionKeys[_name];\n                        }\n                        if (sourceMeta.primary_keys) {\n                          definition.primaryKey = primaryKeys[_name];\n                        }\n                        if (sourceMeta.foreign_keys) {\n                          definition.foreignKey = foreignKeys[_name];\n                        }\n                        definition.index = index++;\n                        catalogEntry.definition = definition;\n                        catalogEntry.saveLater();\n                      }\n                    })[\"catch\"](function (err) {\n                      console.warn(err);\n                    });\n                    promises.push(promise);\n                  }\n                });\n\n                // TODO: Move to connector attributes\n                if (sourceMeta && (_this9.getDialect() === 'impala' || _this9.getDialect() === 'hive') && _this9.isComplex()) {\n                  fieldSourceMeta = sourceMeta;\n                  complexAttributes = fieldSourceMeta.type === 'map' ? ['key', 'value'] : ['item'];\n                  complexAttributes.forEach(function (path) {\n                    var definition = fieldSourceMeta[path];\n                    if (definition) {\n                      var promise = _this9.dataCatalog.getEntry({\n                        namespace: _this9.namespace,\n                        compute: _this9.compute,\n                        path: [].concat(_toConsumableArray(_this9.path), [path])\n                      });\n                      promise.then(function (catalogEntry) {\n                        if (!catalogEntry.definition || typeof catalogEntry.definition.index === 'undefined') {\n                          definition.index = index++;\n                          definition.isMapValue = path === 'value';\n                          catalogEntry.definition = definition;\n                          catalogEntry.saveLater();\n                        }\n                      })[\"catch\"](function (err) {\n                        console.warn(err);\n                      });\n                      promises.push(promise);\n                    }\n                  });\n                }\n                Promise.all(promises).then(resolve)[\"catch\"](reject);\n              case 32:\n              case \"end\":\n                return _context11.stop();\n            }\n          }, _callee11, null, [[2, 8]]);\n        }));\n        return function (_x17, _x18, _x19) {\n          return _ref10.apply(this, arguments);\n        };\n      }());\n      return applyCancellable(this.childrenPromise, options);\n    }\n\n    /**\n     * Loads navigator metadata for children, only applicable to databases and tables\n     */\n  }, {\n    key: \"loadNavigatorMetaForChildren\",\n    value: function loadNavigatorMetaForChildren(options) {\n      var _this10 = this;\n      if (this.navigatorMetaForChildrenPromise && this.navigatorMetaForChildrenPromise.cancelled) {\n        this.navigatorMetaPromise = undefined;\n      }\n      options = forceSilencedErrors(options);\n      if (!this.canHaveNavigatorMetadata() || this.isField()) {\n        return CancellablePromise.resolve([]);\n      }\n      if (this.navigatorMetaForChildrenPromise && !shouldReload(options)) {\n        return applyCancellable(this.navigatorMetaForChildrenPromise, options);\n      }\n      this.navigatorMetaForChildrenPromise = new CancellablePromise( /*#__PURE__*/function () {\n        var _ref11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(resolve, reject, onCancel) {\n          var cancellablePromises, _options, childPromise, children, someHaveNavMeta, query, rejectUnknown, searchPromise;\n          return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n            while (1) switch (_context12.prev = _context12.next) {\n              case 0:\n                cancellablePromises = [];\n                onCancel(function () {\n                  cancellablePromises.forEach(function (cancellable) {\n                    cancellable.cancel();\n                  });\n                });\n                _context12.prev = 2;\n                childPromise = _this10.getChildren(options);\n                cancellablePromises.push(childPromise);\n                _context12.next = 7;\n                return childPromise;\n              case 7:\n                children = _context12.sent;\n                someHaveNavMeta = children.some(function (childEntry) {\n                  return childEntry.navigatorMeta;\n                });\n                if (!(someHaveNavMeta && !shouldReload(options))) {\n                  _context12.next = 12;\n                  break;\n                }\n                resolve(children);\n                return _context12.abrupt(\"return\");\n              case 12:\n                // TODO: Add sourceType to nav search query\n                query = _this10.path.length ? \"parentPath:\\\"/\".concat(_this10.path.join('/'), \"\\\" AND type:(table view field)\") : 'type:database';\n                rejectUnknown = function rejectUnknown() {\n                  children.forEach(function (childEntry) {\n                    if (!childEntry.navigatorMeta) {\n                      childEntry.navigatorMeta = undefined;\n                      childEntry.navigatorMetaPromise = undefined;\n                    }\n                  });\n                };\n                searchPromise = searchEntities({\n                  query: query,\n                  rawQuery: true,\n                  limit: children.length,\n                  silenceErrors: (_options = options) === null || _options === void 0 ? void 0 : _options.silenceErrors\n                });\n                cancellablePromises.push(searchPromise);\n                searchPromise.then(function (result) {\n                  if (result && result.entities) {\n                    var childEntryIndex = {};\n                    children.forEach(function (childEntry) {\n                      childEntryIndex[childEntry.name.toLowerCase()] = childEntry;\n                    });\n                    result.entities.forEach(function (entity) {\n                      var matchingChildEntry = childEntryIndex[(entity.original_name || entity.originalName).toLowerCase()];\n                      if (matchingChildEntry) {\n                        matchingChildEntry.navigatorMeta = entity;\n                        entity.hueTimestamp = Date.now();\n                        matchingChildEntry.navigatorMetaPromise = CancellablePromise.resolve(matchingChildEntry.navigatorMeta);\n                        if (entity && matchingChildEntry.commentObservable) {\n                          matchingChildEntry.commentObservable(matchingChildEntry.getResolvedComment());\n                        }\n                        matchingChildEntry.saveLater();\n                      }\n                    });\n                  }\n                })[\"catch\"](function () {\n                  return resolve([]);\n                })[\"finally\"](function () {\n                  rejectUnknown();\n                  resolve(children);\n                });\n                _context12.next = 23;\n                break;\n              case 19:\n                _context12.prev = 19;\n                _context12.t0 = _context12[\"catch\"](2);\n                resolve([]);\n                return _context12.abrupt(\"return\");\n              case 23:\n              case \"end\":\n                return _context12.stop();\n            }\n          }, _callee12, null, [[2, 19]]);\n        }));\n        return function (_x20, _x21, _x22) {\n          return _ref11.apply(this, arguments);\n        };\n      }());\n      return applyCancellable(this.navigatorMetaForChildrenPromise, options);\n    }\n\n    /**\n     * Helper function used when loading navopt metdata for children\n     */\n  }, {\n    key: \"applySqlAnalyzerResponseToChildren\",\n    value: function applySqlAnalyzerResponseToChildren(response, options) {\n      var _this11 = this;\n      if (!this.definition) {\n        this.definition = {};\n      }\n      this.definition.sqlAnalyzerLoaded = true;\n      this.saveLater();\n      return new CancellablePromise( /*#__PURE__*/function () {\n        var _ref12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(resolve, reject, onCancel) {\n          var childPromise, childEntries, entriesByName, updatedIndex, addSqlAnalyzerPopularity, popularEntries;\n          return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n            while (1) switch (_context13.prev = _context13.next) {\n              case 0:\n                childPromise = _this11.getChildren(options);\n                onCancel(function () {\n                  childPromise.cancel();\n                });\n                _context13.prev = 2;\n                _context13.next = 5;\n                return childPromise;\n              case 5:\n                childEntries = _context13.sent;\n                entriesByName = {};\n                childEntries.forEach(function (childEntry) {\n                  entriesByName[childEntry.name.toLowerCase()] = childEntry;\n                });\n                updatedIndex = {};\n                if (_this11.isDatabase() && response.top_tables) {\n                  response.top_tables.forEach(function (topTable) {\n                    if (!topTable.name) {\n                      return;\n                    }\n                    var matchingChild = entriesByName[topTable.name.toLowerCase()];\n                    if (matchingChild) {\n                      matchingChild.sqlAnalyzerPopularity = topTable;\n                      matchingChild.saveLater();\n                      updatedIndex[matchingChild.getQualifiedPath()] = matchingChild;\n                    }\n                  });\n                } else if (_this11.isTableOrView() && response.values) {\n                  addSqlAnalyzerPopularity = function addSqlAnalyzerPopularity(columns, type) {\n                    if (columns) {\n                      columns.forEach(function (column) {\n                        if (!column.columnName) {\n                          return;\n                        }\n                        var matchingChild = entriesByName[column.columnName.toLowerCase()];\n                        if (matchingChild) {\n                          if (!matchingChild.sqlAnalyzerPopularity) {\n                            matchingChild.sqlAnalyzerPopularity = {\n                              column_count: 0,\n                              columnCount: 0\n                            };\n                          }\n                          matchingChild.sqlAnalyzerPopularity[type] = column;\n                          matchingChild.saveLater();\n                          updatedIndex[matchingChild.getQualifiedPath()] = matchingChild;\n                        }\n                      });\n                    }\n                  };\n                  addSqlAnalyzerPopularity(response.values.filterColumns, 'filterColumn');\n                  addSqlAnalyzerPopularity(response.values.groupbyColumns, 'groupByColumn');\n                  addSqlAnalyzerPopularity(response.values.joinColumns, 'joinColumn');\n                  addSqlAnalyzerPopularity(response.values.orderbyColumns, 'orderByColumn');\n                  addSqlAnalyzerPopularity(response.values.selectColumns, 'selectColumn');\n                }\n                popularEntries = [];\n                Object.keys(updatedIndex).forEach(function (path) {\n                  popularEntries.push(updatedIndex[path]);\n                });\n                resolve(popularEntries);\n                _context13.next = 18;\n                break;\n              case 15:\n                _context13.prev = 15;\n                _context13.t0 = _context13[\"catch\"](2);\n                reject(_context13.t0);\n              case 18:\n              case \"end\":\n                return _context13.stop();\n            }\n          }, _callee13, null, [[2, 15]]);\n        }));\n        return function (_x23, _x24, _x25) {\n          return _ref12.apply(this, arguments);\n        };\n      }());\n    }\n\n    /**\n     * Loads SQL Analyzer popularity for the children of this entry.\n     */\n  }, {\n    key: \"loadSqlAnalyzerPopularityForChildren\",\n    value: function loadSqlAnalyzerPopularityForChildren(options) {\n      var _this12 = this;\n      if (this.sqlAnalyzerPopularityForChildrenPromise && this.sqlAnalyzerPopularityForChildrenPromise.cancelled) {\n        this.sqlAnalyzerPopularityForChildrenPromise = undefined;\n      }\n      options.silenceErrors = true;\n      if (!this.dataCatalog.canHaveSqlAnalyzerMeta()) {\n        return CancellablePromise.reject();\n      }\n      if (this.sqlAnalyzerPopularityForChildrenPromise && !shouldReload(options)) {\n        return applyCancellable(this.sqlAnalyzerPopularityForChildrenPromise, options);\n      }\n      if (this.definition && this.definition.sqlAnalyzerLoaded && !shouldReload(options)) {\n        this.sqlAnalyzerPopularityForChildrenPromise = new CancellablePromise( /*#__PURE__*/function () {\n          var _ref13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(resolve, reject, onCancel) {\n            var childPromise, _children;\n            return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n              while (1) switch (_context14.prev = _context14.next) {\n                case 0:\n                  childPromise = _this12.getChildren(options);\n                  onCancel(function () {\n                    childPromise.cancel();\n                  });\n                  _context14.prev = 2;\n                  _context14.next = 5;\n                  return childPromise;\n                case 5:\n                  _children = _context14.sent;\n                  resolve(_children.filter(function (child) {\n                    return child.sqlAnalyzerPopularity;\n                  }));\n                  _context14.next = 12;\n                  break;\n                case 9:\n                  _context14.prev = 9;\n                  _context14.t0 = _context14[\"catch\"](2);\n                  reject(_context14.t0);\n                case 12:\n                case \"end\":\n                  return _context14.stop();\n              }\n            }, _callee14, null, [[2, 9]]);\n          }));\n          return function (_x26, _x27, _x28) {\n            return _ref13.apply(this, arguments);\n          };\n        }());\n      } else if (this.isDatabase() || this.isTableOrView()) {\n        this.sqlAnalyzerPopularityForChildrenPromise = new CancellablePromise( /*#__PURE__*/function () {\n          var _ref14 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(resolve, reject, onCancel) {\n            var cancellablePromises, popularityPromise, analyzerResponse, applyPromise, entries;\n            return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n              while (1) switch (_context15.prev = _context15.next) {\n                case 0:\n                  cancellablePromises = [];\n                  onCancel(function () {\n                    cancellablePromises.forEach(function (cancellable) {\n                      return cancellable.cancel();\n                    });\n                  });\n                  popularityPromise = options.sqlAnalyzer.fetchPopularity(_objectSpread(_objectSpread({}, options), {}, {\n                    paths: [_this12.path]\n                  }));\n                  cancellablePromises.push(popularityPromise);\n                  _context15.prev = 4;\n                  _context15.next = 7;\n                  return popularityPromise;\n                case 7:\n                  analyzerResponse = _context15.sent;\n                  applyPromise = _this12.applySqlAnalyzerResponseToChildren(analyzerResponse, options);\n                  cancellablePromises.push(applyPromise);\n                  _context15.next = 12;\n                  return applyPromise;\n                case 12:\n                  entries = _context15.sent;\n                  resolve(entries);\n                  _context15.next = 19;\n                  break;\n                case 16:\n                  _context15.prev = 16;\n                  _context15.t0 = _context15[\"catch\"](4);\n                  resolve([]);\n                case 19:\n                case \"end\":\n                  return _context15.stop();\n              }\n            }, _callee15, null, [[4, 16]]);\n          }));\n          return function (_x29, _x30, _x31) {\n            return _ref14.apply(this, arguments);\n          };\n        }());\n      } else {\n        this.sqlAnalyzerPopularityForChildrenPromise = CancellablePromise.resolve([]);\n      }\n      return applyCancellable(this.sqlAnalyzerPopularityForChildrenPromise);\n    }\n\n    /**\n     * Returns true if the catalog entry can have navigator metadata\n     */\n  }, {\n    key: \"canHaveNavigatorMetadata\",\n    value: function canHaveNavigatorMetadata() {\n      if (!window.HAS_CATALOG) {\n        return false;\n      }\n      // TODO: Move to connector attributes\n      return (this.getDialect() === 'hive' || this.getDialect() === 'impala') && (this.isDatabase() || this.isTableOrView() || this.isColumn());\n    }\n\n    /**\n     * Returns the currently known comment without loading any additional metadata\n     */\n  }, {\n    key: \"getResolvedComment\",\n    value: function getResolvedComment() {\n      // TODO: Move to connector attributes\n      if (this.navigatorMeta && (this.getDialect() === 'hive' || this.getDialect() === 'impala')) {\n        if (this.navigatorMeta.description) {\n          return this.navigatorMeta.description;\n        }\n        if (this.navigatorMeta.originalDescription) {\n          return this.navigatorMeta.originalDescription;\n        }\n      }\n      if (this.definition && this.definition.comment) {\n        return this.definition.comment;\n      }\n      return this.sourceMeta && this.sourceMeta.comment || '';\n    }\n\n    /**\n     * This can be used to get an observable for the comment which will be updated once a comment has been\n     * resolved.\n     */\n  }, {\n    key: \"getCommentObservable\",\n    value: function getCommentObservable() {\n      if (!this.commentObservable) {\n        this.commentObservable = ko.observable(this.getResolvedComment());\n      }\n      return this.commentObservable;\n    }\n\n    /**\n     * Checks whether the comment is known and has been loaded from the proper source\n     */\n  }, {\n    key: \"hasResolvedComment\",\n    value: function hasResolvedComment() {\n      if (this.canHaveNavigatorMetadata()) {\n        return typeof this.navigatorMeta !== 'undefined';\n      }\n      return typeof this.sourceMeta !== 'undefined';\n    }\n\n    /**\n     * Gets the comment for this entry, fetching it if necessary from the proper source.\n     */\n  }, {\n    key: \"getComment\",\n    value: function getComment(options) {\n      var _this13 = this;\n      var promise = new CancellablePromise( /*#__PURE__*/function () {\n        var _ref15 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(resolve, reject, onCancel) {\n          var cancellablePromises, navigatorMetaPromise, navigatorMeta, sourceMetaPromise, sourceMeta;\n          return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n            while (1) switch (_context16.prev = _context16.next) {\n              case 0:\n                cancellablePromises = [];\n                onCancel(function () {\n                  cancellablePromises.forEach(function (cancellable) {\n                    return cancellable.cancel();\n                  });\n                });\n                if (!_this13.canHaveNavigatorMetadata()) {\n                  _context16.next = 16;\n                  break;\n                }\n                navigatorMetaPromise = _this13.getNavigatorMeta(options);\n                cancellablePromises.push(navigatorMetaPromise);\n                _context16.prev = 5;\n                _context16.next = 8;\n                return navigatorMetaPromise;\n              case 8:\n                navigatorMeta = _context16.sent;\n                if (!navigatorMeta) {\n                  _context16.next = 12;\n                  break;\n                }\n                resolve(navigatorMeta.description || navigatorMeta.originalDescription || '');\n                return _context16.abrupt(\"return\");\n              case 12:\n                _context16.next = 16;\n                break;\n              case 14:\n                _context16.prev = 14;\n                _context16.t0 = _context16[\"catch\"](5);\n              case 16:\n                if (!_this13.sourceMeta) {\n                  _context16.next = 20;\n                  break;\n                }\n                resolve(_this13.sourceMeta.comment || '');\n                _context16.next = 35;\n                break;\n              case 20:\n                if (!(_this13.definition && _this13.definition.comment)) {\n                  _context16.next = 24;\n                  break;\n                }\n                resolve(_this13.definition.comment);\n                _context16.next = 35;\n                break;\n              case 24:\n                sourceMetaPromise = _this13.getSourceMeta(options);\n                _context16.prev = 25;\n                _context16.next = 28;\n                return sourceMetaPromise;\n              case 28:\n                sourceMeta = _context16.sent;\n                resolve(sourceMeta && sourceMeta.comment || '');\n                _context16.next = 35;\n                break;\n              case 32:\n                _context16.prev = 32;\n                _context16.t1 = _context16[\"catch\"](25);\n                reject(_context16.t1);\n              case 35:\n              case \"end\":\n                return _context16.stop();\n            }\n          }, _callee16, null, [[5, 14], [25, 32]]);\n        }));\n        return function (_x32, _x33, _x34) {\n          return _ref15.apply(this, arguments);\n        };\n      }());\n      return applyCancellable(promise);\n    }\n\n    /**\n     * Updates custom navigator metadata for the catalog entry\n     */\n  }, {\n    key: \"updateNavigatorCustomMetadata\",\n    value: (function () {\n      var _updateNavigatorCustomMetadata = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(modifiedCustomMetadata, deletedCustomMetadataKeys, apiOptions) {\n        var _this14 = this;\n        var navigatorMeta;\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              if (this.canHaveNavigatorMetadata()) {\n                _context17.next = 2;\n                break;\n              }\n              return _context17.abrupt(\"return\", Promise.reject());\n            case 2:\n              _context17.next = 4;\n              return this.getNavigatorMeta(apiOptions);\n            case 4:\n              navigatorMeta = _context17.sent;\n              if (navigatorMeta) {\n                _context17.next = 7;\n                break;\n              }\n              throw new Error('Could not load navigator metadata.');\n            case 7:\n              return _context17.abrupt(\"return\", new Promise(function (resolve, reject) {\n                updateNavigatorProperties({\n                  identity: navigatorMeta.identity,\n                  modifiedCustomMetadata: modifiedCustomMetadata,\n                  deletedCustomMetadataKeys: deletedCustomMetadataKeys\n                }).then(function (entity) {\n                  if (entity) {\n                    _this14.navigatorMeta = entity;\n                    _this14.navigatorMetaPromise = CancellablePromise.resolve(entity);\n                    _this14.saveLater();\n                    resolve(entity);\n                  } else {\n                    reject();\n                  }\n                })[\"catch\"](reject);\n              }));\n            case 8:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _callee17, this);\n      }));\n      function updateNavigatorCustomMetadata(_x35, _x36, _x37) {\n        return _updateNavigatorCustomMetadata.apply(this, arguments);\n      }\n      return updateNavigatorCustomMetadata;\n    }()\n    /**\n     * Sets the comment in the proper source\n     */\n    )\n  }, {\n    key: \"setComment\",\n    value: (function () {\n      var _setComment = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(comment, options) {\n        var _this15 = this;\n        var navigatorMeta;\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) switch (_context20.prev = _context20.next) {\n            case 0:\n              if (!this.canHaveNavigatorMetadata()) {\n                _context20.next = 7;\n                break;\n              }\n              _context20.next = 3;\n              return this.getNavigatorMeta(options);\n            case 3:\n              navigatorMeta = _context20.sent;\n              if (navigatorMeta) {\n                _context20.next = 6;\n                break;\n              }\n              throw new Error('Could not load navigator metadata.');\n            case 6:\n              return _context20.abrupt(\"return\", new Promise(function (resolve, reject) {\n                updateNavigatorProperties({\n                  identity: navigatorMeta.identity,\n                  properties: {\n                    description: comment\n                  }\n                }).then( /*#__PURE__*/function () {\n                  var _ref16 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(entity) {\n                    return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n                      while (1) switch (_context18.prev = _context18.next) {\n                        case 0:\n                          if (entity) {\n                            _this15.navigatorMeta = entity;\n                            _this15.navigatorMetaPromise = CancellablePromise.resolve(entity);\n                            _this15.saveLater();\n                          }\n                          _this15.getComment(options).then(function (comment) {\n                            if (_this15.commentObservable) {\n                              _this15.commentObservable(comment);\n                            }\n                            resolve(comment);\n                          })[\"catch\"](reject);\n                        case 2:\n                        case \"end\":\n                          return _context18.stop();\n                      }\n                    }, _callee18);\n                  }));\n                  return function (_x40) {\n                    return _ref16.apply(this, arguments);\n                  };\n                }())[\"catch\"](reject);\n              }));\n            case 7:\n              return _context20.abrupt(\"return\", new Promise(function (resolve, reject) {\n                updateSourceMetadata({\n                  entry: _this15,\n                  properties: {\n                    comment: comment\n                  },\n                  silenceErrors: options === null || options === void 0 ? void 0 : options.silenceErrors\n                }).then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {\n                  var _comment;\n                  return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n                    while (1) switch (_context19.prev = _context19.next) {\n                      case 0:\n                        _context19.prev = 0;\n                        _context19.next = 3;\n                        return _this15.reloadSourceMeta(options);\n                      case 3:\n                        _context19.next = 5;\n                        return _this15.getComment(options);\n                      case 5:\n                        _comment = _context19.sent;\n                        if (_this15.commentObservable) {\n                          _this15.commentObservable(_comment);\n                        }\n                        resolve(_comment);\n                        _context19.next = 13;\n                        break;\n                      case 10:\n                        _context19.prev = 10;\n                        _context19.t0 = _context19[\"catch\"](0);\n                        reject(_context19.t0);\n                      case 13:\n                      case \"end\":\n                        return _context19.stop();\n                    }\n                  }, _callee19, null, [[0, 10]]);\n                })))[\"catch\"](reject);\n              }));\n            case 8:\n            case \"end\":\n              return _context20.stop();\n          }\n        }, _callee20, this);\n      }));\n      function setComment(_x38, _x39) {\n        return _setComment.apply(this, arguments);\n      }\n      return setComment;\n    }()\n    /**\n     * Adds a list of tags and updates the navigator metadata of the entry\n     */\n    )\n  }, {\n    key: \"addNavigatorTags\",\n    value: (function () {\n      var _addNavigatorTags = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(tags, apiOptions) {\n        var _this16 = this;\n        var navigatorMeta;\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) switch (_context21.prev = _context21.next) {\n            case 0:\n              if (this.canHaveNavigatorMetadata()) {\n                _context21.next = 2;\n                break;\n              }\n              return _context21.abrupt(\"return\", Promise.reject());\n            case 2:\n              _context21.next = 4;\n              return this.getNavigatorMeta(apiOptions);\n            case 4:\n              navigatorMeta = _context21.sent;\n              return _context21.abrupt(\"return\", new Promise(function (resolve, reject) {\n                addNavTags(navigatorMeta.identity, tags).then(function (entity) {\n                  if (entity) {\n                    _this16.navigatorMeta = entity;\n                    _this16.navigatorMetaPromise = CancellablePromise.resolve(entity);\n                    _this16.saveLater();\n                    resolve(entity);\n                  } else {\n                    reject();\n                  }\n                })[\"catch\"](reject);\n              }));\n            case 6:\n            case \"end\":\n              return _context21.stop();\n          }\n        }, _callee21, this);\n      }));\n      function addNavigatorTags(_x41, _x42) {\n        return _addNavigatorTags.apply(this, arguments);\n      }\n      return addNavigatorTags;\n    }()\n    /**\n     * Removes a list of tags and updates the navigator metadata of the entry\n     */\n    )\n  }, {\n    key: \"deleteNavigatorTags\",\n    value: (function () {\n      var _deleteNavigatorTags = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(tags, apiOptions) {\n        var _this17 = this;\n        var navigatorMeta;\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) switch (_context22.prev = _context22.next) {\n            case 0:\n              if (this.canHaveNavigatorMetadata()) {\n                _context22.next = 2;\n                break;\n              }\n              return _context22.abrupt(\"return\", Promise.reject());\n            case 2:\n              _context22.next = 4;\n              return this.getNavigatorMeta(apiOptions);\n            case 4:\n              navigatorMeta = _context22.sent;\n              return _context22.abrupt(\"return\", new Promise(function (resolve, reject) {\n                deleteNavTags(navigatorMeta.identity, tags).then(function (entity) {\n                  if (entity) {\n                    _this17.navigatorMeta = entity;\n                    _this17.navigatorMetaPromise = CancellablePromise.resolve(entity);\n                    _this17.saveLater();\n                    resolve(entity);\n                  } else {\n                    reject();\n                  }\n                })[\"catch\"](reject);\n              }));\n            case 6:\n            case \"end\":\n              return _context22.stop();\n          }\n        }, _callee22, this);\n      }));\n      function deleteNavigatorTags(_x43, _x44) {\n        return _deleteNavigatorTags.apply(this, arguments);\n      }\n      return deleteNavigatorTags;\n    }()\n    /**\n     * Checks if the entry can have children or not without fetching additional metadata.\n     */\n    )\n  }, {\n    key: \"hasPossibleChildren\",\n    value: function hasPossibleChildren() {\n      return this.path.length < 3 || !this.definition && !this.sourceMeta || !!this.sourceMeta && /^(?:struct|array|map)/i.test(this.sourceMeta.type) || !!this.definition && !!this.definition.type && /^(?:struct|array|map)/i.test(this.definition.type);\n    }\n\n    /**\n     * Returns the index representing the order in which the backend returned this entry.\n     */\n  }, {\n    key: \"getIndex\",\n    value: function getIndex() {\n      return this.definition && this.definition.index || 0;\n    }\n\n    /**\n     * Returns the dialect of this entry.\n     */\n  }, {\n    key: \"getDialect\",\n    value: function getDialect() {\n      return this.getConnector().dialect || this.getConnector().id; // .id for editor v1\n    }\n\n    /**\n     * Returns the connector for this entry\n     */\n  }, {\n    key: \"getConnector\",\n    value: function getConnector() {\n      return this.dataCatalog.connector;\n    }\n\n    /**\n     * Returns true if the entry represents a data source.\n     *\n     * @return {boolean}\n     */\n  }, {\n    key: \"isSource\",\n    value: function isSource() {\n      return this.path.length === 0;\n    }\n\n    /**\n     * Returns true if the entry is a database.\n     */\n  }, {\n    key: \"isDatabase\",\n    value: function isDatabase() {\n      return this.path.length === 1;\n    }\n\n    /**\n     * Returns true if the entry is a table or a view.\n     *\n     * @return {boolean}\n     */\n  }, {\n    key: \"isTableOrView\",\n    value: function isTableOrView() {\n      return this.path.length === 2;\n    }\n\n    /**\n     * Returns the default title used for the entry, the qualified path with type for fields. Optionally include\n     * the comment after, if already resolved.\n     */\n  }, {\n    key: \"getTitle\",\n    value: function getTitle(includeComment) {\n      var title = this.getQualifiedPath();\n      if (this.isField()) {\n        var type = this.getType();\n        if (type) {\n          title += ' (' + type + ')';\n        }\n      } else if (this.definition && this.definition.type && this.definition.type.toLowerCase() === 'materialized_view') {\n        title += ' (' + I18n('Materialized') + ')';\n      }\n      if (includeComment && this.hasResolvedComment() && this.getResolvedComment()) {\n        title += ' - ' + this.getResolvedComment();\n      }\n      return title;\n    }\n\n    /**\n     * Returns the fully qualified path for this entry.\n     */\n  }, {\n    key: \"getQualifiedPath\",\n    value: function getQualifiedPath() {\n      return this.path.join('.');\n    }\n\n    /**\n     * Returns the display name for the entry, name or qualified path plus type for fields\n     */\n  }, {\n    key: \"getDisplayName\",\n    value: function getDisplayName(qualified) {\n      var displayName = qualified ? this.getQualifiedPath() : this.name;\n      if (this.isField()) {\n        var type = this.getType();\n        if (type) {\n          return \"\".concat(displayName, \" (\").concat(type, \")\");\n        }\n      }\n      return displayName;\n    }\n\n    /**\n     * Returns true for columns that are a primary key. Note that the definition has to come from a parent entry, i.e.\n     * getChildren().\n     */\n  }, {\n    key: \"isPrimaryKey\",\n    value: function isPrimaryKey() {\n      return !!(this.isColumn() && this.definition && this.definition.primaryKey);\n    }\n\n    /**\n     * Returns true if the entry is a partition key. Note that the definition has to come from a parent entry, i.e.\n     * getChildren().\n     */\n  }, {\n    key: \"isPartitionKey\",\n    value: function isPartitionKey() {\n      return !!(this.definition && this.definition.partitionKey);\n    }\n\n    /**\n     * Returns true if the entry is a foreign key. Note that the definition has to come from a parent entry, i.e.\n     * getChildren().\n     */\n  }, {\n    key: \"isForeignKey\",\n    value: function isForeignKey() {\n      return !!this.definition && !!this.definition.foreignKey;\n    }\n\n    /**\n     * Returns true if the entry is either a partition or primary key. Note that the definition has to come from a parent entry, i.e.\n     * getChildren().\n     */\n  }, {\n    key: \"isKey\",\n    value: function isKey() {\n      return this.isPartitionKey() || this.isPrimaryKey() || this.isForeignKey();\n    }\n\n    /**\n     * Returns true if the entry is a table. It will be accurate once the source meta has been loaded.\n     */\n  }, {\n    key: \"isTable\",\n    value: function isTable() {\n      if (this.path.length === 2) {\n        if (this.analysis && this.analysis.details && this.analysis.details.properties && this.analysis.details.properties.table_type === 'VIRTUAL_VIEW') {\n          return false;\n        }\n        if (this.sourceMeta) {\n          return !this.sourceMeta.is_view;\n        }\n        if (this.definition && this.definition.type) {\n          return this.definition.type.toLowerCase() === 'table';\n        }\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"getHdfsFilePath\",\n    value: function getHdfsFilePath() {\n      var _this$analysis;\n      var hdfs_link = ((_this$analysis = this.analysis) === null || _this$analysis === void 0 ? void 0 : _this$analysis.hdfs_link) || '';\n      return hdfs_link.replace('/filebrowser/view=', '');\n    }\n\n    /**\n     * Returns true if the entry is an Iceberg table\n     */\n  }, {\n    key: \"isIcebergTable\",\n    value: function isIcebergTable() {\n      var _this$analysis2, _this$analysis2$detai, _this$analysis2$detai2;\n      return ((_this$analysis2 = this.analysis) === null || _this$analysis2 === void 0 ? void 0 : (_this$analysis2$detai = _this$analysis2.details) === null || _this$analysis2$detai === void 0 ? void 0 : (_this$analysis2$detai2 = _this$analysis2$detai.stats) === null || _this$analysis2$detai2 === void 0 ? void 0 : _this$analysis2$detai2.table_type) === 'ICEBERG';\n    }\n  }, {\n    key: \"isTransactionalTable\",\n    value: function isTransactionalTable() {\n      var _this$analysis3, _this$analysis3$detai, _this$analysis3$detai2;\n      return ((_this$analysis3 = this.analysis) === null || _this$analysis3 === void 0 ? void 0 : (_this$analysis3$detai = _this$analysis3.details) === null || _this$analysis3$detai === void 0 ? void 0 : (_this$analysis3$detai2 = _this$analysis3$detai.stats) === null || _this$analysis3$detai2 === void 0 ? void 0 : _this$analysis3$detai2.transactional) === 'true';\n    }\n\n    /**\n     * Returns true if the entry is a view. It will be accurate once the source meta has been loaded.\n     */\n  }, {\n    key: \"isView\",\n    value: function isView() {\n      if (this.path.length === 2) {\n        if (this.sourceMeta && this.sourceMeta.is_view) {\n          return true;\n        }\n        if (this.definition && this.definition.type && (this.definition.type.toLowerCase() === 'view' || this.definition.type.toLowerCase() === 'materialized_view')) {\n          return true;\n        }\n        if (this.analysis && this.analysis.details && this.analysis.details.properties && this.analysis.details.properties.table_type === 'VIRTUAL_VIEW') {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Returns true if the entry is a ML Model. It will be accurate once the source meta has been loaded.\n     */\n  }, {\n    key: \"isModel\",\n    value: function isModel() {\n      return this.path.length === 2 && !!this.definition && !!this.definition.type && this.definition.type.toLowerCase() === 'model';\n    }\n\n    /**\n     * Returns true if the entry is a column.\n     */\n  }, {\n    key: \"isColumn\",\n    value: function isColumn() {\n      return this.path.length === 3;\n    }\n\n    /**\n     * Returns true if the entry is a column. It will be accurate once the source meta has been loaded or if loaded from\n     * a parent entry via getChildren().\n     */\n  }, {\n    key: \"isComplex\",\n    value: function isComplex() {\n      var sourceMeta = this.sourceMeta;\n      return !!(this.path.length > 2 && (sourceMeta && /^(?:struct|array|map)/i.test(sourceMeta.type) || this.definition && this.definition.type && /^(?:struct|array|map)/i.test(this.definition.type)));\n    }\n\n    /**\n     * Returns true if the entry is a field, i.e. column or child of a complex type.\n     */\n  }, {\n    key: \"isField\",\n    value: function isField() {\n      return this.path.length > 2;\n    }\n\n    /**\n     * Returns true if the entry is an array. It will be accurate once the source meta has been loaded or if loaded from\n     * a parent entry via getChildren().\n     */\n  }, {\n    key: \"isArray\",\n    value: function isArray() {\n      return !!this.sourceMeta && /^array/i.test(this.sourceMeta.type) || !!this.definition && !!this.definition.type && /^array/i.test(this.definition.type);\n    }\n\n    /**\n     * Returns true if the entry is a map. It will be accurate once the source meta has been loaded or if loaded from\n     * a parent entry via getChildren().\n     */\n  }, {\n    key: \"isMap\",\n    value: function isMap() {\n      return !!this.sourceMeta && /^map/i.test(this.sourceMeta.type) || !!this.definition && !!this.definition.type && /^map/i.test(this.definition.type);\n    }\n\n    /**\n     * Returns true if the entry is a map value. It will be accurate once the source meta has been loaded or if loaded\n     * from a parent entry via getChildren().\n     */\n  }, {\n    key: \"isMapValue\",\n    value: function isMapValue() {\n      return !!this.definition && !!this.definition.isMapValue;\n    }\n\n    /**\n     * Returns the type of the entry. It will be accurate once the source meta has been loaded or if loaded from\n     * a parent entry via getChildren().\n     *\n     * The returned string is always lower case and for complex entries the type definition is stripped to\n     * either 'array', 'map' or 'struct'.\n     */\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      var type = this.getRawType();\n      if (type.indexOf('<') !== -1) {\n        type = type.substring(0, type.indexOf('<'));\n      }\n      return type.toLowerCase();\n    }\n\n    /**\n     * Returns the raw type of the entry. It will be accurate once the source meta has been loaded or if loaded from\n     * a parent entry via getChildren().\n     *\n     * For complex entries the type definition is the full version.\n     */\n  }, {\n    key: \"getRawType\",\n    value: function getRawType() {\n      return this.sourceMeta && this.sourceMeta.type || this.definition && this.definition.type || '';\n    }\n\n    /**\n     * Gets the source metadata for the entry. It will fetch it if not cached or if the refresh option is set.\n     */\n  }, {\n    key: \"getSourceMeta\",\n    value: function getSourceMeta(options) {\n      if (this.sourceMetaPromise && this.sourceMetaPromise.cancelled) {\n        this.sourceMetaPromise = undefined;\n      }\n      if (!this.sourceMetaPromise && cachedOnly(options)) {\n        return CancellablePromise.reject();\n      }\n      if (!this.sourceMetaPromise || shouldReload(options)) {\n        return this.reloadSourceMeta(options);\n      }\n      return applyCancellable(this.sourceMetaPromise, options);\n    }\n\n    /**\n     * Gets the analysis for the entry. It will fetch it if not cached or if the refresh option is set.\n     */\n  }, {\n    key: \"getAnalysis\",\n    value: function getAnalysis(options) {\n      if (this.analysisPromise && this.analysisPromise.cancelled) {\n        this.analysisPromise = undefined;\n      }\n      if (!this.analysisPromise && cachedOnly(options)) {\n        return CancellablePromise.reject();\n      }\n      if (!this.analysisPromise || shouldReload(options)) {\n        return this.reloadAnalysis(options);\n      }\n      return applyCancellable(this.analysisPromise, options);\n    }\n\n    /**\n     * Gets the partitions for the entry. It will fetch it if not cached or if the refresh option is set.\n     */\n  }, {\n    key: \"getPartitions\",\n    value: function getPartitions(options) {\n      if (this.partitionsPromise && this.partitionsPromise.cancelled) {\n        this.partitionsPromise = undefined;\n      }\n      if (!this.isTableOrView() || !this.partitionsPromise && cachedOnly(options)) {\n        return CancellablePromise.reject();\n      }\n      if (!this.partitionsPromise || shouldReload(options)) {\n        return this.reloadPartitions(options);\n      }\n      return applyCancellable(this.partitionsPromise, options);\n    }\n\n    /**\n     * Gets the Navigator metadata for the entry. It will fetch it if not cached or if the refresh option is set.\n     */\n  }, {\n    key: \"getNavigatorMeta\",\n    value: function getNavigatorMeta(options) {\n      if (this.navigatorMetaPromise && this.navigatorMetaPromise.cancelled) {\n        this.navigatorMetaPromise = undefined;\n      }\n      options = forceSilencedErrors(options);\n      if (!this.canHaveNavigatorMetadata() || !this.navigatorMetaPromise && cachedOnly(options)) {\n        return CancellablePromise.reject();\n      }\n      if (!this.navigatorMetaPromise || shouldReload(options)) {\n        return this.reloadNavigatorMeta(options);\n      }\n      return applyCancellable(this.navigatorMetaPromise, options);\n    }\n\n    /**\n     * Gets the SQL Analyzer metadata for the entry. It will fetch it if not cached or if the refresh option is set.\n     */\n  }, {\n    key: \"getSqlAnalyzerMeta\",\n    value: function getSqlAnalyzerMeta(options) {\n      if (this.sqlAnalyzerMetaPromise && this.sqlAnalyzerMetaPromise.cancelled) {\n        this.sqlAnalyzerMetaPromise = undefined;\n      }\n      options.silenceErrors = true;\n      if (!this.dataCatalog.canHaveSqlAnalyzerMeta() || !this.isTableOrView()) {\n        return CancellablePromise.reject();\n      }\n      if (!this.sqlAnalyzerMetaPromise && cachedOnly(options)) {\n        return CancellablePromise.reject();\n      }\n      if (!this.sqlAnalyzerMetaPromise || shouldReload(options)) {\n        return this.reloadSqlAnalyzerMeta(options);\n      }\n      return applyCancellable(this.sqlAnalyzerMetaPromise, options);\n    }\n\n    /**\n     * Gets the sample for the entry, if unknown it will first check if any parent table already has the sample. It\n     * will fetch it if not cached or if the refresh option is set.\n     */\n  }, {\n    key: \"getSample\",\n    value: function getSample(options) {\n      var _this18 = this;\n      if (this.isView()) {\n        return CancellablePromise.reject();\n      }\n      if (this.samplePromise && this.samplePromise.cancelled) {\n        this.samplePromise = undefined;\n      }\n      // This prevents caching of any non-standard sample queries, i.e. DISTINCT etc.\n      if (options && options.operation && options.operation !== 'default') {\n        var operation = options.operation;\n        var samplePromise = fetchSample({\n          entry: this,\n          operation: operation,\n          silenceErrors: options.silenceErrors\n        });\n        return applyCancellable(samplePromise, options);\n      }\n\n      // Check if parent has a sample that we can reuse\n      if (!this.samplePromise && this.isColumn() && !shouldReload(options)) {\n        this.samplePromise = new CancellablePromise( /*#__PURE__*/function () {\n          var _ref18 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(resolve, reject, onCancel) {\n            var cancellablePromises, tableEntry, parentSample, colSample, _loop, i, reloadPromise;\n            return _regeneratorRuntime().wrap(function _callee23$(_context24) {\n              while (1) switch (_context24.prev = _context24.next) {\n                case 0:\n                  cancellablePromises = [];\n                  onCancel(function () {\n                    cancellablePromises.forEach(function (promise) {\n                      return promise.cancel();\n                    });\n                  });\n                  _context24.prev = 2;\n                  _context24.next = 5;\n                  return _this18.dataCatalog.getEntry({\n                    namespace: _this18.namespace,\n                    compute: _this18.compute,\n                    path: _this18.path.slice(0, 2),\n                    definition: {\n                      type: 'table'\n                    }\n                  });\n                case 5:\n                  tableEntry = _context24.sent;\n                  if (!(tableEntry && tableEntry.samplePromise)) {\n                    _context24.next = 26;\n                    break;\n                  }\n                  cancellablePromises.push(applyCancellable(tableEntry.samplePromise, options));\n                  _context24.next = 10;\n                  return tableEntry.samplePromise;\n                case 10:\n                  parentSample = _context24.sent;\n                  colSample = {\n                    hueTimestamp: parentSample.hueTimestamp,\n                    has_more: parentSample.has_more,\n                    type: parentSample.type,\n                    data: [],\n                    meta: []\n                  };\n                  if (!parentSample.meta) {\n                    _context24.next = 22;\n                    break;\n                  }\n                  _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop(i) {\n                    return _regeneratorRuntime().wrap(function _loop$(_context23) {\n                      while (1) switch (_context23.prev = _context23.next) {\n                        case 0:\n                          if (!(parentSample.meta[i].name.toLowerCase() === _this18.name.toLowerCase())) {\n                            _context23.next = 4;\n                            break;\n                          }\n                          colSample.meta[0] = parentSample.meta[i];\n                          parentSample.data.forEach(function (parentRow) {\n                            colSample.data.push([parentRow[i]]);\n                          });\n                          return _context23.abrupt(\"return\", 1);\n                        case 4:\n                        case \"end\":\n                          return _context23.stop();\n                      }\n                    }, _loop);\n                  });\n                  i = 0;\n                case 15:\n                  if (!(i < parentSample.meta.length)) {\n                    _context24.next = 22;\n                    break;\n                  }\n                  return _context24.delegateYield(_loop(i), \"t0\", 17);\n                case 17:\n                  if (!_context24.t0) {\n                    _context24.next = 19;\n                    break;\n                  }\n                  return _context24.abrupt(\"break\", 22);\n                case 19:\n                  i++;\n                  _context24.next = 15;\n                  break;\n                case 22:\n                  if (!colSample.meta.length) {\n                    _context24.next = 26;\n                    break;\n                  }\n                  _this18.sample = colSample;\n                  resolve(_this18.sample);\n                  return _context24.abrupt(\"return\");\n                case 26:\n                  _context24.next = 30;\n                  break;\n                case 28:\n                  _context24.prev = 28;\n                  _context24.t1 = _context24[\"catch\"](2);\n                case 30:\n                  if (!cachedOnly(options)) {\n                    _context24.next = 34;\n                    break;\n                  }\n                  reject();\n                  _context24.next = 46;\n                  break;\n                case 34:\n                  reloadPromise = _this18.reloadSample(options);\n                  _context24.prev = 35;\n                  _context24.t2 = resolve;\n                  _context24.next = 39;\n                  return reloadPromise;\n                case 39:\n                  _context24.t3 = _context24.sent;\n                  (0, _context24.t2)(_context24.t3);\n                  _context24.next = 46;\n                  break;\n                case 43:\n                  _context24.prev = 43;\n                  _context24.t4 = _context24[\"catch\"](35);\n                  reject();\n                case 46:\n                case \"end\":\n                  return _context24.stop();\n              }\n            }, _callee23, null, [[2, 28], [35, 43]]);\n          }));\n          return function (_x45, _x46, _x47) {\n            return _ref18.apply(this, arguments);\n          };\n        }());\n        return applyCancellable(this.samplePromise, options);\n      }\n      if (!this.samplePromise && cachedOnly(options)) {\n        return CancellablePromise.reject();\n      }\n      if (!this.samplePromise || shouldReload(options)) {\n        return this.reloadSample(options);\n      }\n      return applyCancellable(this.samplePromise, options);\n    }\n\n    /**\n     * Gets the top aggregate UDFs for the entry if it's a table or view. It will fetch it if not cached or if the refresh option is set.\n     */\n  }, {\n    key: \"getTopAggs\",\n    value: function getTopAggs(options) {\n      var _this19 = this;\n      var promise = new CancellablePromise( /*#__PURE__*/function () {\n        var _ref19 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(resolve, reject, onCancel) {\n          var multiTableEntry, topAggsPromise;\n          return _regeneratorRuntime().wrap(function _callee24$(_context25) {\n            while (1) switch (_context25.prev = _context25.next) {\n              case 0:\n                _context25.next = 2;\n                return getMultiTableEntry(_this19);\n              case 2:\n                multiTableEntry = _context25.sent;\n                topAggsPromise = multiTableEntry.getTopAggs(options);\n                onCancel(function () {\n                  topAggsPromise.cancel();\n                });\n                topAggsPromise.then(resolve)[\"catch\"](reject);\n              case 6:\n              case \"end\":\n                return _context25.stop();\n            }\n          }, _callee24);\n        }));\n        return function (_x48, _x49, _x50) {\n          return _ref19.apply(this, arguments);\n        };\n      }());\n      return applyCancellable(promise);\n    }\n\n    /**\n     * Gets the top filters for the entry if it's a table or view. It will fetch it if not cached or if the refresh option is set.\n     *\n     * @return {CancellableJqPromise}\n     */\n  }, {\n    key: \"getTopFilters\",\n    value: function getTopFilters(options) {\n      var _this20 = this;\n      var promise = new CancellablePromise( /*#__PURE__*/function () {\n        var _ref20 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(resolve, reject, onCancel) {\n          var multiTableEntry, topFiltersPromise;\n          return _regeneratorRuntime().wrap(function _callee25$(_context26) {\n            while (1) switch (_context26.prev = _context26.next) {\n              case 0:\n                _context26.next = 2;\n                return getMultiTableEntry(_this20);\n              case 2:\n                multiTableEntry = _context26.sent;\n                topFiltersPromise = multiTableEntry.getTopFilters(options);\n                onCancel(function () {\n                  topFiltersPromise.cancel();\n                });\n                topFiltersPromise.then(resolve)[\"catch\"](reject);\n              case 6:\n              case \"end\":\n                return _context26.stop();\n            }\n          }, _callee25);\n        }));\n        return function (_x51, _x52, _x53) {\n          return _ref20.apply(this, arguments);\n        };\n      }());\n      return applyCancellable(promise);\n    }\n\n    /**\n     * Gets the top joins for the entry if it's a table or view. It will fetch it if not cached or if the refresh option is set.\n     */\n  }, {\n    key: \"getTopJoins\",\n    value: function getTopJoins(options) {\n      var _this21 = this;\n      var promise = new CancellablePromise( /*#__PURE__*/function () {\n        var _ref21 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(resolve, reject, onCancel) {\n          var multiTableEntry, topJoinsPromise;\n          return _regeneratorRuntime().wrap(function _callee26$(_context27) {\n            while (1) switch (_context27.prev = _context27.next) {\n              case 0:\n                _context27.next = 2;\n                return getMultiTableEntry(_this21);\n              case 2:\n                multiTableEntry = _context27.sent;\n                topJoinsPromise = multiTableEntry.getTopJoins(options);\n                onCancel(function () {\n                  topJoinsPromise.cancel();\n                });\n                topJoinsPromise.then(resolve)[\"catch\"](reject);\n              case 6:\n              case \"end\":\n                return _context27.stop();\n            }\n          }, _callee26);\n        }));\n        return function (_x54, _x55, _x56) {\n          return _ref21.apply(this, arguments);\n        };\n      }());\n      return applyCancellable(promise);\n    }\n  }]);\n}();\nexport { DataCatalogEntry as default };","function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport localforage from 'localforage';\nimport { fetchAllNavigatorTags } from \"./api\";\nimport { DataCatalog } from \"./dataCatalog\";\nvar STORAGE_POSTFIX = window.LOGGED_USERNAME;\nvar DATA_CATALOG_VERSION = 5;\nvar NAV_TAGS_STORE_ID = 'hue.dataCatalog.allNavTags';\nvar GeneralDataCatalog = /*#__PURE__*/function () {\n  function GeneralDataCatalog() {\n    _classCallCheck(this, GeneralDataCatalog);\n    this.store = void 0;\n    this.allNavigatorTagsPromise = void 0;\n    this.store = localforage.createInstance({\n      name: 'HueDataCatalog_' + STORAGE_POSTFIX\n    });\n  }\n  return _createClass(GeneralDataCatalog, [{\n    key: \"getAllNavigatorTags\",\n    value: function () {\n      var _getAllNavigatorTags = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {\n        var _this = this;\n        var ttl;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(this.allNavigatorTagsPromise && DataCatalog.cacheEnabled() && (!options || !options.refreshCache))) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\", this.allNavigatorTagsPromise);\n            case 2:\n              if (window.HAS_CATALOG) {\n                _context.next = 4;\n                break;\n              }\n              return _context.abrupt(\"return\", {});\n            case 4:\n              ttl = window.CACHEABLE_TTL || {};\n              this.allNavigatorTagsPromise = new Promise(function (resolve, reject) {\n                var reloadAllTags = function reloadAllTags() {\n                  fetchAllNavigatorTags({\n                    silenceErrors: options && options.silenceErrors\n                  }).then(function (allTags) {\n                    resolve(allTags);\n                    if (ttl[\"default\"] && ttl[\"default\"] > 0) {\n                      _this.store.setItem(NAV_TAGS_STORE_ID, {\n                        allTags: allTags,\n                        hueTimestamp: Date.now(),\n                        version: DATA_CATALOG_VERSION\n                      });\n                    }\n                  })[\"catch\"](reject);\n                };\n                if (ttl[\"default\"] && ttl[\"default\"] > 0 && DataCatalog.cacheEnabled() && (!options || !options.refreshCache)) {\n                  _this.store.getItem(NAV_TAGS_STORE_ID).then(function (storeEntry) {\n                    if (storeEntry && storeEntry.version === DATA_CATALOG_VERSION && ttl[\"default\"] && (!storeEntry.hueTimestamp || Date.now() - storeEntry.hueTimestamp < ttl[\"default\"])) {\n                      resolve(storeEntry.allTags);\n                    } else {\n                      reloadAllTags();\n                    }\n                  })[\"catch\"](reloadAllTags);\n                } else {\n                  reloadAllTags();\n                }\n              });\n              return _context.abrupt(\"return\", this.allNavigatorTagsPromise);\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function getAllNavigatorTags(_x) {\n        return _getAllNavigatorTags.apply(this, arguments);\n      }\n      return getAllNavigatorTags;\n    }()\n  }, {\n    key: \"updateAllNavigatorTags\",\n    value: function () {\n      var _updateAllNavigatorTags = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(tagsToAdd, tagsToRemove) {\n        var allTags;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!this.allNavigatorTagsPromise) {\n                _context2.next = 8;\n                break;\n              }\n              _context2.next = 3;\n              return this.allNavigatorTagsPromise;\n            case 3:\n              allTags = _context2.sent;\n              tagsToAdd.forEach(function (newTag) {\n                if (!allTags[newTag]) {\n                  allTags[newTag] = 0;\n                }\n                allTags[newTag]++;\n              });\n              tagsToRemove.forEach(function (removedTag) {\n                if (!allTags[removedTag]) {\n                  allTags[removedTag]--;\n                  if (allTags[removedTag] === 0) {\n                    delete allTags[removedTag];\n                  }\n                }\n              });\n              _context2.next = 8;\n              return this.store.setItem(NAV_TAGS_STORE_ID, {\n                allTags: allTags,\n                hueTimestamp: Date.now(),\n                version: DATA_CATALOG_VERSION\n              });\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function updateAllNavigatorTags(_x2, _x3) {\n        return _updateAllNavigatorTags.apply(this, arguments);\n      }\n      return updateAllNavigatorTags;\n    }()\n  }]);\n}();\nexport { GeneralDataCatalog as default };","function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { DataCatalog } from \"./dataCatalog\";\nimport { CancellablePromise } from 'api/cancellablePromise';\nimport { applyCancellable } from 'catalog/catalogUtils';\nimport noop from 'utils/timing/noop';\nvar fetchAndSave = function fetchAndSave(sqlAnalyzerFunction, setFunction, entry, apiOptions) {\n  var promise = sqlAnalyzerFunction({\n    paths: entry.paths,\n    // Set for MultiTableEntry\n    silenceErrors: apiOptions && apiOptions.silenceErrors\n  });\n  promise.then(function (data) {\n    setFunction(data);\n    entry.saveLater();\n  })[\"catch\"](noop);\n  return promise;\n};\n\n/**\n * Helper function to reload a SQL Analyzer multi table attribute, like topAggs or topFilters\n */\nvar genericSqlAnalyzerReload = function genericSqlAnalyzerReload(multiTableEntry, options, promiseSetter, dataAttributeSetter, sqlAnalyzerFunction) {\n  var promise = new CancellablePromise(function (resolve, reject, onCancel) {\n    if (!multiTableEntry.dataCatalog.canHaveSqlAnalyzerMeta()) {\n      reject();\n      return;\n    }\n    var fetchPromise = fetchAndSave(sqlAnalyzerFunction, dataAttributeSetter, multiTableEntry, options);\n    onCancel(function () {\n      if (fetchPromise.cancel) {\n        fetchPromise.cancel();\n      }\n    });\n    fetchPromise.then(resolve)[\"catch\"](function (err) {\n      if (fetchPromise.cancelled) {\n        promiseSetter(undefined);\n      }\n      reject(err);\n    });\n  });\n  promiseSetter(promise);\n  return promise;\n};\n\n/**\n * Helper function to get a SQL Analyzer multi table attribute, like topAggs or topFilters\n */\nvar genericSqlAnalyzerGet = function genericSqlAnalyzerGet(multiTableEntry, options, promiseSetter, promiseGetter, dataAttributeSetter, apiHelperFunction) {\n  var promise = promiseGetter();\n  if (DataCatalog.cacheEnabled() && options && options.cachedOnly) {\n    return promise && applyCancellable(promise) || CancellablePromise.reject();\n  }\n  if (!promise || !DataCatalog.cacheEnabled() || options && options.refreshCache) {\n    promise = genericSqlAnalyzerReload(multiTableEntry, options, promiseSetter, dataAttributeSetter, apiHelperFunction);\n  }\n  return applyCancellable(promise, options);\n};\nvar MultiTableEntry = /*#__PURE__*/function () {\n  function MultiTableEntry(options) {\n    _classCallCheck(this, MultiTableEntry);\n    this.dataCatalog = void 0;\n    this.identifier = void 0;\n    this.paths = void 0;\n    this.saveTimeout = -1;\n    this.topAggs = void 0;\n    this.topAggsPromise = void 0;\n    this.topColumns = void 0;\n    this.topColumnsPromise = void 0;\n    this.topFilters = void 0;\n    this.topFiltersPromise = void 0;\n    this.topJoins = void 0;\n    this.topJoinsPromise = void 0;\n    this.identifier = options.identifier;\n    this.dataCatalog = options.dataCatalog;\n    this.paths = options.paths;\n  }\n\n  /**\n   * Save the multi table entry to cache\n   *\n   * @return {Promise}\n   */\n  return _createClass(MultiTableEntry, [{\n    key: \"save\",\n    value: function save() {\n      window.clearTimeout(this.saveTimeout);\n      return this.dataCatalog.persistMultiTableEntry(this);\n    }\n\n    /**\n     * Save the multi table entry at a later point of time\n     */\n  }, {\n    key: \"saveLater\",\n    value: function saveLater() {\n      var _this = this;\n      var ttl = window.CACHEABLE_TTL;\n      if (ttl && ttl[\"default\"] && ttl[\"default\"] > 0) {\n        window.clearTimeout(this.saveTimeout);\n        this.saveTimeout = window.setTimeout(function () {\n          _this.save()[\"catch\"]();\n        }, 1000);\n      }\n    }\n\n    /**\n     * Returns the dialect of this entry.\n     */\n  }, {\n    key: \"getDialect\",\n    value: function getDialect() {\n      return this.getConnector().dialect || this.getConnector().id; // .id for editor v1\n    }\n\n    /**\n     * Returns the connector for this entry\n     */\n  }, {\n    key: \"getConnector\",\n    value: function getConnector() {\n      return this.dataCatalog.connector;\n    }\n\n    /**\n     * Gets the top aggregate UDFs for the entry. It will fetch it if not cached or if the refresh option is set.\n     */\n  }, {\n    key: \"getTopAggs\",\n    value: function getTopAggs(options) {\n      var _this2 = this;\n      return genericSqlAnalyzerGet(this, options, function (promise) {\n        _this2.topAggsPromise = promise;\n      }, function () {\n        return _this2.topAggsPromise;\n      }, function (val) {\n        _this2.topAggs = val;\n      }, options.sqlAnalyzer.fetchTopAggs.bind(options.sqlAnalyzer));\n    }\n\n    /**\n     * Gets the top columns for the entry. It will fetch it if not cached or if the refresh option is set.\n     */\n  }, {\n    key: \"getTopColumns\",\n    value: function getTopColumns(options) {\n      var _this3 = this;\n      return genericSqlAnalyzerGet(this, options, function (promise) {\n        _this3.topColumnsPromise = promise;\n      }, function () {\n        return _this3.topColumnsPromise;\n      }, function (val) {\n        _this3.topColumns = val;\n      }, options.sqlAnalyzer.fetchTopColumns.bind(options.sqlAnalyzer));\n    }\n\n    /**\n     * Gets the top filters for the entry. It will fetch it if not cached or if the refresh option is set.\n     */\n  }, {\n    key: \"getTopFilters\",\n    value: function getTopFilters(options) {\n      var _this4 = this;\n      return genericSqlAnalyzerGet(this, options, function (promise) {\n        _this4.topFiltersPromise = promise;\n      }, function () {\n        return _this4.topFiltersPromise;\n      }, function (val) {\n        _this4.topFilters = val;\n      }, options.sqlAnalyzer.fetchTopFilters.bind(options.sqlAnalyzer));\n    }\n\n    /**\n     * Gets the top joins for the entry. It will fetch it if not cached or if the refresh option is set.\n     */\n  }, {\n    key: \"getTopJoins\",\n    value: function getTopJoins(options) {\n      var _this5 = this;\n      return genericSqlAnalyzerGet(this, options, function (promise) {\n        _this5.topJoinsPromise = promise;\n      }, function () {\n        return _this5.topJoinsPromise;\n      }, function (val) {\n        _this5.topJoins = val;\n      }, options.sqlAnalyzer.fetchTopJoins.bind(options.sqlAnalyzer));\n    }\n  }]);\n}();\nexport default MultiTableEntry;"],"names":[],"sourceRoot":""}
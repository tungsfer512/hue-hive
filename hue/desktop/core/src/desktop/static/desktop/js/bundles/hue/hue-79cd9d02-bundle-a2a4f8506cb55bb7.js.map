{"version":3,"file":"hue-79cd9d02-bundle-a2a4f8506cb55bb7.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC1yOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AChvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///./desktop/core/src/desktop/js/ext/ko.editable.custom.js","webpack:///./desktop/core/src/desktop/js/ext/ko.selectize.custom.js","webpack:///./desktop/core/src/desktop/js/ext/leaflet/leaflet.heat.js","webpack:///./desktop/core/src/desktop/js/ext/leaflet/leaflet.js","webpack:///./desktop/core/src/desktop/js/ext/leaflet/leaflet.markercluster.js","webpack:///./desktop/core/src/desktop/js/ext/leaflet/leaflet.zoombox.js","webpack:///./desktop/core/src/desktop/js/ext/nv.d3.1.1.15b.custom.js"],"sourcesContent":["function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// based on the original https://github.com/brianchance/knockout-x-editable\n\nimport $ from 'jquery';\nimport * as ko from 'knockout';\nko.bindingHandlers.editable = {\n  init: function init(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n    var $element = $(element),\n      value = valueAccessor(),\n      allBindings = allBindingsAccessor(),\n      editableOptions = allBindings.editableOptions || {};\n    editableOptions.value = ko.utils.unwrapObservable(value);\n    if (!editableOptions.name) {\n      $.each(bindingContext.$data, function (k, v) {\n        if (v == value) {\n          editableOptions.name = k;\n          return false;\n        }\n      });\n    }\n\n    //wrap calls to knockout.validation\n    if (!editableOptions.validate && value.isValid) {\n      editableOptions.validate = function (testValue) {\n        //have to set to new value, then call validate, then reset to original value\n        //not pretty, but works\n        var initalValue = value();\n        value(testValue);\n        var res = value.isValid() ? null : ko.utils.unwrapObservable(value.error);\n        value(initalValue);\n        return res;\n      };\n    }\n    if ((editableOptions.type === 'select' || editableOptions.type === 'checklist' || editableOptions.type === 'typeahead') && !editableOptions.source && editableOptions.options) {\n      //taken directly from ko.bindingHandlers['options']\n      var applyToObject = function applyToObject(object, predicate, defaultValue) {\n        var predicateType = _typeof(predicate);\n        if (predicateType === \"function\")\n          // Given a function; run it against the data value\n          return predicate(object);else if (predicateType === \"string\")\n          // Given a string; treat it as a property name on the data value\n          return object[predicate];else\n          // Given no optionsText arg; use the data value itself\n          return defaultValue;\n      };\n      if (editableOptions.optionsCaption) editableOptions.prepend = editableOptions.optionsCaption;\n      editableOptions.source = function () {\n        return ko.utils.arrayMap(editableOptions.options(), function (item) {\n          var optionValue = applyToObject(item, editableOptions.optionsValue, item);\n          var optionText = applyToObject(item, editableOptions.optionsText, optionText);\n          return {\n            value: ko.utils.unwrapObservable(optionValue),\n            text: ko.utils.unwrapObservable(optionText)\n          };\n        });\n      };\n    }\n    if (editableOptions.visible && ko.isObservable(editableOptions.visible)) {\n      editableOptions.toggle = 'manual';\n    }\n    var onActionRender = undefined;\n    if (editableOptions.inlineEditAction) {\n      onActionRender = function onActionRender($container, overflowing) {\n        if (!overflowing) {\n          var $editAction = $('<a href=\"javascript:void(0);\"><i class=\"fa fa-fw fa-pencil\"></i></a>');\n          if (editableOptions.inlineEditAction.editClass) {\n            $editAction.addClass(editableOptions.inlineEditAction.editClass);\n          }\n          $editAction.on('click', function () {\n            $editable.editable('toggle');\n          });\n          $editAction.appendTo($container);\n        }\n      };\n    }\n    var addPlaceHolder = function addPlaceHolder($container) {\n      if (editableOptions.placeholder) {\n        $('<div>').addClass('editable-inline-empty').text(editableOptions.placeholder).click(function () {\n          $editable.editable('toggle');\n        }).appendTo($container);\n      }\n    };\n    var multiLineEllipsisHandler;\n    if (editableOptions.multiLineEllipsis) {\n      editableOptions.display = function (value) {\n        if (!value) {\n          if (multiLineEllipsisHandler) {\n            multiLineEllipsisHandler.pause();\n          }\n          var $container = $(this);\n          $container.empty();\n          addPlaceHolder($container);\n          if (onActionRender) {\n            onActionRender($container);\n          }\n          return;\n        }\n        if (!multiLineEllipsisHandler) {\n          multiLineEllipsisHandler = new MultiLineEllipsisHandler({\n            element: element,\n            text: value,\n            overflowHeight: editableOptions.multiLineEllipsis.overflowHeight,\n            expandable: editableOptions.multiLineEllipsis,\n            expandActionClass: editableOptions.multiLineEllipsis.expandActionClass,\n            linkify: true,\n            onActionRender: onActionRender\n          });\n          ko.utils.domNodeDisposal.addDisposeCallback(element, function () {\n            multiLineEllipsisHandler.dispose();\n          });\n        } else {\n          multiLineEllipsisHandler.setText(value);\n          multiLineEllipsisHandler.resume();\n        }\n      };\n    } else if (onActionRender) {\n      editableOptions.display = function (value) {\n        var $container = $(this);\n        if (!value) {\n          addPlaceHolder($container);\n        } else {\n          $('<span>').html(value).appendTo($container);\n        }\n        onActionRender($container);\n      };\n      onActionRender = function onActionRender($container) {\n        var $editAction = $('<a href=\"javascript:void(0);\"><i class=\"fa fa-fw fa-pencil\"></i></a>');\n        if (editableOptions.inlineEditAction.editClass) {\n          $editAction.addClass(editableOptions.inlineEditAction.editClass);\n        }\n        $editAction.appendTo($container);\n      };\n    }\n\n    //create editable\n    var $editable = $element.editable(editableOptions);\n    if (editableOptions.multiLineEllipsis) {\n      $editable.off('.multiLine');\n      $editable.on('hidden.multiLine', function () {\n        if (multiLineEllipsisHandler && ko.unwrap(value)) {\n          multiLineEllipsisHandler.resume();\n        }\n      });\n      $editable.on('shown.multiLine', function () {\n        if (multiLineEllipsisHandler) {\n          multiLineEllipsisHandler.pause();\n        }\n      });\n    }\n\n    //update observable on save\n    if (ko.isObservable(value)) {\n      $editable.on('save.ko', function (e, params) {\n        var newValue = params.newValue || '';\n        newValue = newValue.replace(/<(?:.|\\n)*?>/gm, '');\n        if (editableOptions.type !== 'textarea') {\n          newValue = newValue.replace(/\\r?\\n|\\r/g, ' ');\n        }\n        value(newValue);\n      });\n    }\n    if (editableOptions.toggleElement) {\n      var $clickable = $element.parent().find(editableOptions.toggleElement);\n      if ($element.parents('.show-inactive-on-hover').length > 0) {\n        $clickable = $element.parents('.show-inactive-on-hover').find(editableOptions.toggleElement);\n      }\n      if ($clickable !== null) {\n        $clickable.on('click', function (e) {\n          e.stopPropagation();\n          e.preventDefault();\n          $editable.editable('toggle');\n        });\n      }\n    }\n    if (editableOptions.save) {\n      $editable.on('save', editableOptions.save.bind(viewModel));\n    }\n\n    //setup observable to fire only when editable changes, not when options change\n    //http://www.knockmeout.net/2012/06/knockoutjs-performance-gotcha-3-all-bindings.html\n    ko.computed({\n      read: function read() {\n        var _allBindings = ko.utils.unwrapObservable(allBindingsAccessor());\n        var _options = _allBindings.editableOptions || {};\n        if (_options.enabled != null && _options.enabled) {\n          $editable.editable('enable');\n        } else {\n          $editable.editable('disable');\n        }\n        var val = ko.utils.unwrapObservable(valueAccessor());\n        if (val === null) val = '';\n        $editable.editable('setValue', val, true);\n      },\n      owner: this,\n      disposeWhenNodeIsRemoved: element\n    });\n    if (editableOptions.visible && ko.isObservable(editableOptions.visible)) {\n      ko.computed({\n        read: function read() {\n          var val = ko.utils.unwrapObservable(editableOptions.visible());\n          if (val) $editable.editable('show');\n        },\n        owner: this,\n        disposeWhenNodeIsRemoved: element\n      });\n      $editable.on('hidden.ko', function (e, params) {\n        editableOptions.visible(false);\n      });\n    }\n  }\n};","// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Based on https://gist.githubusercontent.com/xtranophilist/8001624/raw/ko_selectize.js\n\nimport $ from 'jquery';\nimport * as ko from 'knockout';\nimport I18n from \"../utils/i18n\";\nvar inject_binding = function inject_binding(allBindings, key, value) {\n  //https://github.com/knockout/knockout/pull/932#issuecomment-26547528\n  return {\n    has: function has(bindingKey) {\n      return bindingKey == key || allBindings.has(bindingKey);\n    },\n    get: function get(bindingKey) {\n      var binding = allBindings.get(bindingKey);\n      if (bindingKey == key) {\n        binding = binding ? [].concat(binding, value) : value;\n      }\n      return binding;\n    }\n  };\n};\nko.bindingHandlers.browserAwareSelectize = {\n  init: function init(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n    ko.bindingHandlers.selectize.init.apply(null, arguments);\n  },\n  update: function update(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n    ko.bindingHandlers.selectize.update.apply(null, arguments);\n  }\n};\nko.bindingHandlers.selectize = {\n  init: function init(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n    if (typeof allBindingsAccessor.get('optionsCaption') == 'undefined') allBindingsAccessor = inject_binding(allBindingsAccessor, 'optionsCaption', I18n('Choose...'));\n    ko.bindingHandlers.options.update(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);\n    var options = {};\n    if (allBindingsAccessor.get('optionsValue')) {\n      options.valueField = allBindingsAccessor.get('optionsValue');\n    }\n    if (allBindingsAccessor.get('optionsText')) {\n      options.labelField = allBindingsAccessor.get('optionsText'), options.searchField = allBindingsAccessor.get('optionsText');\n    }\n    if (allBindingsAccessor.has('selectizeOptions')) {\n      var passed_options = allBindingsAccessor.get('selectizeOptions');\n      for (var attr_name in passed_options) {\n        if (attr_name === 'maxLength') {\n          options.createFilter = function (input) {\n            return input.length <= passed_options[attr_name];\n          };\n        } else if (attr_name === 'clearable' && passed_options[attr_name]) {\n          options.plugins = ['clear_button'];\n        } else {\n          options[attr_name] = passed_options[attr_name];\n        }\n      }\n    }\n    if (!options.hasOwnProperty('dropdownParent')) {\n      options.dropdownParent = 'body';\n    }\n    var $select = $(element).selectize(options)[0].selectize;\n    if (typeof allBindingsAccessor.get('value') == 'function') {\n      $select.addItem(allBindingsAccessor.get('value')());\n      allBindingsAccessor.get('value').subscribe(function (new_val) {\n        $select.addItem(new_val);\n      });\n    }\n    if (allBindingsAccessor.get('innerSubscriber')) {\n      valueAccessor()().forEach(function (item) {\n        var previousValue;\n        item[allBindingsAccessor.get('innerSubscriber')].subscribe(function (oldValue) {\n          previousValue = oldValue;\n        }, null, 'beforeChange');\n        item[allBindingsAccessor.get('innerSubscriber')].subscribe(function (newValue) {\n          var newOption = {};\n          newOption[options.valueField] = newValue;\n          newOption[options.labelField] = newValue;\n          $select.updateOption(previousValue, newOption);\n          $select.refreshOptions(false);\n        });\n      });\n    }\n    if (typeof allBindingsAccessor.get('selectedOptions') == 'function') {\n      allBindingsAccessor.get('selectedOptions').subscribe(function (new_val) {\n        // Removing items which are not in new value\n        var values = $select.getValue();\n        var items_to_remove = [];\n        for (var k in values) {\n          if (new_val.indexOf(values[k]) == -1) {\n            items_to_remove.push(values[k]);\n          }\n        }\n        for (var k in items_to_remove) {\n          $select.removeItem(items_to_remove[k]);\n        }\n        for (var k in new_val) {\n          $select.addItem(new_val[k]);\n        }\n      });\n      var selected = allBindingsAccessor.get('selectedOptions')();\n      for (var k in selected) {\n        $select.addItem(selected[k]);\n      }\n    }\n    if (typeof init_selectize == 'function') {\n      init_selectize($select);\n    }\n    if (typeof valueAccessor().subscribe == 'function') {\n      valueAccessor().subscribe(function (changes) {\n        // To avoid having duplicate keys, all delete operations will go first\n        var addedItems = new Array();\n        changes.forEach(function (change) {\n          switch (change.status) {\n            case 'added':\n              addedItems.push(change.value);\n              break;\n            case 'deleted':\n              var itemId = change.value[options.valueField];\n              if (typeof itemId === 'function') {\n                itemId = itemId();\n              }\n              if (itemId != null) {\n                $select.removeOption(itemId);\n              }\n          }\n        });\n        addedItems.forEach(function (item) {\n          var optionValue = item[options.valueField];\n          if (typeof optionValue === 'function') {\n            optionValue = optionValue();\n          }\n          var optionLabel = item[options.labelField];\n          if (typeof optionLabel === 'function') {\n            optionLabel = optionLabel();\n          }\n          var newOption = {};\n          newOption[options.valueField] = optionValue;\n          newOption[options.labelField] = optionLabel;\n          $select.addOption(newOption);\n          if (allBindingsAccessor.get('innerSubscriber')) {\n            var previousValue;\n            item[allBindingsAccessor.get('innerSubscriber')].subscribe(function (oldValue) {\n              previousValue = oldValue;\n            }, null, 'beforeChange');\n            item[allBindingsAccessor.get('innerSubscriber')].subscribe(function (newValue) {\n              var newOption = {};\n              newOption[options.valueField] = newValue;\n              newOption[options.labelField] = newValue;\n              $select.updateOption(previousValue, newOption);\n              $select.refreshOptions(false);\n            });\n          }\n        });\n      }, null, \"arrayChange\");\n    }\n  },\n  update: function update(element, valueAccessor, allBindingsAccessor) {\n    var optionsValue = allBindingsAccessor.get('optionsValue') || 'value';\n    var value_accessor = valueAccessor();\n    if (allBindingsAccessor.has('selectedObjects')) {\n      allBindingsAccessor.get('selectedObjects')($.grep(value_accessor(), function (i) {\n        var id = i[optionsValue];\n        if (typeof i[optionsValue] == 'function') {\n          id = i[optionsValue]();\n        }\n        return allBindingsAccessor.get('selectedOptions')().indexOf(id) > -1;\n      }));\n    }\n    if (allBindingsAccessor.has('object')) {\n      allBindingsAccessor.get('object')($.grep(value_accessor(), function (i) {\n        var id = i[optionsValue];\n        if (typeof i[optionsValue] == 'function') {\n          id = i[optionsValue]();\n        }\n        return id == allBindingsAccessor.get('value')();\n      })[0]);\n    }\n  }\n};","/*\n (c) 2014, Vladimir Agafonkin\n simpleheat, a tiny JavaScript library for drawing heatmaps with Canvas\n https://github.com/mourner/simpleheat\n*/\n!function () {\n  \"use strict\";\n\n  function t(i) {\n    return this instanceof t ? (this._canvas = i = \"string\" == typeof i ? document.getElementById(i) : i, this._ctx = i.getContext(\"2d\"), this._width = i.width, this._height = i.height, this._max = 1, void this.clear()) : new t(i);\n  }\n  t.prototype = {\n    defaultRadius: 25,\n    defaultGradient: {\n      .4: \"blue\",\n      .6: \"cyan\",\n      .7: \"lime\",\n      .8: \"yellow\",\n      1: \"red\"\n    },\n    data: function data(t, i) {\n      return this._data = t, this;\n    },\n    max: function max(t) {\n      return this._max = t, this;\n    },\n    add: function add(t) {\n      return this._data.push(t), this;\n    },\n    clear: function clear() {\n      return this._data = [], this;\n    },\n    radius: function radius(t, i) {\n      i = i || 15;\n      var a = this._circle = document.createElement(\"canvas\"),\n        s = a.getContext(\"2d\"),\n        e = this._r = t + i;\n      return a.width = a.height = 2 * e, s.shadowOffsetX = s.shadowOffsetY = 200, s.shadowBlur = i, s.shadowColor = \"black\", s.beginPath(), s.arc(e - 200, e - 200, t, 0, 2 * Math.PI, !0), s.closePath(), s.fill(), this;\n    },\n    gradient: function gradient(t) {\n      var i = document.createElement(\"canvas\"),\n        a = i.getContext(\"2d\"),\n        s = a.createLinearGradient(0, 0, 0, 256);\n      i.width = 1, i.height = 256;\n      for (var e in t) s.addColorStop(e, t[e]);\n      return a.fillStyle = s, a.fillRect(0, 0, 1, 256), this._grad = a.getImageData(0, 0, 1, 256).data, this;\n    },\n    draw: function draw(t) {\n      this._circle || this.radius(this.defaultRadius), this._grad || this.gradient(this.defaultGradient);\n      var i = this._ctx;\n      i.clearRect(0, 0, this._width, this._height);\n      for (var a, s = 0, e = this._data.length; e > s; s++) a = this._data[s], i.globalAlpha = Math.max(a[2] / this._max, t || .05), i.drawImage(this._circle, a[0] - this._r, a[1] - this._r);\n      var n = i.getImageData(0, 0, this._width, this._height);\n      return this._colorize(n.data, this._grad), i.putImageData(n, 0, 0), this;\n    },\n    _colorize: function _colorize(t, i) {\n      for (var a, s = 3, e = t.length; e > s; s += 4) a = 4 * t[s], a && (t[s - 3] = i[a], t[s - 2] = i[a + 1], t[s - 1] = i[a + 2]);\n    }\n  }, window.simpleheat = t;\n}(),\n/*\n(c) 2014, Vladimir Agafonkin\nLeaflet.heat, a tiny and fast heatmap plugin for Leaflet.\nhttps://github.com/Leaflet/Leaflet.heat\n*/\nL.HeatLayer = (L.Layer ? L.Layer : L.Class).extend({\n  initialize: function initialize(t, i) {\n    this._latlngs = t, L.setOptions(this, i);\n  },\n  setLatLngs: function setLatLngs(t) {\n    return this._latlngs = t, this.redraw();\n  },\n  addLatLng: function addLatLng(t) {\n    return this._latlngs.push(t), this.redraw();\n  },\n  setOptions: function setOptions(t) {\n    return L.setOptions(this, t), this._heat && this._updateOptions(), this.redraw();\n  },\n  redraw: function redraw() {\n    return !this._heat || this._frame || this._map._animating || (this._frame = L.Util.requestAnimFrame(this._redraw, this)), this;\n  },\n  onAdd: function onAdd(t) {\n    this._map = t, this._canvas || this._initCanvas(), t._panes.overlayPane.appendChild(this._canvas), t.on(\"moveend\", this._reset, this), t.options.zoomAnimation && L.Browser.any3d && t.on(\"zoomanim\", this._animateZoom, this), this._reset();\n  },\n  onRemove: function onRemove(t) {\n    t.getPanes().overlayPane.removeChild(this._canvas), t.off(\"moveend\", this._reset, this), t.options.zoomAnimation && t.off(\"zoomanim\", this._animateZoom, this);\n  },\n  addTo: function addTo(t) {\n    return t.addLayer(this), this;\n  },\n  _initCanvas: function _initCanvas() {\n    var t = this._canvas = L.DomUtil.create(\"canvas\", \"leaflet-heatmap-layer leaflet-layer\"),\n      i = L.DomUtil.testProp([\"transformOrigin\", \"WebkitTransformOrigin\", \"msTransformOrigin\"]);\n    t.style[i] = \"50% 50%\";\n    var a = this._map.getSize();\n    t.width = a.x, t.height = a.y;\n    var s = this._map.options.zoomAnimation && L.Browser.any3d;\n    L.DomUtil.addClass(t, \"leaflet-zoom-\" + (s ? \"animated\" : \"hide\")), this._heat = simpleheat(t), this._updateOptions();\n  },\n  _updateOptions: function _updateOptions() {\n    this._heat.radius(this.options.radius || this._heat.defaultRadius, this.options.blur), this.options.gradient && this._heat.gradient(this.options.gradient), this.options.max && this._heat.max(this.options.max);\n  },\n  _reset: function _reset() {\n    var t = this._map.containerPointToLayerPoint([0, 0]);\n    L.DomUtil.setPosition(this._canvas, t);\n    var i = this._map.getSize();\n    this._heat._width !== i.x && (this._canvas.width = this._heat._width = i.x), this._heat._height !== i.y && (this._canvas.height = this._heat._height = i.y), this._redraw();\n  },\n  _redraw: function _redraw() {\n    var t,\n      i,\n      a,\n      s,\n      e,\n      n,\n      h,\n      o,\n      r,\n      d = [],\n      _ = this._heat._r,\n      l = this._map.getSize(),\n      m = new L.Bounds(L.point([-_, -_]), l.add([_, _])),\n      c = void 0 === this.options.max ? 1 : this.options.max,\n      u = void 0 === this.options.maxZoom ? this._map.getMaxZoom() : this.options.maxZoom,\n      f = 1 / Math.pow(2, Math.max(0, Math.min(u - this._map.getZoom(), 12))),\n      g = _ / 2,\n      p = [],\n      v = this._map._getMapPanePos(),\n      w = v.x % g,\n      y = v.y % g;\n    for (t = 0, i = this._latlngs.length; i > t; t++) if (a = this._map.latLngToContainerPoint(this._latlngs[t]), m.contains(a)) {\n      e = Math.floor((a.x - w) / g) + 2, n = Math.floor((a.y - y) / g) + 2;\n      var x = void 0 !== this._latlngs[t].alt ? this._latlngs[t].alt : void 0 !== this._latlngs[t][2] ? +this._latlngs[t][2] : 1;\n      r = x * f, p[n] = p[n] || [], s = p[n][e], s ? (s[0] = (s[0] * s[2] + a.x * r) / (s[2] + r), s[1] = (s[1] * s[2] + a.y * r) / (s[2] + r), s[2] += r) : p[n][e] = [a.x, a.y, r];\n    }\n    for (t = 0, i = p.length; i > t; t++) if (p[t]) for (h = 0, o = p[t].length; o > h; h++) s = p[t][h], s && d.push([Math.round(s[0]), Math.round(s[1]), Math.min(s[2], c)]);\n    this._heat.data(d).draw(this.options.minOpacity), this._frame = null;\n  },\n  _animateZoom: function _animateZoom(t) {\n    var i = this._map.getZoomScale(t.zoom),\n      a = this._map._getCenterOffset(t.center)._multiplyBy(-i).subtract(this._map._getMapPanePos());\n    L.DomUtil.setTransform ? L.DomUtil.setTransform(this._canvas, a, i) : this._canvas.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(a) + \" scale(\" + i + \")\";\n  }\n}), L.heatLayer = function (t, i) {\n  return new L.HeatLayer(t, i);\n};","function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n/*\n Leaflet, a JavaScript library for mobile-friendly interactive maps. http://leafletjs.com\n (c) 2010-2013, Vladimir Agafonkin\n (c) 2010-2011, CloudMade\n*/\n\n/*\n\n    This file has Hue specific changes for L.Icon.Default\n\n*/\n\n(function (window, document, undefined) {\n  var oldL = window.L,\n    L = {};\n  L.version = '0.7.7';\n\n  // define Leaflet for Node module pattern loaders, including Browserify\n  if ((typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) === 'object' && _typeof(module.exports) === 'object') {\n    module.exports = L;\n\n    // define Leaflet as an AMD module\n  } else if (typeof define === 'function' && define.amd) {\n    define(L);\n  }\n\n  // define Leaflet as a global L variable, saving the original L to restore later if needed\n\n  L.noConflict = function () {\n    window.L = oldL;\n    return this;\n  };\n  window.L = L;\n\n  /*\n  * L.Util contains various utility functions used throughout Leaflet code.\n  */\n\n  L.Util = {\n    extend: function extend(dest) {\n      // (Object[, Object, ...]) ->\n      var sources = Array.prototype.slice.call(arguments, 1),\n        i,\n        j,\n        len,\n        src;\n      for (j = 0, len = sources.length; j < len; j++) {\n        src = sources[j] || {};\n        for (i in src) {\n          if (src.hasOwnProperty(i)) {\n            dest[i] = src[i];\n          }\n        }\n      }\n      return dest;\n    },\n    bind: function bind(fn, obj) {\n      // (Function, Object) -> Function\n      var args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;\n      return function () {\n        return fn.apply(obj, args || arguments);\n      };\n    },\n    stamp: function () {\n      var lastId = 0,\n        key = '_leaflet_id';\n      return function (obj) {\n        obj[key] = obj[key] || ++lastId;\n        return obj[key];\n      };\n    }(),\n    invokeEach: function invokeEach(obj, method, context) {\n      var i, args;\n      if (_typeof(obj) === 'object') {\n        args = Array.prototype.slice.call(arguments, 3);\n        for (i in obj) {\n          method.apply(context, [i, obj[i]].concat(args));\n        }\n        return true;\n      }\n      return false;\n    },\n    limitExecByInterval: function limitExecByInterval(fn, time, context) {\n      var lock, execOnUnlock;\n      return function wrapperFn() {\n        var args = arguments;\n        if (lock) {\n          execOnUnlock = true;\n          return;\n        }\n        lock = true;\n        setTimeout(function () {\n          lock = false;\n          if (execOnUnlock) {\n            wrapperFn.apply(context, args);\n            execOnUnlock = false;\n          }\n        }, time);\n        fn.apply(context, args);\n      };\n    },\n    falseFn: function falseFn() {\n      return false;\n    },\n    formatNum: function formatNum(num, digits) {\n      var pow = Math.pow(10, digits || 5);\n      return Math.round(num * pow) / pow;\n    },\n    trim: function trim(str) {\n      return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n    },\n    splitWords: function splitWords(str) {\n      return L.Util.trim(str).split(/\\s+/);\n    },\n    setOptions: function setOptions(obj, options) {\n      obj.options = L.extend({}, obj.options, options);\n      return obj.options;\n    },\n    getParamString: function getParamString(obj, existingUrl, uppercase) {\n      var params = [];\n      for (var i in obj) {\n        params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\n      }\n      return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');\n    },\n    template: function template(str, data) {\n      return str.replace(/\\{ *([\\w_]+) *\\}/g, function (str, key) {\n        var value = data[key];\n        if (value === undefined) {\n          throw new Error('No value provided for variable ' + str);\n        } else if (typeof value === 'function') {\n          value = value(data);\n        }\n        return value;\n      });\n    },\n    isArray: Array.isArray || function (obj) {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    },\n    emptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='\n  };\n  (function () {\n    // inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n\n    function getPrefixed(name) {\n      var i,\n        fn,\n        prefixes = ['webkit', 'moz', 'o', 'ms'];\n      for (i = 0; i < prefixes.length && !fn; i++) {\n        fn = window[prefixes[i] + name];\n      }\n      return fn;\n    }\n    var lastTime = 0;\n    function timeoutDefer(fn) {\n      var time = +new Date(),\n        timeToCall = Math.max(0, 16 - (time - lastTime));\n      lastTime = time + timeToCall;\n      return window.setTimeout(fn, timeToCall);\n    }\n    var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;\n    var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') || getPrefixed('CancelRequestAnimationFrame') || function (id) {\n      window.clearTimeout(id);\n    };\n    L.Util.requestAnimFrame = function (fn, context, immediate, element) {\n      fn = L.bind(fn, context);\n      if (immediate && requestFn === timeoutDefer) {\n        fn();\n      } else {\n        return requestFn.call(window, fn, element);\n      }\n    };\n    L.Util.cancelAnimFrame = function (id) {\n      if (id) {\n        cancelFn.call(window, id);\n      }\n    };\n  })();\n\n  // shortcuts for most used utility functions\n  L.extend = L.Util.extend;\n  L.bind = L.Util.bind;\n  L.stamp = L.Util.stamp;\n  L.setOptions = L.Util.setOptions;\n\n  /*\n  * L.Class powers the OOP facilities of the library.\n  * Thanks to John Resig and Dean Edwards for inspiration!\n  */\n\n  L.Class = function () {};\n  L.Class.extend = function (props) {\n    // extended class with the new prototype\n    var NewClass = function NewClass() {\n      // call the constructor\n      if (this.initialize) {\n        this.initialize.apply(this, arguments);\n      }\n\n      // call all constructor hooks\n      if (this._initHooks) {\n        this.callInitHooks();\n      }\n    };\n\n    // instantiate class without calling constructor\n    var F = function F() {};\n    F.prototype = this.prototype;\n    var proto = new F();\n    proto.constructor = NewClass;\n    NewClass.prototype = proto;\n\n    //inherit parent's statics\n    for (var i in this) {\n      if (this.hasOwnProperty(i) && i !== 'prototype') {\n        NewClass[i] = this[i];\n      }\n    }\n\n    // mix static properties into the class\n    if (props.statics) {\n      L.extend(NewClass, props.statics);\n      delete props.statics;\n    }\n\n    // mix includes into the prototype\n    if (props.includes) {\n      L.Util.extend.apply(null, [proto].concat(props.includes));\n      delete props.includes;\n    }\n\n    // merge options\n    if (props.options && proto.options) {\n      props.options = L.extend({}, proto.options, props.options);\n    }\n\n    // mix given properties into the prototype\n    L.extend(proto, props);\n    proto._initHooks = [];\n    var parent = this;\n    // jshint camelcase: false\n    NewClass.__super__ = parent.prototype;\n\n    // add method for calling all hooks\n    proto.callInitHooks = function () {\n      if (this._initHooksCalled) {\n        return;\n      }\n      if (parent.prototype.callInitHooks) {\n        parent.prototype.callInitHooks.call(this);\n      }\n      this._initHooksCalled = true;\n      for (var i = 0, len = proto._initHooks.length; i < len; i++) {\n        proto._initHooks[i].call(this);\n      }\n    };\n    return NewClass;\n  };\n\n  // method for adding properties to prototype\n  L.Class.include = function (props) {\n    L.extend(this.prototype, props);\n  };\n\n  // merge new default options to the Class\n  L.Class.mergeOptions = function (options) {\n    L.extend(this.prototype.options, options);\n  };\n\n  // add a constructor hook\n  L.Class.addInitHook = function (fn) {\n    // (Function) || (String, args...)\n    var args = Array.prototype.slice.call(arguments, 1);\n    var init = typeof fn === 'function' ? fn : function () {\n      this[fn].apply(this, args);\n    };\n    this.prototype._initHooks = this.prototype._initHooks || [];\n    this.prototype._initHooks.push(init);\n  };\n\n  /*\n  * L.Mixin.Events is used to add custom events functionality to Leaflet classes.\n  */\n\n  var eventsKey = '_leaflet_events';\n  L.Mixin = {};\n  L.Mixin.Events = {\n    addEventListener: function addEventListener(types, fn, context) {\n      // (String, Function[, Object]) or (Object[, Object])\n\n      // types can be a map of types/handlers\n      if (L.Util.invokeEach(types, this.addEventListener, this, fn, context)) {\n        return this;\n      }\n      var events = this[eventsKey] = this[eventsKey] || {},\n        contextId = context && context !== this && L.stamp(context),\n        i,\n        len,\n        event,\n        type,\n        indexKey,\n        indexLenKey,\n        typeIndex;\n\n      // types can be a string of space-separated words\n      types = L.Util.splitWords(types);\n      for (i = 0, len = types.length; i < len; i++) {\n        event = {\n          action: fn,\n          context: context || this\n        };\n        type = types[i];\n        if (contextId) {\n          // store listeners of a particular context in a separate hash (if it has an id)\n          // gives a major performance boost when removing thousands of map layers\n\n          indexKey = type + '_idx';\n          indexLenKey = indexKey + '_len';\n          typeIndex = events[indexKey] = events[indexKey] || {};\n          if (!typeIndex[contextId]) {\n            typeIndex[contextId] = [];\n\n            // keep track of the number of keys in the index to quickly check if it's empty\n            events[indexLenKey] = (events[indexLenKey] || 0) + 1;\n          }\n          typeIndex[contextId].push(event);\n        } else {\n          events[type] = events[type] || [];\n          events[type].push(event);\n        }\n      }\n      return this;\n    },\n    hasEventListeners: function hasEventListeners(type) {\n      // (String) -> Boolean\n      var events = this[eventsKey];\n      return !!events && (type in events && events[type].length > 0 || type + '_idx' in events && events[type + '_idx_len'] > 0);\n    },\n    removeEventListener: function removeEventListener(types, fn, context) {\n      // ([String, Function, Object]) or (Object[, Object])\n\n      if (!this[eventsKey]) {\n        return this;\n      }\n      if (!types) {\n        return this.clearAllEventListeners();\n      }\n      if (L.Util.invokeEach(types, this.removeEventListener, this, fn, context)) {\n        return this;\n      }\n      var events = this[eventsKey],\n        contextId = context && context !== this && L.stamp(context),\n        i,\n        len,\n        type,\n        listeners,\n        j,\n        indexKey,\n        indexLenKey,\n        typeIndex,\n        removed;\n      types = L.Util.splitWords(types);\n      for (i = 0, len = types.length; i < len; i++) {\n        type = types[i];\n        indexKey = type + '_idx';\n        indexLenKey = indexKey + '_len';\n        typeIndex = events[indexKey];\n        if (!fn) {\n          // clear all listeners for a type if function isn't specified\n          delete events[type];\n          delete events[indexKey];\n          delete events[indexLenKey];\n        } else {\n          listeners = contextId && typeIndex ? typeIndex[contextId] : events[type];\n          if (listeners) {\n            for (j = listeners.length - 1; j >= 0; j--) {\n              if (listeners[j].action === fn && (!context || listeners[j].context === context)) {\n                removed = listeners.splice(j, 1);\n                // set the old action to a no-op, because it is possible\n                // that the listener is being iterated over as part of a dispatch\n                removed[0].action = L.Util.falseFn;\n              }\n            }\n            if (context && typeIndex && listeners.length === 0) {\n              delete typeIndex[contextId];\n              events[indexLenKey]--;\n            }\n          }\n        }\n      }\n      return this;\n    },\n    clearAllEventListeners: function clearAllEventListeners() {\n      delete this[eventsKey];\n      return this;\n    },\n    fireEvent: function fireEvent(type, data) {\n      // (String[, Object])\n      if (!this.hasEventListeners(type)) {\n        return this;\n      }\n      var event = L.Util.extend({}, data, {\n        type: type,\n        target: this\n      });\n      var events = this[eventsKey],\n        listeners,\n        i,\n        len,\n        typeIndex,\n        contextId;\n      if (events[type]) {\n        // make sure adding/removing listeners inside other listeners won't cause infinite loop\n        listeners = events[type].slice();\n        for (i = 0, len = listeners.length; i < len; i++) {\n          listeners[i].action.call(listeners[i].context, event);\n        }\n      }\n\n      // fire event for the context-indexed listeners as well\n      typeIndex = events[type + '_idx'];\n      for (contextId in typeIndex) {\n        listeners = typeIndex[contextId].slice();\n        if (listeners) {\n          for (i = 0, len = listeners.length; i < len; i++) {\n            listeners[i].action.call(listeners[i].context, event);\n          }\n        }\n      }\n      return this;\n    },\n    addOneTimeEventListener: function addOneTimeEventListener(types, fn, context) {\n      if (L.Util.invokeEach(types, this.addOneTimeEventListener, this, fn, context)) {\n        return this;\n      }\n      var handler = L.bind(function () {\n        this.removeEventListener(types, fn, context).removeEventListener(types, handler, context);\n      }, this);\n      return this.addEventListener(types, fn, context).addEventListener(types, handler, context);\n    }\n  };\n  L.Mixin.Events.on = L.Mixin.Events.addEventListener;\n  L.Mixin.Events.off = L.Mixin.Events.removeEventListener;\n  L.Mixin.Events.once = L.Mixin.Events.addOneTimeEventListener;\n  L.Mixin.Events.fire = L.Mixin.Events.fireEvent;\n\n  /*\n  * L.Browser handles different browser and feature detections for internal Leaflet use.\n  */\n\n  (function () {\n    var ie = ('ActiveXObject' in window),\n      ielt9 = ie && !document.addEventListener,\n      // terrible browser detection to work around Safari / iOS / Android browser bugs\n      ua = navigator.userAgent.toLowerCase(),\n      webkit = ua.indexOf('webkit') !== -1,\n      chrome = ua.indexOf('chrome') !== -1,\n      phantomjs = ua.indexOf('phantom') !== -1,\n      android = ua.indexOf('android') !== -1,\n      android23 = ua.search('android [23]') !== -1,\n      gecko = ua.indexOf('gecko') !== -1,\n      mobile = (typeof orientation === \"undefined\" ? \"undefined\" : _typeof(orientation)) !== undefined + '',\n      msPointer = !window.PointerEvent && window.MSPointerEvent,\n      pointer = window.PointerEvent && window.navigator.pointerEnabled || msPointer,\n      retina = 'devicePixelRatio' in window && window.devicePixelRatio > 1 || 'matchMedia' in window && window.matchMedia('(min-resolution:144dpi)') && window.matchMedia('(min-resolution:144dpi)').matches,\n      doc = document.documentElement,\n      ie3d = ie && 'transition' in doc.style,\n      webkit3d = 'WebKitCSSMatrix' in window && 'm11' in new window.WebKitCSSMatrix() && !android23,\n      gecko3d = ('MozPerspective' in doc.style),\n      opera3d = ('OTransition' in doc.style),\n      any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs;\n    var touch = !window.L_NO_TOUCH && !phantomjs && (pointer || 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch);\n    L.Browser = {\n      ie: ie,\n      ielt9: ielt9,\n      webkit: webkit,\n      gecko: gecko && !webkit && !window.opera && !ie,\n      android: android,\n      android23: android23,\n      chrome: chrome,\n      ie3d: ie3d,\n      webkit3d: webkit3d,\n      gecko3d: gecko3d,\n      opera3d: opera3d,\n      any3d: any3d,\n      mobile: mobile,\n      mobileWebkit: mobile && webkit,\n      mobileWebkit3d: mobile && webkit3d,\n      mobileOpera: mobile && window.opera,\n      touch: touch,\n      msPointer: msPointer,\n      pointer: pointer,\n      retina: retina\n    };\n  })();\n\n  /*\n  * L.Point represents a point with x and y coordinates.\n  */\n\n  L.Point = function ( /*Number*/x, /*Number*/y, /*Boolean*/round) {\n    this.x = round ? Math.round(x) : x;\n    this.y = round ? Math.round(y) : y;\n  };\n  L.Point.prototype = {\n    clone: function clone() {\n      return new L.Point(this.x, this.y);\n    },\n    // non-destructive, returns a new point\n    add: function add(point) {\n      return this.clone()._add(L.point(point));\n    },\n    // destructive, used directly for performance in situations where it's safe to modify existing point\n    _add: function _add(point) {\n      this.x += point.x;\n      this.y += point.y;\n      return this;\n    },\n    subtract: function subtract(point) {\n      return this.clone()._subtract(L.point(point));\n    },\n    _subtract: function _subtract(point) {\n      this.x -= point.x;\n      this.y -= point.y;\n      return this;\n    },\n    divideBy: function divideBy(num) {\n      return this.clone()._divideBy(num);\n    },\n    _divideBy: function _divideBy(num) {\n      this.x /= num;\n      this.y /= num;\n      return this;\n    },\n    multiplyBy: function multiplyBy(num) {\n      return this.clone()._multiplyBy(num);\n    },\n    _multiplyBy: function _multiplyBy(num) {\n      this.x *= num;\n      this.y *= num;\n      return this;\n    },\n    round: function round() {\n      return this.clone()._round();\n    },\n    _round: function _round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      return this;\n    },\n    floor: function floor() {\n      return this.clone()._floor();\n    },\n    _floor: function _floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      return this;\n    },\n    distanceTo: function distanceTo(point) {\n      point = L.point(point);\n      var x = point.x - this.x,\n        y = point.y - this.y;\n      return Math.sqrt(x * x + y * y);\n    },\n    equals: function equals(point) {\n      point = L.point(point);\n      return point.x === this.x && point.y === this.y;\n    },\n    contains: function contains(point) {\n      point = L.point(point);\n      return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);\n    },\n    toString: function toString() {\n      return 'Point(' + L.Util.formatNum(this.x) + ', ' + L.Util.formatNum(this.y) + ')';\n    }\n  };\n  L.point = function (x, y, round) {\n    if (x instanceof L.Point) {\n      return x;\n    }\n    if (L.Util.isArray(x)) {\n      return new L.Point(x[0], x[1]);\n    }\n    if (x === undefined || x === null) {\n      return x;\n    }\n    return new L.Point(x, y, round);\n  };\n\n  /*\n  * L.Bounds represents a rectangular area on the screen in pixel coordinates.\n  */\n\n  L.Bounds = function (a, b) {\n    //(Point, Point) or Point[]\n    if (!a) {\n      return;\n    }\n    var points = b ? [a, b] : a;\n    for (var i = 0, len = points.length; i < len; i++) {\n      this.extend(points[i]);\n    }\n  };\n  L.Bounds.prototype = {\n    // extend the bounds to contain the given point\n    extend: function extend(point) {\n      // (Point)\n      point = L.point(point);\n      if (!this.min && !this.max) {\n        this.min = point.clone();\n        this.max = point.clone();\n      } else {\n        this.min.x = Math.min(point.x, this.min.x);\n        this.max.x = Math.max(point.x, this.max.x);\n        this.min.y = Math.min(point.y, this.min.y);\n        this.max.y = Math.max(point.y, this.max.y);\n      }\n      return this;\n    },\n    getCenter: function getCenter(round) {\n      // (Boolean) -> Point\n      return new L.Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);\n    },\n    getBottomLeft: function getBottomLeft() {\n      // -> Point\n      return new L.Point(this.min.x, this.max.y);\n    },\n    getTopRight: function getTopRight() {\n      // -> Point\n      return new L.Point(this.max.x, this.min.y);\n    },\n    getSize: function getSize() {\n      return this.max.subtract(this.min);\n    },\n    contains: function contains(obj) {\n      // (Bounds) or (Point) -> Boolean\n      var min, max;\n      if (typeof obj[0] === 'number' || obj instanceof L.Point) {\n        obj = L.point(obj);\n      } else {\n        obj = L.bounds(obj);\n      }\n      if (obj instanceof L.Bounds) {\n        min = obj.min;\n        max = obj.max;\n      } else {\n        min = max = obj;\n      }\n      return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;\n    },\n    intersects: function intersects(bounds) {\n      // (Bounds) -> Boolean\n      bounds = L.bounds(bounds);\n      var min = this.min,\n        max = this.max,\n        min2 = bounds.min,\n        max2 = bounds.max,\n        xIntersects = max2.x >= min.x && min2.x <= max.x,\n        yIntersects = max2.y >= min.y && min2.y <= max.y;\n      return xIntersects && yIntersects;\n    },\n    isValid: function isValid() {\n      return !!(this.min && this.max);\n    }\n  };\n  L.bounds = function (a, b) {\n    // (Bounds) or (Point, Point) or (Point[])\n    if (!a || a instanceof L.Bounds) {\n      return a;\n    }\n    return new L.Bounds(a, b);\n  };\n\n  /*\n  * L.Transformation is an utility class to perform simple point transformations through a 2d-matrix.\n  */\n\n  L.Transformation = function (a, b, c, d) {\n    this._a = a;\n    this._b = b;\n    this._c = c;\n    this._d = d;\n  };\n  L.Transformation.prototype = {\n    transform: function transform(point, scale) {\n      // (Point, Number) -> Point\n      return this._transform(point.clone(), scale);\n    },\n    // destructive transform (faster)\n    _transform: function _transform(point, scale) {\n      scale = scale || 1;\n      point.x = scale * (this._a * point.x + this._b);\n      point.y = scale * (this._c * point.y + this._d);\n      return point;\n    },\n    untransform: function untransform(point, scale) {\n      scale = scale || 1;\n      return new L.Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);\n    }\n  };\n\n  /*\n  * L.DomUtil contains various utility functions for working with DOM.\n  */\n\n  L.DomUtil = {\n    get: function get(id) {\n      return typeof id === 'string' ? document.getElementById(id) : id;\n    },\n    getStyle: function getStyle(el, style) {\n      var value = el.style[style];\n      if (!value && el.currentStyle) {\n        value = el.currentStyle[style];\n      }\n      if ((!value || value === 'auto') && document.defaultView) {\n        var css = document.defaultView.getComputedStyle(el, null);\n        value = css ? css[style] : null;\n      }\n      return value === 'auto' ? null : value;\n    },\n    getViewportOffset: function getViewportOffset(element) {\n      var top = 0,\n        left = 0,\n        el = element,\n        docBody = document.body,\n        docEl = document.documentElement,\n        pos;\n      do {\n        top += el.offsetTop || 0;\n        left += el.offsetLeft || 0;\n\n        //add borders\n        top += parseInt(L.DomUtil.getStyle(el, 'borderTopWidth'), 10) || 0;\n        left += parseInt(L.DomUtil.getStyle(el, 'borderLeftWidth'), 10) || 0;\n        pos = L.DomUtil.getStyle(el, 'position');\n        if (el.offsetParent === docBody && pos === 'absolute') {\n          break;\n        }\n        if (pos === 'fixed') {\n          top += docBody.scrollTop || docEl.scrollTop || 0;\n          left += docBody.scrollLeft || docEl.scrollLeft || 0;\n          break;\n        }\n        if (pos === 'relative' && !el.offsetLeft) {\n          var width = L.DomUtil.getStyle(el, 'width'),\n            maxWidth = L.DomUtil.getStyle(el, 'max-width'),\n            r = el.getBoundingClientRect();\n          if (width !== 'none' || maxWidth !== 'none') {\n            left += r.left + el.clientLeft;\n          }\n\n          //calculate full y offset since we're breaking out of the loop\n          top += r.top + (docBody.scrollTop || docEl.scrollTop || 0);\n          break;\n        }\n        el = el.offsetParent;\n      } while (el);\n      el = element;\n      do {\n        if (el === docBody) {\n          break;\n        }\n        top -= el.scrollTop || 0;\n        left -= el.scrollLeft || 0;\n        el = el.parentNode;\n      } while (el);\n      return new L.Point(left, top);\n    },\n    documentIsLtr: function documentIsLtr() {\n      if (!L.DomUtil._docIsLtrCached) {\n        L.DomUtil._docIsLtrCached = true;\n        L.DomUtil._docIsLtr = L.DomUtil.getStyle(document.body, 'direction') === 'ltr';\n      }\n      return L.DomUtil._docIsLtr;\n    },\n    create: function create(tagName, className, container) {\n      var el = document.createElement(tagName);\n      el.className = className;\n      if (container) {\n        container.appendChild(el);\n      }\n      return el;\n    },\n    hasClass: function hasClass(el, name) {\n      if (el.classList !== undefined) {\n        return el.classList.contains(name);\n      }\n      var className = L.DomUtil._getClass(el);\n      return className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\n    },\n    addClass: function addClass(el, name) {\n      if (el.classList !== undefined) {\n        var classes = L.Util.splitWords(name);\n        for (var i = 0, len = classes.length; i < len; i++) {\n          el.classList.add(classes[i]);\n        }\n      } else if (!L.DomUtil.hasClass(el, name)) {\n        var className = L.DomUtil._getClass(el);\n        L.DomUtil._setClass(el, (className ? className + ' ' : '') + name);\n      }\n    },\n    removeClass: function removeClass(el, name) {\n      if (el.classList !== undefined) {\n        el.classList.remove(name);\n      } else {\n        L.DomUtil._setClass(el, L.Util.trim((' ' + L.DomUtil._getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\n      }\n    },\n    _setClass: function _setClass(el, name) {\n      if (el.className.baseVal === undefined) {\n        el.className = name;\n      } else {\n        // in case of SVG element\n        el.className.baseVal = name;\n      }\n    },\n    _getClass: function _getClass(el) {\n      return el.className.baseVal === undefined ? el.className : el.className.baseVal;\n    },\n    setOpacity: function setOpacity(el, value) {\n      if ('opacity' in el.style) {\n        el.style.opacity = value;\n      } else if ('filter' in el.style) {\n        var filter = false,\n          filterName = 'DXImageTransform.Microsoft.Alpha';\n\n        // filters collection throws an error if we try to retrieve a filter that doesn't exist\n        try {\n          filter = el.filters.item(filterName);\n        } catch (e) {\n          // don't set opacity to 1 if we haven't already set an opacity,\n          // it isn't needed and breaks transparent pngs.\n          if (value === 1) {\n            return;\n          }\n        }\n        value = Math.round(value * 100);\n        if (filter) {\n          filter.Enabled = value !== 100;\n          filter.Opacity = value;\n        } else {\n          el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';\n        }\n      }\n    },\n    testProp: function testProp(props) {\n      var style = document.documentElement.style;\n      for (var i = 0; i < props.length; i++) {\n        if (props[i] in style) {\n          return props[i];\n        }\n      }\n      return false;\n    },\n    getTranslateString: function getTranslateString(point) {\n      // on WebKit browsers (Chrome/Safari/iOS Safari/Android) using translate3d instead of translate\n      // makes animation smoother as it ensures HW accel is used. Firefox 13 doesn't care\n      // (same speed either way), Opera 12 doesn't support translate3d\n\n      var is3d = L.Browser.webkit3d,\n        open = 'translate' + (is3d ? '3d' : '') + '(',\n        close = (is3d ? ',0' : '') + ')';\n      return open + point.x + 'px,' + point.y + 'px' + close;\n    },\n    getScaleString: function getScaleString(scale, origin) {\n      var preTranslateStr = L.DomUtil.getTranslateString(origin.add(origin.multiplyBy(-1 * scale))),\n        scaleStr = ' scale(' + scale + ') ';\n      return preTranslateStr + scaleStr;\n    },\n    setPosition: function setPosition(el, point, disable3D) {\n      // (HTMLElement, Point[, Boolean])\n\n      // jshint camelcase: false\n      el._leaflet_pos = point;\n      if (!disable3D && L.Browser.any3d) {\n        el.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(point);\n      } else {\n        el.style.left = point.x + 'px';\n        el.style.top = point.y + 'px';\n      }\n    },\n    getPosition: function getPosition(el) {\n      // this method is only used for elements previously positioned using setPosition,\n      // so it's safe to cache the position for performance\n\n      // jshint camelcase: false\n      return el._leaflet_pos;\n    }\n  };\n\n  // prefix style property names\n\n  L.DomUtil.TRANSFORM = L.DomUtil.testProp(['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);\n\n  // webkitTransition comes first because some browser versions that drop vendor prefix don't do\n  // the same for the transitionend event, in particular the Android 4.1 stock browser\n\n  L.DomUtil.TRANSITION = L.DomUtil.testProp(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);\n  L.DomUtil.TRANSITION_END = L.DomUtil.TRANSITION === 'webkitTransition' || L.DomUtil.TRANSITION === 'OTransition' ? L.DomUtil.TRANSITION + 'End' : 'transitionend';\n  (function () {\n    if ('onselectstart' in document) {\n      L.extend(L.DomUtil, {\n        disableTextSelection: function disableTextSelection() {\n          L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);\n        },\n        enableTextSelection: function enableTextSelection() {\n          L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);\n        }\n      });\n    } else {\n      var userSelectProperty = L.DomUtil.testProp(['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);\n      L.extend(L.DomUtil, {\n        disableTextSelection: function disableTextSelection() {\n          if (userSelectProperty) {\n            var style = document.documentElement.style;\n            this._userSelect = style[userSelectProperty];\n            style[userSelectProperty] = 'none';\n          }\n        },\n        enableTextSelection: function enableTextSelection() {\n          if (userSelectProperty) {\n            document.documentElement.style[userSelectProperty] = this._userSelect;\n            delete this._userSelect;\n          }\n        }\n      });\n    }\n    L.extend(L.DomUtil, {\n      disableImageDrag: function disableImageDrag() {\n        L.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);\n      },\n      enableImageDrag: function enableImageDrag() {\n        L.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);\n      }\n    });\n  })();\n\n  /*\n  * L.LatLng represents a geographical point with latitude and longitude coordinates.\n  */\n\n  L.LatLng = function (lat, lng, alt) {\n    // (Number, Number, Number)\n    lat = parseFloat(lat);\n    lng = parseFloat(lng);\n    if (isNaN(lat) || isNaN(lng)) {\n      throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');\n    }\n    this.lat = lat;\n    this.lng = lng;\n    if (alt !== undefined) {\n      this.alt = parseFloat(alt);\n    }\n  };\n  L.extend(L.LatLng, {\n    DEG_TO_RAD: Math.PI / 180,\n    RAD_TO_DEG: 180 / Math.PI,\n    MAX_MARGIN: 1.0E-9 // max margin of error for the \"equals\" check\n  });\n  L.LatLng.prototype = {\n    equals: function equals(obj) {\n      // (LatLng) -> Boolean\n      if (!obj) {\n        return false;\n      }\n      obj = L.latLng(obj);\n      var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));\n      return margin <= L.LatLng.MAX_MARGIN;\n    },\n    toString: function toString(precision) {\n      // (Number) -> String\n      return 'LatLng(' + L.Util.formatNum(this.lat, precision) + ', ' + L.Util.formatNum(this.lng, precision) + ')';\n    },\n    // Haversine distance formula, see http://en.wikipedia.org/wiki/Haversine_formula\n    // TODO move to projection code, LatLng shouldn't know about Earth\n    distanceTo: function distanceTo(other) {\n      // (LatLng) -> Number\n      other = L.latLng(other);\n      var R = 6378137,\n        // earth radius in meters\n        d2r = L.LatLng.DEG_TO_RAD,\n        dLat = (other.lat - this.lat) * d2r,\n        dLon = (other.lng - this.lng) * d2r,\n        lat1 = this.lat * d2r,\n        lat2 = other.lat * d2r,\n        sin1 = Math.sin(dLat / 2),\n        sin2 = Math.sin(dLon / 2);\n      var a = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);\n      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    },\n    wrap: function wrap(a, b) {\n      // (Number, Number) -> LatLng\n      var lng = this.lng;\n      a = a || -180;\n      b = b || 180;\n      lng = (lng + b) % (b - a) + (lng < a || lng === b ? b : a);\n      return new L.LatLng(this.lat, lng);\n    }\n  };\n  L.latLng = function (a, b) {\n    // (LatLng) or ([Number, Number]) or (Number, Number)\n    if (a instanceof L.LatLng) {\n      return a;\n    }\n    if (L.Util.isArray(a)) {\n      if (typeof a[0] === 'number' || typeof a[0] === 'string') {\n        return new L.LatLng(a[0], a[1], a[2]);\n      } else {\n        return null;\n      }\n    }\n    if (a === undefined || a === null) {\n      return a;\n    }\n    if (_typeof(a) === 'object' && 'lat' in a) {\n      return new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon);\n    }\n    if (b === undefined) {\n      return null;\n    }\n    return new L.LatLng(a, b);\n  };\n\n  /*\n  * L.LatLngBounds represents a rectangular area on the map in geographical coordinates.\n  */\n\n  L.LatLngBounds = function (southWest, northEast) {\n    // (LatLng, LatLng) or (LatLng[])\n    if (!southWest) {\n      return;\n    }\n    var latlngs = northEast ? [southWest, northEast] : southWest;\n    for (var i = 0, len = latlngs.length; i < len; i++) {\n      this.extend(latlngs[i]);\n    }\n  };\n  L.LatLngBounds.prototype = {\n    // extend the bounds to contain the given point or bounds\n    extend: function extend(obj) {\n      // (LatLng) or (LatLngBounds)\n      if (!obj) {\n        return this;\n      }\n      var latLng = L.latLng(obj);\n      if (latLng !== null) {\n        obj = latLng;\n      } else {\n        obj = L.latLngBounds(obj);\n      }\n      if (obj instanceof L.LatLng) {\n        if (!this._southWest && !this._northEast) {\n          this._southWest = new L.LatLng(obj.lat, obj.lng);\n          this._northEast = new L.LatLng(obj.lat, obj.lng);\n        } else {\n          this._southWest.lat = Math.min(obj.lat, this._southWest.lat);\n          this._southWest.lng = Math.min(obj.lng, this._southWest.lng);\n          this._northEast.lat = Math.max(obj.lat, this._northEast.lat);\n          this._northEast.lng = Math.max(obj.lng, this._northEast.lng);\n        }\n      } else if (obj instanceof L.LatLngBounds) {\n        this.extend(obj._southWest);\n        this.extend(obj._northEast);\n      }\n      return this;\n    },\n    // extend the bounds by a percentage\n    pad: function pad(bufferRatio) {\n      // (Number) -> LatLngBounds\n      var sw = this._southWest,\n        ne = this._northEast,\n        heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,\n        widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\n      return new L.LatLngBounds(new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\n    },\n    getCenter: function getCenter() {\n      // -> LatLng\n      return new L.LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);\n    },\n    getSouthWest: function getSouthWest() {\n      return this._southWest;\n    },\n    getNorthEast: function getNorthEast() {\n      return this._northEast;\n    },\n    getNorthWest: function getNorthWest() {\n      return new L.LatLng(this.getNorth(), this.getWest());\n    },\n    getSouthEast: function getSouthEast() {\n      return new L.LatLng(this.getSouth(), this.getEast());\n    },\n    getWest: function getWest() {\n      return this._southWest.lng;\n    },\n    getSouth: function getSouth() {\n      return this._southWest.lat;\n    },\n    getEast: function getEast() {\n      return this._northEast.lng;\n    },\n    getNorth: function getNorth() {\n      return this._northEast.lat;\n    },\n    contains: function contains(obj) {\n      // (LatLngBounds) or (LatLng) -> Boolean\n      if (typeof obj[0] === 'number' || obj instanceof L.LatLng) {\n        obj = L.latLng(obj);\n      } else {\n        obj = L.latLngBounds(obj);\n      }\n      var sw = this._southWest,\n        ne = this._northEast,\n        sw2,\n        ne2;\n      if (obj instanceof L.LatLngBounds) {\n        sw2 = obj.getSouthWest();\n        ne2 = obj.getNorthEast();\n      } else {\n        sw2 = ne2 = obj;\n      }\n      return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;\n    },\n    intersects: function intersects(bounds) {\n      // (LatLngBounds)\n      bounds = L.latLngBounds(bounds);\n      var sw = this._southWest,\n        ne = this._northEast,\n        sw2 = bounds.getSouthWest(),\n        ne2 = bounds.getNorthEast(),\n        latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat,\n        lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;\n      return latIntersects && lngIntersects;\n    },\n    toBBoxString: function toBBoxString() {\n      return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\n    },\n    equals: function equals(bounds) {\n      // (LatLngBounds)\n      if (!bounds) {\n        return false;\n      }\n      bounds = L.latLngBounds(bounds);\n      return this._southWest.equals(bounds.getSouthWest()) && this._northEast.equals(bounds.getNorthEast());\n    },\n    isValid: function isValid() {\n      return !!(this._southWest && this._northEast);\n    }\n  };\n\n  //TODO International date line?\n\n  L.latLngBounds = function (a, b) {\n    // (LatLngBounds) or (LatLng, LatLng)\n    if (!a || a instanceof L.LatLngBounds) {\n      return a;\n    }\n    return new L.LatLngBounds(a, b);\n  };\n\n  /*\n  * L.Projection contains various geographical projections used by CRS classes.\n  */\n\n  L.Projection = {};\n\n  /*\n  * Spherical Mercator is the most popular map projection, used by EPSG:3857 CRS used by default.\n  */\n\n  L.Projection.SphericalMercator = {\n    MAX_LATITUDE: 85.0511287798,\n    project: function project(latlng) {\n      // (LatLng) -> Point\n      var d = L.LatLng.DEG_TO_RAD,\n        max = this.MAX_LATITUDE,\n        lat = Math.max(Math.min(max, latlng.lat), -max),\n        x = latlng.lng * d,\n        y = lat * d;\n      y = Math.log(Math.tan(Math.PI / 4 + y / 2));\n      return new L.Point(x, y);\n    },\n    unproject: function unproject(point) {\n      // (Point, Boolean) -> LatLng\n      var d = L.LatLng.RAD_TO_DEG,\n        lng = point.x * d,\n        lat = (2 * Math.atan(Math.exp(point.y)) - Math.PI / 2) * d;\n      return new L.LatLng(lat, lng);\n    }\n  };\n\n  /*\n  * Simple equirectangular (Plate Carree) projection, used by CRS like EPSG:4326 and Simple.\n  */\n\n  L.Projection.LonLat = {\n    project: function project(latlng) {\n      return new L.Point(latlng.lng, latlng.lat);\n    },\n    unproject: function unproject(point) {\n      return new L.LatLng(point.y, point.x);\n    }\n  };\n\n  /*\n  * L.CRS is a base object for all defined CRS (Coordinate Reference Systems) in Leaflet.\n  */\n\n  L.CRS = {\n    latLngToPoint: function latLngToPoint(latlng, zoom) {\n      // (LatLng, Number) -> Point\n      var projectedPoint = this.projection.project(latlng),\n        scale = this.scale(zoom);\n      return this.transformation._transform(projectedPoint, scale);\n    },\n    pointToLatLng: function pointToLatLng(point, zoom) {\n      // (Point, Number[, Boolean]) -> LatLng\n      var scale = this.scale(zoom),\n        untransformedPoint = this.transformation.untransform(point, scale);\n      return this.projection.unproject(untransformedPoint);\n    },\n    project: function project(latlng) {\n      return this.projection.project(latlng);\n    },\n    scale: function scale(zoom) {\n      return 256 * Math.pow(2, zoom);\n    },\n    getSize: function getSize(zoom) {\n      var s = this.scale(zoom);\n      return L.point(s, s);\n    }\n  };\n\n  /*\n  * A simple CRS that can be used for flat non-Earth maps like panoramas or game maps.\n  */\n\n  L.CRS.Simple = L.extend({}, L.CRS, {\n    projection: L.Projection.LonLat,\n    transformation: new L.Transformation(1, 0, -1, 0),\n    scale: function scale(zoom) {\n      return Math.pow(2, zoom);\n    }\n  });\n\n  /*\n  * L.CRS.EPSG3857 (Spherical Mercator) is the most common CRS for web mapping\n  * and is used by Leaflet by default.\n  */\n\n  L.CRS.EPSG3857 = L.extend({}, L.CRS, {\n    code: 'EPSG:3857',\n    projection: L.Projection.SphericalMercator,\n    transformation: new L.Transformation(0.5 / Math.PI, 0.5, -0.5 / Math.PI, 0.5),\n    project: function project(latlng) {\n      // (LatLng) -> Point\n      var projectedPoint = this.projection.project(latlng),\n        earthRadius = 6378137;\n      return projectedPoint.multiplyBy(earthRadius);\n    }\n  });\n  L.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {\n    code: 'EPSG:900913'\n  });\n\n  /*\n  * L.CRS.EPSG4326 is a CRS popular among advanced GIS specialists.\n  */\n\n  L.CRS.EPSG4326 = L.extend({}, L.CRS, {\n    code: 'EPSG:4326',\n    projection: L.Projection.LonLat,\n    transformation: new L.Transformation(1 / 360, 0.5, -1 / 360, 0.5)\n  });\n\n  /*\n  * L.Map is the central class of the API - it is used to create a map.\n  */\n\n  L.Map = L.Class.extend({\n    includes: L.Mixin.Events,\n    options: {\n      crs: L.CRS.EPSG3857,\n      /*\n      center: LatLng,\n      zoom: Number,\n      layers: Array,\n      */\n\n      fadeAnimation: L.DomUtil.TRANSITION && !L.Browser.android23,\n      trackResize: true,\n      markerZoomAnimation: L.DomUtil.TRANSITION && L.Browser.any3d\n    },\n    initialize: function initialize(id, options) {\n      // (HTMLElement or String, Object)\n      options = L.setOptions(this, options);\n      this._initContainer(id);\n      this._initLayout();\n\n      // hack for https://github.com/Leaflet/Leaflet/issues/1980\n      this._onResize = L.bind(this._onResize, this);\n      this._initEvents();\n      if (options.maxBounds) {\n        this.setMaxBounds(options.maxBounds);\n      }\n      if (options.center && options.zoom !== undefined) {\n        this.setView(L.latLng(options.center), options.zoom, {\n          reset: true\n        });\n      }\n      this._handlers = [];\n      this._layers = {};\n      this._zoomBoundLayers = {};\n      this._tileLayersNum = 0;\n      this.callInitHooks();\n      this._addLayers(options.layers);\n    },\n    // public methods that modify map state\n\n    // replaced by animation-powered implementation in Map.PanAnimation.js\n    setView: function setView(center, zoom) {\n      zoom = zoom === undefined ? this.getZoom() : zoom;\n      this._resetView(L.latLng(center), this._limitZoom(zoom));\n      return this;\n    },\n    setZoom: function setZoom(zoom, options) {\n      if (!this._loaded) {\n        this._zoom = this._limitZoom(zoom);\n        return this;\n      }\n      return this.setView(this.getCenter(), zoom, {\n        zoom: options\n      });\n    },\n    zoomIn: function zoomIn(delta, options) {\n      return this.setZoom(this._zoom + (delta || 1), options);\n    },\n    zoomOut: function zoomOut(delta, options) {\n      return this.setZoom(this._zoom - (delta || 1), options);\n    },\n    setZoomAround: function setZoomAround(latlng, zoom, options) {\n      var scale = this.getZoomScale(zoom),\n        viewHalf = this.getSize().divideBy(2),\n        containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),\n        centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\n        newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\n      return this.setView(newCenter, zoom, {\n        zoom: options\n      });\n    },\n    fitBounds: function fitBounds(bounds, options) {\n      options = options || {};\n      bounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);\n      var paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),\n        paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),\n        zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\n      zoom = options.maxZoom ? Math.min(options.maxZoom, zoom) : zoom;\n      var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\n        swPoint = this.project(bounds.getSouthWest(), zoom),\n        nePoint = this.project(bounds.getNorthEast(), zoom),\n        center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\n      return this.setView(center, zoom, options);\n    },\n    fitWorld: function fitWorld(options) {\n      return this.fitBounds([[-90, -180], [90, 180]], options);\n    },\n    panTo: function panTo(center, options) {\n      // (LatLng)\n      return this.setView(center, this._zoom, {\n        pan: options\n      });\n    },\n    panBy: function panBy(offset) {\n      // (Point)\n      // replaced with animated panBy in Map.PanAnimation.js\n      this.fire('movestart');\n      this._rawPanBy(L.point(offset));\n      this.fire('move');\n      return this.fire('moveend');\n    },\n    setMaxBounds: function setMaxBounds(bounds) {\n      bounds = L.latLngBounds(bounds);\n      this.options.maxBounds = bounds;\n      if (!bounds) {\n        return this.off('moveend', this._panInsideMaxBounds, this);\n      }\n      if (this._loaded) {\n        this._panInsideMaxBounds();\n      }\n      return this.on('moveend', this._panInsideMaxBounds, this);\n    },\n    panInsideBounds: function panInsideBounds(bounds, options) {\n      var center = this.getCenter(),\n        newCenter = this._limitCenter(center, this._zoom, bounds);\n      if (center.equals(newCenter)) {\n        return this;\n      }\n      return this.panTo(newCenter, options);\n    },\n    addLayer: function addLayer(layer) {\n      // TODO method is too big, refactor\n\n      var id = L.stamp(layer);\n      if (this._layers[id]) {\n        return this;\n      }\n      this._layers[id] = layer;\n\n      // TODO getMaxZoom, getMinZoom in ILayer (instead of options)\n      if (layer.options && (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom))) {\n        this._zoomBoundLayers[id] = layer;\n        this._updateZoomLevels();\n      }\n\n      // TODO looks ugly, refactor!!!\n      if (this.options.zoomAnimation && L.TileLayer && layer instanceof L.TileLayer) {\n        this._tileLayersNum++;\n        this._tileLayersToLoad++;\n        layer.on('load', this._onTileLayerLoad, this);\n      }\n      if (this._loaded) {\n        this._layerAdd(layer);\n      }\n      return this;\n    },\n    removeLayer: function removeLayer(layer) {\n      var id = L.stamp(layer);\n      if (!this._layers[id]) {\n        return this;\n      }\n      if (this._loaded) {\n        layer.onRemove(this);\n      }\n      delete this._layers[id];\n      if (this._loaded) {\n        this.fire('layerremove', {\n          layer: layer\n        });\n      }\n      if (this._zoomBoundLayers[id]) {\n        delete this._zoomBoundLayers[id];\n        this._updateZoomLevels();\n      }\n\n      // TODO looks ugly, refactor\n      if (this.options.zoomAnimation && L.TileLayer && layer instanceof L.TileLayer) {\n        this._tileLayersNum--;\n        this._tileLayersToLoad--;\n        layer.off('load', this._onTileLayerLoad, this);\n      }\n      return this;\n    },\n    hasLayer: function hasLayer(layer) {\n      if (!layer) {\n        return false;\n      }\n      return L.stamp(layer) in this._layers;\n    },\n    eachLayer: function eachLayer(method, context) {\n      for (var i in this._layers) {\n        method.call(context, this._layers[i]);\n      }\n      return this;\n    },\n    invalidateSize: function invalidateSize(options) {\n      if (!this._loaded) {\n        return this;\n      }\n      options = L.extend({\n        animate: false,\n        pan: true\n      }, options === true ? {\n        animate: true\n      } : options);\n      var oldSize = this.getSize();\n      this._sizeChanged = true;\n      this._initialCenter = null;\n      var newSize = this.getSize(),\n        oldCenter = oldSize.divideBy(2).round(),\n        newCenter = newSize.divideBy(2).round(),\n        offset = oldCenter.subtract(newCenter);\n      if (!offset.x && !offset.y) {\n        return this;\n      }\n      if (options.animate && options.pan) {\n        this.panBy(offset);\n      } else {\n        if (options.pan) {\n          this._rawPanBy(offset);\n        }\n        this.fire('move');\n        if (options.debounceMoveend) {\n          clearTimeout(this._sizeTimer);\n          this._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);\n        } else {\n          this.fire('moveend');\n        }\n      }\n      return this.fire('resize', {\n        oldSize: oldSize,\n        newSize: newSize\n      });\n    },\n    // TODO handler.addTo\n    addHandler: function addHandler(name, HandlerClass) {\n      if (!HandlerClass) {\n        return this;\n      }\n      var handler = this[name] = new HandlerClass(this);\n      this._handlers.push(handler);\n      if (this.options[name]) {\n        handler.enable();\n      }\n      return this;\n    },\n    remove: function remove() {\n      if (this._loaded) {\n        this.fire('unload');\n      }\n      this._initEvents('off');\n      try {\n        // throws error in IE6-8\n        delete this._container._leaflet;\n      } catch (e) {\n        this._container._leaflet = undefined;\n      }\n      this._clearPanes();\n      if (this._clearControlPos) {\n        this._clearControlPos();\n      }\n      this._clearHandlers();\n      return this;\n    },\n    // public methods for getting map state\n\n    getCenter: function getCenter() {\n      // (Boolean) -> LatLng\n      this._checkIfLoaded();\n      if (this._initialCenter && !this._moved()) {\n        return this._initialCenter;\n      }\n      return this.layerPointToLatLng(this._getCenterLayerPoint());\n    },\n    getZoom: function getZoom() {\n      return this._zoom;\n    },\n    getBounds: function getBounds() {\n      var bounds = this.getPixelBounds(),\n        sw = this.unproject(bounds.getBottomLeft()),\n        ne = this.unproject(bounds.getTopRight());\n      return new L.LatLngBounds(sw, ne);\n    },\n    getMinZoom: function getMinZoom() {\n      return this.options.minZoom === undefined ? this._layersMinZoom === undefined ? 0 : this._layersMinZoom : this.options.minZoom;\n    },\n    getMaxZoom: function getMaxZoom() {\n      return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;\n    },\n    getBoundsZoom: function getBoundsZoom(bounds, inside, padding) {\n      // (LatLngBounds[, Boolean, Point]) -> Number\n      bounds = L.latLngBounds(bounds);\n      var zoom = this.getMinZoom() - (inside ? 1 : 0),\n        maxZoom = this.getMaxZoom(),\n        size = this.getSize(),\n        nw = bounds.getNorthWest(),\n        se = bounds.getSouthEast(),\n        zoomNotFound = true,\n        boundsSize;\n      padding = L.point(padding || [0, 0]);\n      do {\n        zoom++;\n        boundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding);\n        zoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;\n      } while (zoomNotFound && zoom <= maxZoom);\n      if (zoomNotFound && inside) {\n        return null;\n      }\n      return inside ? zoom : zoom - 1;\n    },\n    getSize: function getSize() {\n      if (!this._size || this._sizeChanged) {\n        this._size = new L.Point(this._container.clientWidth, this._container.clientHeight);\n        this._sizeChanged = false;\n      }\n      return this._size.clone();\n    },\n    getPixelBounds: function getPixelBounds() {\n      var topLeftPoint = this._getTopLeftPoint();\n      return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\n    },\n    getPixelOrigin: function getPixelOrigin() {\n      this._checkIfLoaded();\n      return this._initialTopLeftPoint;\n    },\n    getPanes: function getPanes() {\n      return this._panes;\n    },\n    getContainer: function getContainer() {\n      return this._container;\n    },\n    // TODO replace with universal implementation after refactoring projections\n\n    getZoomScale: function getZoomScale(toZoom) {\n      var crs = this.options.crs;\n      return crs.scale(toZoom) / crs.scale(this._zoom);\n    },\n    getScaleZoom: function getScaleZoom(scale) {\n      return this._zoom + Math.log(scale) / Math.LN2;\n    },\n    // conversion methods\n\n    project: function project(latlng, zoom) {\n      // (LatLng[, Number]) -> Point\n      zoom = zoom === undefined ? this._zoom : zoom;\n      return this.options.crs.latLngToPoint(L.latLng(latlng), zoom);\n    },\n    unproject: function unproject(point, zoom) {\n      // (Point[, Number]) -> LatLng\n      zoom = zoom === undefined ? this._zoom : zoom;\n      return this.options.crs.pointToLatLng(L.point(point), zoom);\n    },\n    layerPointToLatLng: function layerPointToLatLng(point) {\n      // (Point)\n      var projectedPoint = L.point(point).add(this.getPixelOrigin());\n      return this.unproject(projectedPoint);\n    },\n    latLngToLayerPoint: function latLngToLayerPoint(latlng) {\n      // (LatLng)\n      var projectedPoint = this.project(L.latLng(latlng))._round();\n      return projectedPoint._subtract(this.getPixelOrigin());\n    },\n    containerPointToLayerPoint: function containerPointToLayerPoint(point) {\n      // (Point)\n      return L.point(point).subtract(this._getMapPanePos());\n    },\n    layerPointToContainerPoint: function layerPointToContainerPoint(point) {\n      // (Point)\n      return L.point(point).add(this._getMapPanePos());\n    },\n    containerPointToLatLng: function containerPointToLatLng(point) {\n      var layerPoint = this.containerPointToLayerPoint(L.point(point));\n      return this.layerPointToLatLng(layerPoint);\n    },\n    latLngToContainerPoint: function latLngToContainerPoint(latlng) {\n      return this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));\n    },\n    mouseEventToContainerPoint: function mouseEventToContainerPoint(e) {\n      // (MouseEvent)\n      return L.DomEvent.getMousePosition(e, this._container);\n    },\n    mouseEventToLayerPoint: function mouseEventToLayerPoint(e) {\n      // (MouseEvent)\n      return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\n    },\n    mouseEventToLatLng: function mouseEventToLatLng(e) {\n      // (MouseEvent)\n      return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\n    },\n    // map initialization methods\n\n    _initContainer: function _initContainer(id) {\n      var container = this._container = L.DomUtil.get(id);\n      if (!container) {\n        throw new Error('Map container not found.');\n      } else if (container._leaflet) {\n        throw new Error('Map container is already initialized.');\n      }\n      container._leaflet = true;\n    },\n    _initLayout: function _initLayout() {\n      var container = this._container;\n      L.DomUtil.addClass(container, 'leaflet-container' + (L.Browser.touch ? ' leaflet-touch' : '') + (L.Browser.retina ? ' leaflet-retina' : '') + (L.Browser.ielt9 ? ' leaflet-oldie' : '') + (this.options.fadeAnimation ? ' leaflet-fade-anim' : ''));\n      var position = L.DomUtil.getStyle(container, 'position');\n      if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {\n        container.style.position = 'relative';\n      }\n      this._initPanes();\n      if (this._initControlPos) {\n        this._initControlPos();\n      }\n    },\n    _initPanes: function _initPanes() {\n      var panes = this._panes = {};\n      this._mapPane = panes.mapPane = this._createPane('leaflet-map-pane', this._container);\n      this._tilePane = panes.tilePane = this._createPane('leaflet-tile-pane', this._mapPane);\n      panes.objectsPane = this._createPane('leaflet-objects-pane', this._mapPane);\n      panes.shadowPane = this._createPane('leaflet-shadow-pane');\n      panes.overlayPane = this._createPane('leaflet-overlay-pane');\n      panes.markerPane = this._createPane('leaflet-marker-pane');\n      panes.popupPane = this._createPane('leaflet-popup-pane');\n      var zoomHide = ' leaflet-zoom-hide';\n      if (!this.options.markerZoomAnimation) {\n        L.DomUtil.addClass(panes.markerPane, zoomHide);\n        L.DomUtil.addClass(panes.shadowPane, zoomHide);\n        L.DomUtil.addClass(panes.popupPane, zoomHide);\n      }\n    },\n    _createPane: function _createPane(className, container) {\n      return L.DomUtil.create('div', className, container || this._panes.objectsPane);\n    },\n    _clearPanes: function _clearPanes() {\n      this._container.removeChild(this._mapPane);\n    },\n    _addLayers: function _addLayers(layers) {\n      layers = layers ? L.Util.isArray(layers) ? layers : [layers] : [];\n      for (var i = 0, len = layers.length; i < len; i++) {\n        this.addLayer(layers[i]);\n      }\n    },\n    // private methods that modify map state\n\n    _resetView: function _resetView(center, zoom, preserveMapOffset, afterZoomAnim) {\n      var zoomChanged = this._zoom !== zoom;\n      if (!afterZoomAnim) {\n        this.fire('movestart');\n        if (zoomChanged) {\n          this.fire('zoomstart');\n        }\n      }\n      this._zoom = zoom;\n      this._initialCenter = center;\n      this._initialTopLeftPoint = this._getNewTopLeftPoint(center);\n      if (!preserveMapOffset) {\n        L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));\n      } else {\n        this._initialTopLeftPoint._add(this._getMapPanePos());\n      }\n      this._tileLayersToLoad = this._tileLayersNum;\n      var loading = !this._loaded;\n      this._loaded = true;\n      this.fire('viewreset', {\n        hard: !preserveMapOffset\n      });\n      if (loading) {\n        this.fire('load');\n        this.eachLayer(this._layerAdd, this);\n      }\n      this.fire('move');\n      if (zoomChanged || afterZoomAnim) {\n        this.fire('zoomend');\n      }\n      this.fire('moveend', {\n        hard: !preserveMapOffset\n      });\n    },\n    _rawPanBy: function _rawPanBy(offset) {\n      L.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\n    },\n    _getZoomSpan: function _getZoomSpan() {\n      return this.getMaxZoom() - this.getMinZoom();\n    },\n    _updateZoomLevels: function _updateZoomLevels() {\n      var i,\n        minZoom = Infinity,\n        maxZoom = -Infinity,\n        oldZoomSpan = this._getZoomSpan();\n      for (i in this._zoomBoundLayers) {\n        var layer = this._zoomBoundLayers[i];\n        if (!isNaN(layer.options.minZoom)) {\n          minZoom = Math.min(minZoom, layer.options.minZoom);\n        }\n        if (!isNaN(layer.options.maxZoom)) {\n          maxZoom = Math.max(maxZoom, layer.options.maxZoom);\n        }\n      }\n      if (i === undefined) {\n        // we have no tilelayers\n        this._layersMaxZoom = this._layersMinZoom = undefined;\n      } else {\n        this._layersMaxZoom = maxZoom;\n        this._layersMinZoom = minZoom;\n      }\n      if (oldZoomSpan !== this._getZoomSpan()) {\n        this.fire('zoomlevelschange');\n      }\n    },\n    _panInsideMaxBounds: function _panInsideMaxBounds() {\n      this.panInsideBounds(this.options.maxBounds);\n    },\n    _checkIfLoaded: function _checkIfLoaded() {\n      if (!this._loaded) {\n        throw new Error('Set map center and zoom first.');\n      }\n    },\n    // map events\n\n    _initEvents: function _initEvents(onOff) {\n      if (!L.DomEvent) {\n        return;\n      }\n      onOff = onOff || 'on';\n      L.DomEvent[onOff](this._container, 'click', this._onMouseClick, this);\n      var events = ['dblclick', 'mousedown', 'mouseup', 'mouseenter', 'mouseleave', 'mousemove', 'contextmenu'],\n        i,\n        len;\n      for (i = 0, len = events.length; i < len; i++) {\n        L.DomEvent[onOff](this._container, events[i], this._fireMouseEvent, this);\n      }\n      if (this.options.trackResize) {\n        L.DomEvent[onOff](window, 'resize', this._onResize, this);\n      }\n    },\n    _onResize: function _onResize() {\n      L.Util.cancelAnimFrame(this._resizeRequest);\n      this._resizeRequest = L.Util.requestAnimFrame(function () {\n        this.invalidateSize({\n          debounceMoveend: true\n        });\n      }, this, false, this._container);\n    },\n    _onMouseClick: function _onMouseClick(e) {\n      if (!this._loaded || !e._simulated && (this.dragging && this.dragging.moved() || this.boxZoom && this.boxZoom.moved()) || L.DomEvent._skipped(e)) {\n        return;\n      }\n      this.fire('preclick');\n      this._fireMouseEvent(e);\n    },\n    _fireMouseEvent: function _fireMouseEvent(e) {\n      if (!this._loaded || L.DomEvent._skipped(e)) {\n        return;\n      }\n      var type = e.type;\n      type = type === 'mouseenter' ? 'mouseover' : type === 'mouseleave' ? 'mouseout' : type;\n      if (!this.hasEventListeners(type)) {\n        return;\n      }\n      if (type === 'contextmenu') {\n        L.DomEvent.preventDefault(e);\n      }\n      var containerPoint = this.mouseEventToContainerPoint(e),\n        layerPoint = this.containerPointToLayerPoint(containerPoint),\n        latlng = this.layerPointToLatLng(layerPoint);\n      this.fire(type, {\n        latlng: latlng,\n        layerPoint: layerPoint,\n        containerPoint: containerPoint,\n        originalEvent: e\n      });\n    },\n    _onTileLayerLoad: function _onTileLayerLoad() {\n      this._tileLayersToLoad--;\n      if (this._tileLayersNum && !this._tileLayersToLoad) {\n        this.fire('tilelayersload');\n      }\n    },\n    _clearHandlers: function _clearHandlers() {\n      for (var i = 0, len = this._handlers.length; i < len; i++) {\n        this._handlers[i].disable();\n      }\n    },\n    whenReady: function whenReady(callback, context) {\n      if (this._loaded) {\n        callback.call(context || this, this);\n      } else {\n        this.on('load', callback, context);\n      }\n      return this;\n    },\n    _layerAdd: function _layerAdd(layer) {\n      layer.onAdd(this);\n      this.fire('layeradd', {\n        layer: layer\n      });\n    },\n    // private methods for getting map state\n\n    _getMapPanePos: function _getMapPanePos() {\n      return L.DomUtil.getPosition(this._mapPane);\n    },\n    _moved: function _moved() {\n      var pos = this._getMapPanePos();\n      return pos && !pos.equals([0, 0]);\n    },\n    _getTopLeftPoint: function _getTopLeftPoint() {\n      return this.getPixelOrigin().subtract(this._getMapPanePos());\n    },\n    _getNewTopLeftPoint: function _getNewTopLeftPoint(center, zoom) {\n      var viewHalf = this.getSize()._divideBy(2);\n      // TODO round on display, not calculation to increase precision?\n      return this.project(center, zoom)._subtract(viewHalf)._round();\n    },\n    _latLngToNewLayerPoint: function _latLngToNewLayerPoint(latlng, newZoom, newCenter) {\n      var topLeft = this._getNewTopLeftPoint(newCenter, newZoom).add(this._getMapPanePos());\n      return this.project(latlng, newZoom)._subtract(topLeft);\n    },\n    // layer point of the current center\n    _getCenterLayerPoint: function _getCenterLayerPoint() {\n      return this.containerPointToLayerPoint(this.getSize()._divideBy(2));\n    },\n    // offset of the specified place to the current center in pixels\n    _getCenterOffset: function _getCenterOffset(latlng) {\n      return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\n    },\n    // adjust center for view to get inside bounds\n    _limitCenter: function _limitCenter(center, zoom, bounds) {\n      if (!bounds) {\n        return center;\n      }\n      var centerPoint = this.project(center, zoom),\n        viewHalf = this.getSize().divideBy(2),\n        viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\n        offset = this._getBoundsOffset(viewBounds, bounds, zoom);\n      return this.unproject(centerPoint.add(offset), zoom);\n    },\n    // adjust offset for view to get inside bounds\n    _limitOffset: function _limitOffset(offset, bounds) {\n      if (!bounds) {\n        return offset;\n      }\n      var viewBounds = this.getPixelBounds(),\n        newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\n      return offset.add(this._getBoundsOffset(newBounds, bounds));\n    },\n    // returns offset needed for pxBounds to get inside maxBounds at a specified zoom\n    _getBoundsOffset: function _getBoundsOffset(pxBounds, maxBounds, zoom) {\n      var nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min),\n        seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max),\n        dx = this._rebound(nwOffset.x, -seOffset.x),\n        dy = this._rebound(nwOffset.y, -seOffset.y);\n      return new L.Point(dx, dy);\n    },\n    _rebound: function _rebound(left, right) {\n      return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\n    },\n    _limitZoom: function _limitZoom(zoom) {\n      var min = this.getMinZoom(),\n        max = this.getMaxZoom();\n      return Math.max(min, Math.min(max, zoom));\n    }\n  });\n  L.map = function (id, options) {\n    return new L.Map(id, options);\n  };\n\n  /*\n  * Mercator projection that takes into account that the Earth is not a perfect sphere.\n  * Less popular than spherical mercator; used by projections like EPSG:3395.\n  */\n\n  L.Projection.Mercator = {\n    MAX_LATITUDE: 85.0840591556,\n    R_MINOR: 6356752.314245179,\n    R_MAJOR: 6378137,\n    project: function project(latlng) {\n      // (LatLng) -> Point\n      var d = L.LatLng.DEG_TO_RAD,\n        max = this.MAX_LATITUDE,\n        lat = Math.max(Math.min(max, latlng.lat), -max),\n        r = this.R_MAJOR,\n        r2 = this.R_MINOR,\n        x = latlng.lng * d * r,\n        y = lat * d,\n        tmp = r2 / r,\n        eccent = Math.sqrt(1.0 - tmp * tmp),\n        con = eccent * Math.sin(y);\n      con = Math.pow((1 - con) / (1 + con), eccent * 0.5);\n      var ts = Math.tan(0.5 * (Math.PI * 0.5 - y)) / con;\n      y = -r * Math.log(ts);\n      return new L.Point(x, y);\n    },\n    unproject: function unproject(point) {\n      // (Point, Boolean) -> LatLng\n      var d = L.LatLng.RAD_TO_DEG,\n        r = this.R_MAJOR,\n        r2 = this.R_MINOR,\n        lng = point.x * d / r,\n        tmp = r2 / r,\n        eccent = Math.sqrt(1 - tmp * tmp),\n        ts = Math.exp(-point.y / r),\n        phi = Math.PI / 2 - 2 * Math.atan(ts),\n        numIter = 15,\n        tol = 1e-7,\n        i = numIter,\n        dphi = 0.1,\n        con;\n      while (Math.abs(dphi) > tol && --i > 0) {\n        con = eccent * Math.sin(phi);\n        dphi = Math.PI / 2 - 2 * Math.atan(ts * Math.pow((1.0 - con) / (1.0 + con), 0.5 * eccent)) - phi;\n        phi += dphi;\n      }\n      return new L.LatLng(phi * d, lng);\n    }\n  };\n  L.CRS.EPSG3395 = L.extend({}, L.CRS, {\n    code: 'EPSG:3395',\n    projection: L.Projection.Mercator,\n    transformation: function () {\n      var m = L.Projection.Mercator,\n        r = m.R_MAJOR,\n        scale = 0.5 / (Math.PI * r);\n      return new L.Transformation(scale, 0.5, -scale, 0.5);\n    }()\n  });\n\n  /*\n  * L.TileLayer is used for standard xyz-numbered tile layers.\n  */\n\n  L.TileLayer = L.Class.extend({\n    includes: L.Mixin.Events,\n    options: {\n      minZoom: 0,\n      maxZoom: 18,\n      tileSize: 256,\n      subdomains: 'abc',\n      errorTileUrl: '',\n      attribution: '',\n      zoomOffset: 0,\n      opacity: 1,\n      /*\n      maxNativeZoom: null,\n      zIndex: null,\n      tms: false,\n      continuousWorld: false,\n      noWrap: false,\n      zoomReverse: false,\n      detectRetina: false,\n      reuseTiles: false,\n      bounds: false,\n      */\n      unloadInvisibleTiles: L.Browser.mobile,\n      updateWhenIdle: L.Browser.mobile\n    },\n    initialize: function initialize(url, options) {\n      options = L.setOptions(this, options);\n\n      // detecting retina displays, adjusting tileSize and zoom levels\n      if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {\n        options.tileSize = Math.floor(options.tileSize / 2);\n        options.zoomOffset++;\n        if (options.minZoom > 0) {\n          options.minZoom--;\n        }\n        this.options.maxZoom--;\n      }\n      if (options.bounds) {\n        options.bounds = L.latLngBounds(options.bounds);\n      }\n      this._url = url;\n      var subdomains = this.options.subdomains;\n      if (typeof subdomains === 'string') {\n        this.options.subdomains = subdomains.split('');\n      }\n    },\n    onAdd: function onAdd(map) {\n      this._map = map;\n      this._animated = map._zoomAnimated;\n\n      // create a container div for tiles\n      this._initContainer();\n\n      // set up events\n      map.on({\n        'viewreset': this._reset,\n        'moveend': this._update\n      }, this);\n      if (this._animated) {\n        map.on({\n          'zoomanim': this._animateZoom,\n          'zoomend': this._endZoomAnim\n        }, this);\n      }\n      if (!this.options.updateWhenIdle) {\n        this._limitedUpdate = L.Util.limitExecByInterval(this._update, 150, this);\n        map.on('move', this._limitedUpdate, this);\n      }\n      this._reset();\n      this._update();\n    },\n    addTo: function addTo(map) {\n      map.addLayer(this);\n      return this;\n    },\n    onRemove: function onRemove(map) {\n      this._container.parentNode.removeChild(this._container);\n      map.off({\n        'viewreset': this._reset,\n        'moveend': this._update\n      }, this);\n      if (this._animated) {\n        map.off({\n          'zoomanim': this._animateZoom,\n          'zoomend': this._endZoomAnim\n        }, this);\n      }\n      if (!this.options.updateWhenIdle) {\n        map.off('move', this._limitedUpdate, this);\n      }\n      this._container = null;\n      this._map = null;\n    },\n    bringToFront: function bringToFront() {\n      var pane = this._map._panes.tilePane;\n      if (this._container) {\n        pane.appendChild(this._container);\n        this._setAutoZIndex(pane, Math.max);\n      }\n      return this;\n    },\n    bringToBack: function bringToBack() {\n      var pane = this._map._panes.tilePane;\n      if (this._container) {\n        pane.insertBefore(this._container, pane.firstChild);\n        this._setAutoZIndex(pane, Math.min);\n      }\n      return this;\n    },\n    getAttribution: function getAttribution() {\n      return this.options.attribution;\n    },\n    getContainer: function getContainer() {\n      return this._container;\n    },\n    setOpacity: function setOpacity(opacity) {\n      this.options.opacity = opacity;\n      if (this._map) {\n        this._updateOpacity();\n      }\n      return this;\n    },\n    setZIndex: function setZIndex(zIndex) {\n      this.options.zIndex = zIndex;\n      this._updateZIndex();\n      return this;\n    },\n    setUrl: function setUrl(url, noRedraw) {\n      this._url = url;\n      if (!noRedraw) {\n        this.redraw();\n      }\n      return this;\n    },\n    redraw: function redraw() {\n      if (this._map) {\n        this._reset({\n          hard: true\n        });\n        this._update();\n      }\n      return this;\n    },\n    _updateZIndex: function _updateZIndex() {\n      if (this._container && this.options.zIndex !== undefined) {\n        this._container.style.zIndex = this.options.zIndex;\n      }\n    },\n    _setAutoZIndex: function _setAutoZIndex(pane, compare) {\n      var layers = pane.children,\n        edgeZIndex = -compare(Infinity, -Infinity),\n        // -Infinity for max, Infinity for min\n        zIndex,\n        i,\n        len;\n      for (i = 0, len = layers.length; i < len; i++) {\n        if (layers[i] !== this._container) {\n          zIndex = parseInt(layers[i].style.zIndex, 10);\n          if (!isNaN(zIndex)) {\n            edgeZIndex = compare(edgeZIndex, zIndex);\n          }\n        }\n      }\n      this.options.zIndex = this._container.style.zIndex = (isFinite(edgeZIndex) ? edgeZIndex : 0) + compare(1, -1);\n    },\n    _updateOpacity: function _updateOpacity() {\n      var i,\n        tiles = this._tiles;\n      if (L.Browser.ielt9) {\n        for (i in tiles) {\n          L.DomUtil.setOpacity(tiles[i], this.options.opacity);\n        }\n      } else {\n        L.DomUtil.setOpacity(this._container, this.options.opacity);\n      }\n    },\n    _initContainer: function _initContainer() {\n      var tilePane = this._map._panes.tilePane;\n      if (!this._container) {\n        this._container = L.DomUtil.create('div', 'leaflet-layer');\n        this._updateZIndex();\n        if (this._animated) {\n          var className = 'leaflet-tile-container';\n          this._bgBuffer = L.DomUtil.create('div', className, this._container);\n          this._tileContainer = L.DomUtil.create('div', className, this._container);\n        } else {\n          this._tileContainer = this._container;\n        }\n        tilePane.appendChild(this._container);\n        if (this.options.opacity < 1) {\n          this._updateOpacity();\n        }\n      }\n    },\n    _reset: function _reset(e) {\n      for (var key in this._tiles) {\n        this.fire('tileunload', {\n          tile: this._tiles[key]\n        });\n      }\n      this._tiles = {};\n      this._tilesToLoad = 0;\n      if (this.options.reuseTiles) {\n        this._unusedTiles = [];\n      }\n      this._tileContainer.innerHTML = '';\n      if (this._animated && e && e.hard) {\n        this._clearBgBuffer();\n      }\n      this._initContainer();\n    },\n    _getTileSize: function _getTileSize() {\n      var map = this._map,\n        zoom = map.getZoom() + this.options.zoomOffset,\n        zoomN = this.options.maxNativeZoom,\n        tileSize = this.options.tileSize;\n      if (zoomN && zoom > zoomN) {\n        tileSize = Math.round(map.getZoomScale(zoom) / map.getZoomScale(zoomN) * tileSize);\n      }\n      return tileSize;\n    },\n    _update: function _update() {\n      if (!this._map) {\n        return;\n      }\n      var map = this._map,\n        bounds = map.getPixelBounds(),\n        zoom = map.getZoom(),\n        tileSize = this._getTileSize();\n      if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n        return;\n      }\n      var tileBounds = L.bounds(bounds.min.divideBy(tileSize)._floor(), bounds.max.divideBy(tileSize)._floor());\n      this._addTilesFromCenterOut(tileBounds);\n      if (this.options.unloadInvisibleTiles || this.options.reuseTiles) {\n        this._removeOtherTiles(tileBounds);\n      }\n    },\n    _addTilesFromCenterOut: function _addTilesFromCenterOut(bounds) {\n      var queue = [],\n        center = bounds.getCenter();\n      var j, i, point;\n      for (j = bounds.min.y; j <= bounds.max.y; j++) {\n        for (i = bounds.min.x; i <= bounds.max.x; i++) {\n          point = new L.Point(i, j);\n          if (this._tileShouldBeLoaded(point)) {\n            queue.push(point);\n          }\n        }\n      }\n      var tilesToLoad = queue.length;\n      if (tilesToLoad === 0) {\n        return;\n      }\n\n      // load tiles in order of their distance to center\n      queue.sort(function (a, b) {\n        return a.distanceTo(center) - b.distanceTo(center);\n      });\n      var fragment = document.createDocumentFragment();\n\n      // if its the first batch of tiles to load\n      if (!this._tilesToLoad) {\n        this.fire('loading');\n      }\n      this._tilesToLoad += tilesToLoad;\n      for (i = 0; i < tilesToLoad; i++) {\n        this._addTile(queue[i], fragment);\n      }\n      this._tileContainer.appendChild(fragment);\n    },\n    _tileShouldBeLoaded: function _tileShouldBeLoaded(tilePoint) {\n      if (tilePoint.x + ':' + tilePoint.y in this._tiles) {\n        return false; // already loaded\n      }\n      var options = this.options;\n      if (!options.continuousWorld) {\n        var limit = this._getWrapTileNum();\n\n        // don't load if exceeds world bounds\n        if (options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x) || tilePoint.y < 0 || tilePoint.y >= limit.y) {\n          return false;\n        }\n      }\n      if (options.bounds) {\n        var tileSize = this._getTileSize(),\n          nwPoint = tilePoint.multiplyBy(tileSize),\n          sePoint = nwPoint.add([tileSize, tileSize]),\n          nw = this._map.unproject(nwPoint),\n          se = this._map.unproject(sePoint);\n\n        // TODO temporary hack, will be removed after refactoring projections\n        // https://github.com/Leaflet/Leaflet/issues/1618\n        if (!options.continuousWorld && !options.noWrap) {\n          nw = nw.wrap();\n          se = se.wrap();\n        }\n        if (!options.bounds.intersects([nw, se])) {\n          return false;\n        }\n      }\n      return true;\n    },\n    _removeOtherTiles: function _removeOtherTiles(bounds) {\n      var kArr, x, y, key;\n      for (key in this._tiles) {\n        kArr = key.split(':');\n        x = parseInt(kArr[0], 10);\n        y = parseInt(kArr[1], 10);\n\n        // remove tile if it's out of bounds\n        if (x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {\n          this._removeTile(key);\n        }\n      }\n    },\n    _removeTile: function _removeTile(key) {\n      var tile = this._tiles[key];\n      this.fire('tileunload', {\n        tile: tile,\n        url: tile.src\n      });\n      if (this.options.reuseTiles) {\n        L.DomUtil.removeClass(tile, 'leaflet-tile-loaded');\n        this._unusedTiles.push(tile);\n      } else if (tile.parentNode === this._tileContainer) {\n        this._tileContainer.removeChild(tile);\n      }\n\n      // for https://github.com/CloudMade/Leaflet/issues/137\n      if (!L.Browser.android) {\n        tile.onload = null;\n        tile.src = L.Util.emptyImageUrl;\n      }\n      delete this._tiles[key];\n    },\n    _addTile: function _addTile(tilePoint, container) {\n      var tilePos = this._getTilePos(tilePoint);\n\n      // get unused tile - or create a new tile\n      var tile = this._getTile();\n\n      /*\n      Chrome 20 layouts much faster with top/left (verify with timeline, frames)\n      Android 4 browser has display issues with top/left and requires transform instead\n      (other browsers don't currently care) - see debug/hacks/jitter.html for an example\n      */\n      L.DomUtil.setPosition(tile, tilePos, L.Browser.chrome);\n      this._tiles[tilePoint.x + ':' + tilePoint.y] = tile;\n      this._loadTile(tile, tilePoint);\n      if (tile.parentNode !== this._tileContainer) {\n        container.appendChild(tile);\n      }\n    },\n    _getZoomForUrl: function _getZoomForUrl() {\n      var options = this.options,\n        zoom = this._map.getZoom();\n      if (options.zoomReverse) {\n        zoom = options.maxZoom - zoom;\n      }\n      zoom += options.zoomOffset;\n      return options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;\n    },\n    _getTilePos: function _getTilePos(tilePoint) {\n      var origin = this._map.getPixelOrigin(),\n        tileSize = this._getTileSize();\n      return tilePoint.multiplyBy(tileSize).subtract(origin);\n    },\n    // image-specific code (override to implement e.g. Canvas or SVG tile layer)\n\n    getTileUrl: function getTileUrl(tilePoint) {\n      return L.Util.template(this._url, L.extend({\n        s: this._getSubdomain(tilePoint),\n        z: tilePoint.z,\n        x: tilePoint.x,\n        y: tilePoint.y\n      }, this.options));\n    },\n    _getWrapTileNum: function _getWrapTileNum() {\n      var crs = this._map.options.crs,\n        size = crs.getSize(this._map.getZoom());\n      return size.divideBy(this._getTileSize())._floor();\n    },\n    _adjustTilePoint: function _adjustTilePoint(tilePoint) {\n      var limit = this._getWrapTileNum();\n\n      // wrap tile coordinates\n      if (!this.options.continuousWorld && !this.options.noWrap) {\n        tilePoint.x = (tilePoint.x % limit.x + limit.x) % limit.x;\n      }\n      if (this.options.tms) {\n        tilePoint.y = limit.y - tilePoint.y - 1;\n      }\n      tilePoint.z = this._getZoomForUrl();\n    },\n    _getSubdomain: function _getSubdomain(tilePoint) {\n      var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\n      return this.options.subdomains[index];\n    },\n    _getTile: function _getTile() {\n      if (this.options.reuseTiles && this._unusedTiles.length > 0) {\n        var tile = this._unusedTiles.pop();\n        this._resetTile(tile);\n        return tile;\n      }\n      return this._createTile();\n    },\n    // Override if data stored on a tile needs to be cleaned up before reuse\n    _resetTile: function _resetTile( /*tile*/) {},\n    _createTile: function _createTile() {\n      var tile = L.DomUtil.create('img', 'leaflet-tile');\n      tile.style.width = tile.style.height = this._getTileSize() + 'px';\n      tile.galleryimg = 'no';\n      tile.onselectstart = tile.onmousemove = L.Util.falseFn;\n      if (L.Browser.ielt9 && this.options.opacity !== undefined) {\n        L.DomUtil.setOpacity(tile, this.options.opacity);\n      }\n      // without this hack, tiles disappear after zoom on Chrome for Android\n      // https://github.com/Leaflet/Leaflet/issues/2078\n      if (L.Browser.mobileWebkit3d) {\n        tile.style.WebkitBackfaceVisibility = 'hidden';\n      }\n      return tile;\n    },\n    _loadTile: function _loadTile(tile, tilePoint) {\n      tile._layer = this;\n      tile.onload = this._tileOnLoad;\n      tile.onerror = this._tileOnError;\n      this._adjustTilePoint(tilePoint);\n      tile.src = this.getTileUrl(tilePoint);\n      this.fire('tileloadstart', {\n        tile: tile,\n        url: tile.src\n      });\n    },\n    _tileLoaded: function _tileLoaded() {\n      this._tilesToLoad--;\n      if (this._animated) {\n        L.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');\n      }\n      if (!this._tilesToLoad) {\n        this.fire('load');\n        if (this._animated) {\n          // clear scaled tiles after all new tiles are loaded (for performance)\n          clearTimeout(this._clearBgBufferTimer);\n          this._clearBgBufferTimer = setTimeout(L.bind(this._clearBgBuffer, this), 500);\n        }\n      }\n    },\n    _tileOnLoad: function _tileOnLoad() {\n      var layer = this._layer;\n\n      //Only if we are loading an actual image\n      if (this.src !== L.Util.emptyImageUrl) {\n        L.DomUtil.addClass(this, 'leaflet-tile-loaded');\n        layer.fire('tileload', {\n          tile: this,\n          url: this.src\n        });\n      }\n      layer._tileLoaded();\n    },\n    _tileOnError: function _tileOnError() {\n      var layer = this._layer;\n      layer.fire('tileerror', {\n        tile: this,\n        url: this.src\n      });\n      var newUrl = layer.options.errorTileUrl;\n      if (newUrl) {\n        this.src = newUrl;\n      }\n      layer._tileLoaded();\n    }\n  });\n  L.tileLayer = function (url, options) {\n    return new L.TileLayer(url, options);\n  };\n\n  /*\n  * L.TileLayer.WMS is used for putting WMS tile layers on the map.\n  */\n\n  L.TileLayer.WMS = L.TileLayer.extend({\n    defaultWmsParams: {\n      service: 'WMS',\n      request: 'GetMap',\n      version: '1.1.1',\n      layers: '',\n      styles: '',\n      format: 'image/jpeg',\n      transparent: false\n    },\n    initialize: function initialize(url, options) {\n      // (String, Object)\n\n      this._url = url;\n      var wmsParams = L.extend({}, this.defaultWmsParams),\n        tileSize = options.tileSize || this.options.tileSize;\n      if (options.detectRetina && L.Browser.retina) {\n        wmsParams.width = wmsParams.height = tileSize * 2;\n      } else {\n        wmsParams.width = wmsParams.height = tileSize;\n      }\n      for (var i in options) {\n        // all keys that are not TileLayer options go to WMS params\n        if (!this.options.hasOwnProperty(i) && i !== 'crs') {\n          wmsParams[i] = options[i];\n        }\n      }\n      this.wmsParams = wmsParams;\n      L.setOptions(this, options);\n    },\n    onAdd: function onAdd(map) {\n      this._crs = this.options.crs || map.options.crs;\n      this._wmsVersion = parseFloat(this.wmsParams.version);\n      var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';\n      this.wmsParams[projectionKey] = this._crs.code;\n      L.TileLayer.prototype.onAdd.call(this, map);\n    },\n    getTileUrl: function getTileUrl(tilePoint) {\n      // (Point, Number) -> String\n\n      var map = this._map,\n        tileSize = this.options.tileSize,\n        nwPoint = tilePoint.multiplyBy(tileSize),\n        sePoint = nwPoint.add([tileSize, tileSize]),\n        nw = this._crs.project(map.unproject(nwPoint, tilePoint.z)),\n        se = this._crs.project(map.unproject(sePoint, tilePoint.z)),\n        bbox = this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ? [se.y, nw.x, nw.y, se.x].join(',') : [nw.x, se.y, se.x, nw.y].join(','),\n        url = L.Util.template(this._url, {\n          s: this._getSubdomain(tilePoint)\n        });\n      return url + L.Util.getParamString(this.wmsParams, url, true) + '&BBOX=' + bbox;\n    },\n    setParams: function setParams(params, noRedraw) {\n      L.extend(this.wmsParams, params);\n      if (!noRedraw) {\n        this.redraw();\n      }\n      return this;\n    }\n  });\n  L.tileLayer.wms = function (url, options) {\n    return new L.TileLayer.WMS(url, options);\n  };\n\n  /*\n  * L.TileLayer.Canvas is a class that you can use as a base for creating\n  * dynamically drawn Canvas-based tile layers.\n  */\n\n  L.TileLayer.Canvas = L.TileLayer.extend({\n    options: {\n      async: false\n    },\n    initialize: function initialize(options) {\n      L.setOptions(this, options);\n    },\n    redraw: function redraw() {\n      if (this._map) {\n        this._reset({\n          hard: true\n        });\n        this._update();\n      }\n      for (var i in this._tiles) {\n        this._redrawTile(this._tiles[i]);\n      }\n      return this;\n    },\n    _redrawTile: function _redrawTile(tile) {\n      this.drawTile(tile, tile._tilePoint, this._map._zoom);\n    },\n    _createTile: function _createTile() {\n      var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n      tile.width = tile.height = this.options.tileSize;\n      tile.onselectstart = tile.onmousemove = L.Util.falseFn;\n      return tile;\n    },\n    _loadTile: function _loadTile(tile, tilePoint) {\n      tile._layer = this;\n      tile._tilePoint = tilePoint;\n      this._redrawTile(tile);\n      if (!this.options.async) {\n        this.tileDrawn(tile);\n      }\n    },\n    drawTile: function drawTile( /*tile, tilePoint*/\n    ) {\n      // override with rendering code\n    },\n    tileDrawn: function tileDrawn(tile) {\n      this._tileOnLoad.call(tile);\n    }\n  });\n  L.tileLayer.canvas = function (options) {\n    return new L.TileLayer.Canvas(options);\n  };\n\n  /*\n  * L.ImageOverlay is used to overlay images over the map (to specific geographical bounds).\n  */\n\n  L.ImageOverlay = L.Class.extend({\n    includes: L.Mixin.Events,\n    options: {\n      opacity: 1\n    },\n    initialize: function initialize(url, bounds, options) {\n      // (String, LatLngBounds, Object)\n      this._url = url;\n      this._bounds = L.latLngBounds(bounds);\n      L.setOptions(this, options);\n    },\n    onAdd: function onAdd(map) {\n      this._map = map;\n      if (!this._image) {\n        this._initImage();\n      }\n      map._panes.overlayPane.appendChild(this._image);\n      map.on('viewreset', this._reset, this);\n      if (map.options.zoomAnimation && L.Browser.any3d) {\n        map.on('zoomanim', this._animateZoom, this);\n      }\n      this._reset();\n    },\n    onRemove: function onRemove(map) {\n      map.getPanes().overlayPane.removeChild(this._image);\n      map.off('viewreset', this._reset, this);\n      if (map.options.zoomAnimation) {\n        map.off('zoomanim', this._animateZoom, this);\n      }\n    },\n    addTo: function addTo(map) {\n      map.addLayer(this);\n      return this;\n    },\n    setOpacity: function setOpacity(opacity) {\n      this.options.opacity = opacity;\n      this._updateOpacity();\n      return this;\n    },\n    // TODO remove bringToFront/bringToBack duplication from TileLayer/Path\n    bringToFront: function bringToFront() {\n      if (this._image) {\n        this._map._panes.overlayPane.appendChild(this._image);\n      }\n      return this;\n    },\n    bringToBack: function bringToBack() {\n      var pane = this._map._panes.overlayPane;\n      if (this._image) {\n        pane.insertBefore(this._image, pane.firstChild);\n      }\n      return this;\n    },\n    setUrl: function setUrl(url) {\n      this._url = url;\n      this._image.src = this._url;\n    },\n    getAttribution: function getAttribution() {\n      return this.options.attribution;\n    },\n    _initImage: function _initImage() {\n      this._image = L.DomUtil.create('img', 'leaflet-image-layer');\n      if (this._map.options.zoomAnimation && L.Browser.any3d) {\n        L.DomUtil.addClass(this._image, 'leaflet-zoom-animated');\n      } else {\n        L.DomUtil.addClass(this._image, 'leaflet-zoom-hide');\n      }\n      this._updateOpacity();\n\n      //TODO createImage util method to remove duplication\n      L.extend(this._image, {\n        galleryimg: 'no',\n        onselectstart: L.Util.falseFn,\n        onmousemove: L.Util.falseFn,\n        onload: L.bind(this._onImageLoad, this),\n        src: this._url\n      });\n    },\n    _animateZoom: function _animateZoom(e) {\n      var map = this._map,\n        image = this._image,\n        scale = map.getZoomScale(e.zoom),\n        nw = this._bounds.getNorthWest(),\n        se = this._bounds.getSouthEast(),\n        topLeft = map._latLngToNewLayerPoint(nw, e.zoom, e.center),\n        size = map._latLngToNewLayerPoint(se, e.zoom, e.center)._subtract(topLeft),\n        origin = topLeft._add(size._multiplyBy(1 / 2 * (1 - 1 / scale)));\n      image.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(origin) + ' scale(' + scale + ') ';\n    },\n    _reset: function _reset() {\n      var image = this._image,\n        topLeft = this._map.latLngToLayerPoint(this._bounds.getNorthWest()),\n        size = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(topLeft);\n      L.DomUtil.setPosition(image, topLeft);\n      image.style.width = size.x + 'px';\n      image.style.height = size.y + 'px';\n    },\n    _onImageLoad: function _onImageLoad() {\n      this.fire('load');\n    },\n    _updateOpacity: function _updateOpacity() {\n      L.DomUtil.setOpacity(this._image, this.options.opacity);\n    }\n  });\n  L.imageOverlay = function (url, bounds, options) {\n    return new L.ImageOverlay(url, bounds, options);\n  };\n\n  /*\n  * L.Icon is an image-based icon class that you can use with L.Marker for custom markers.\n  */\n\n  L.Icon = L.Class.extend({\n    options: {\n      /*\n      iconUrl: (String) (required)\n      iconRetinaUrl: (String) (optional, used for retina devices if detected)\n      iconSize: (Point) (can be set through CSS)\n      iconAnchor: (Point) (centered by default, can be set in CSS with negative margins)\n      popupAnchor: (Point) (if not specified, popup opens in the anchor point)\n      shadowUrl: (String) (no shadow by default)\n      shadowRetinaUrl: (String) (optional, used for retina devices if detected)\n      shadowSize: (Point)\n      shadowAnchor: (Point)\n      */\n      className: ''\n    },\n    initialize: function initialize(options) {\n      L.setOptions(this, options);\n    },\n    createIcon: function createIcon(oldIcon) {\n      return this._createIcon('icon', oldIcon);\n    },\n    createShadow: function createShadow(oldIcon) {\n      return this._createIcon('shadow', oldIcon);\n    },\n    _createIcon: function _createIcon(name, oldIcon) {\n      var src = this._getIconUrl(name);\n      if (!src) {\n        if (name === 'icon') {\n          throw new Error('iconUrl not set in Icon options (see the docs).');\n        }\n        return null;\n      }\n      var img;\n      if (!oldIcon || oldIcon.tagName !== 'IMG') {\n        img = this._createImg(src);\n      } else {\n        img = this._createImg(src, oldIcon);\n      }\n      this._setIconStyles(img, name);\n      return img;\n    },\n    _setIconStyles: function _setIconStyles(img, name) {\n      var options = this.options,\n        size = L.point(options[name + 'Size']),\n        anchor;\n      if (name === 'shadow') {\n        anchor = L.point(options.shadowAnchor || options.iconAnchor);\n      } else {\n        anchor = L.point(options.iconAnchor);\n      }\n      if (!anchor && size) {\n        anchor = size.divideBy(2, true);\n      }\n      img.className = 'leaflet-marker-' + name + ' ' + options.className;\n      if (anchor) {\n        img.style.marginLeft = -anchor.x + 'px';\n        img.style.marginTop = -anchor.y + 'px';\n      }\n      if (size) {\n        img.style.width = size.x + 'px';\n        img.style.height = size.y + 'px';\n      }\n    },\n    _createImg: function _createImg(src, el) {\n      el = el || document.createElement('img');\n      el.src = src;\n      return el;\n    },\n    _getIconUrl: function _getIconUrl(name) {\n      if (L.Browser.retina && this.options[name + 'RetinaUrl']) {\n        return this.options[name + 'RetinaUrl'];\n      }\n      return this.options[name + 'Url'];\n    }\n  });\n  L.icon = function (options) {\n    return new L.Icon(options);\n  };\n\n  /*\n  * L.Icon.Default is the blue marker icon used by default in Leaflet.\n  */\n\n  L.Icon.Default = L.Icon.extend({\n    options: {\n      iconSize: [25, 41],\n      iconAnchor: [12, 41],\n      popupAnchor: [1, -34],\n      shadowSize: [41, 41]\n    },\n    _getIconUrl: function _getIconUrl(name) {\n      var key = name + 'Url';\n      if (this.options[key]) {\n        return this.options[key];\n      }\n      if (L.Browser.retina && name === 'icon') {\n        name += '-2x';\n      }\n\n      // HUE Specific change for static files\n      return window.LEAFLET_DEFAULTS.images[name];\n    }\n  });\n  L.Icon.Default.imagePath = function () {\n    var scripts = document.getElementsByTagName('script'),\n      leafletRe = /[\\/^]leaflet[\\-\\._]?([\\w\\-\\._]*)\\.js\\??/;\n    var i, len, src, matches, path;\n    for (i = 0, len = scripts.length; i < len; i++) {\n      src = scripts[i].src;\n      matches = src.match(leafletRe);\n      if (matches) {\n        path = src.split(leafletRe)[0];\n        return (path ? path + '/' : '') + 'images';\n      }\n    }\n  }();\n\n  /*\n  * L.Marker is used to display clickable/draggable icons on the map.\n  */\n\n  L.Marker = L.Class.extend({\n    includes: L.Mixin.Events,\n    options: {\n      icon: new L.Icon.Default(),\n      title: '',\n      alt: '',\n      clickable: true,\n      draggable: false,\n      keyboard: true,\n      zIndexOffset: 0,\n      opacity: 1,\n      riseOnHover: false,\n      riseOffset: 250\n    },\n    initialize: function initialize(latlng, options) {\n      L.setOptions(this, options);\n      this._latlng = L.latLng(latlng);\n    },\n    onAdd: function onAdd(map) {\n      this._map = map;\n      map.on('viewreset', this.update, this);\n      this._initIcon();\n      this.update();\n      this.fire('add');\n      if (map.options.zoomAnimation && map.options.markerZoomAnimation) {\n        map.on('zoomanim', this._animateZoom, this);\n      }\n    },\n    addTo: function addTo(map) {\n      map.addLayer(this);\n      return this;\n    },\n    onRemove: function onRemove(map) {\n      if (this.dragging) {\n        this.dragging.disable();\n      }\n      this._removeIcon();\n      this._removeShadow();\n      this.fire('remove');\n      map.off({\n        'viewreset': this.update,\n        'zoomanim': this._animateZoom\n      }, this);\n      this._map = null;\n    },\n    getLatLng: function getLatLng() {\n      return this._latlng;\n    },\n    setLatLng: function setLatLng(latlng) {\n      this._latlng = L.latLng(latlng);\n      this.update();\n      return this.fire('move', {\n        latlng: this._latlng\n      });\n    },\n    setZIndexOffset: function setZIndexOffset(offset) {\n      this.options.zIndexOffset = offset;\n      this.update();\n      return this;\n    },\n    setIcon: function setIcon(icon) {\n      this.options.icon = icon;\n      if (this._map) {\n        this._initIcon();\n        this.update();\n      }\n      if (this._popup) {\n        this.bindPopup(this._popup);\n      }\n      return this;\n    },\n    update: function update() {\n      if (this._icon) {\n        this._setPos(this._map.latLngToLayerPoint(this._latlng).round());\n      }\n      return this;\n    },\n    _initIcon: function _initIcon() {\n      var options = this.options,\n        map = this._map,\n        animation = map.options.zoomAnimation && map.options.markerZoomAnimation,\n        classToAdd = animation ? 'leaflet-zoom-animated' : 'leaflet-zoom-hide';\n      var icon = options.icon.createIcon(this._icon),\n        addIcon = false;\n\n      // if we're not reusing the icon, remove the old one and init new one\n      if (icon !== this._icon) {\n        if (this._icon) {\n          this._removeIcon();\n        }\n        addIcon = true;\n        if (options.title) {\n          icon.title = options.title;\n        }\n        if (options.alt) {\n          icon.alt = options.alt;\n        }\n      }\n      L.DomUtil.addClass(icon, classToAdd);\n      if (options.keyboard) {\n        icon.tabIndex = '0';\n      }\n      this._icon = icon;\n      this._initInteraction();\n      if (options.riseOnHover) {\n        L.DomEvent.on(icon, 'mouseover', this._bringToFront, this).on(icon, 'mouseout', this._resetZIndex, this);\n      }\n      var newShadow = options.icon.createShadow(this._shadow),\n        addShadow = false;\n      if (newShadow !== this._shadow) {\n        this._removeShadow();\n        addShadow = true;\n      }\n      if (newShadow) {\n        L.DomUtil.addClass(newShadow, classToAdd);\n      }\n      this._shadow = newShadow;\n      if (options.opacity < 1) {\n        this._updateOpacity();\n      }\n      var panes = this._map._panes;\n      if (addIcon) {\n        panes.markerPane.appendChild(this._icon);\n      }\n      if (newShadow && addShadow) {\n        panes.shadowPane.appendChild(this._shadow);\n      }\n    },\n    _removeIcon: function _removeIcon() {\n      if (this.options.riseOnHover) {\n        L.DomEvent.off(this._icon, 'mouseover', this._bringToFront).off(this._icon, 'mouseout', this._resetZIndex);\n      }\n      this._map._panes.markerPane.removeChild(this._icon);\n      this._icon = null;\n    },\n    _removeShadow: function _removeShadow() {\n      if (this._shadow) {\n        this._map._panes.shadowPane.removeChild(this._shadow);\n      }\n      this._shadow = null;\n    },\n    _setPos: function _setPos(pos) {\n      L.DomUtil.setPosition(this._icon, pos);\n      if (this._shadow) {\n        L.DomUtil.setPosition(this._shadow, pos);\n      }\n      this._zIndex = pos.y + this.options.zIndexOffset;\n      this._resetZIndex();\n    },\n    _updateZIndex: function _updateZIndex(offset) {\n      this._icon.style.zIndex = this._zIndex + offset;\n    },\n    _animateZoom: function _animateZoom(opt) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\n      this._setPos(pos);\n    },\n    _initInteraction: function _initInteraction() {\n      if (!this.options.clickable) {\n        return;\n      }\n\n      // TODO refactor into something shared with Map/Path/etc. to DRY it up\n\n      var icon = this._icon,\n        events = ['dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu'];\n      L.DomUtil.addClass(icon, 'leaflet-clickable');\n      L.DomEvent.on(icon, 'click', this._onMouseClick, this);\n      L.DomEvent.on(icon, 'keypress', this._onKeyPress, this);\n      for (var i = 0; i < events.length; i++) {\n        L.DomEvent.on(icon, events[i], this._fireMouseEvent, this);\n      }\n      if (L.Handler.MarkerDrag) {\n        this.dragging = new L.Handler.MarkerDrag(this);\n        if (this.options.draggable) {\n          this.dragging.enable();\n        }\n      }\n    },\n    _onMouseClick: function _onMouseClick(e) {\n      var wasDragged = this.dragging && this.dragging.moved();\n      if (this.hasEventListeners(e.type) || wasDragged) {\n        L.DomEvent.stopPropagation(e);\n      }\n      if (wasDragged) {\n        return;\n      }\n      if ((!this.dragging || !this.dragging._enabled) && this._map.dragging && this._map.dragging.moved()) {\n        return;\n      }\n      this.fire(e.type, {\n        originalEvent: e,\n        latlng: this._latlng\n      });\n    },\n    _onKeyPress: function _onKeyPress(e) {\n      if (e.keyCode === 13) {\n        this.fire('click', {\n          originalEvent: e,\n          latlng: this._latlng\n        });\n      }\n    },\n    _fireMouseEvent: function _fireMouseEvent(e) {\n      this.fire(e.type, {\n        originalEvent: e,\n        latlng: this._latlng\n      });\n\n      // TODO proper custom event propagation\n      // this line will always be called if marker is in a FeatureGroup\n      if (e.type === 'contextmenu' && this.hasEventListeners(e.type)) {\n        L.DomEvent.preventDefault(e);\n      }\n      if (e.type !== 'mousedown') {\n        L.DomEvent.stopPropagation(e);\n      } else {\n        L.DomEvent.preventDefault(e);\n      }\n    },\n    setOpacity: function setOpacity(opacity) {\n      this.options.opacity = opacity;\n      if (this._map) {\n        this._updateOpacity();\n      }\n      return this;\n    },\n    _updateOpacity: function _updateOpacity() {\n      L.DomUtil.setOpacity(this._icon, this.options.opacity);\n      if (this._shadow) {\n        L.DomUtil.setOpacity(this._shadow, this.options.opacity);\n      }\n    },\n    _bringToFront: function _bringToFront() {\n      this._updateZIndex(this.options.riseOffset);\n    },\n    _resetZIndex: function _resetZIndex() {\n      this._updateZIndex(0);\n    }\n  });\n  L.marker = function (latlng, options) {\n    return new L.Marker(latlng, options);\n  };\n\n  /*\n  * L.DivIcon is a lightweight HTML-based icon class (as opposed to the image-based L.Icon)\n  * to use with L.Marker.\n  */\n\n  L.DivIcon = L.Icon.extend({\n    options: {\n      iconSize: [12, 12],\n      // also can be set through CSS\n      /*\n      iconAnchor: (Point)\n      popupAnchor: (Point)\n      html: (String)\n      bgPos: (Point)\n      */\n      className: 'leaflet-div-icon',\n      html: false\n    },\n    createIcon: function createIcon(oldIcon) {\n      var div = oldIcon && oldIcon.tagName === 'DIV' ? oldIcon : document.createElement('div'),\n        options = this.options;\n      if (options.html !== false) {\n        div.innerHTML = options.html;\n      } else {\n        div.innerHTML = '';\n      }\n      if (options.bgPos) {\n        div.style.backgroundPosition = -options.bgPos.x + 'px ' + -options.bgPos.y + 'px';\n      }\n      this._setIconStyles(div, 'icon');\n      return div;\n    },\n    createShadow: function createShadow() {\n      return null;\n    }\n  });\n  L.divIcon = function (options) {\n    return new L.DivIcon(options);\n  };\n\n  /*\n  * L.Popup is used for displaying popups on the map.\n  */\n\n  L.Map.mergeOptions({\n    closePopupOnClick: true\n  });\n  L.Popup = L.Class.extend({\n    includes: L.Mixin.Events,\n    options: {\n      minWidth: 50,\n      maxWidth: 300,\n      // maxHeight: null,\n      autoPan: true,\n      closeButton: true,\n      offset: [0, 7],\n      autoPanPadding: [5, 5],\n      // autoPanPaddingTopLeft: null,\n      // autoPanPaddingBottomRight: null,\n      keepInView: false,\n      className: '',\n      zoomAnimation: true\n    },\n    initialize: function initialize(options, source) {\n      L.setOptions(this, options);\n      this._source = source;\n      this._animated = L.Browser.any3d && this.options.zoomAnimation;\n      this._isOpen = false;\n    },\n    onAdd: function onAdd(map) {\n      this._map = map;\n      if (!this._container) {\n        this._initLayout();\n      }\n      var animFade = map.options.fadeAnimation;\n      if (animFade) {\n        L.DomUtil.setOpacity(this._container, 0);\n      }\n      map._panes.popupPane.appendChild(this._container);\n      map.on(this._getEvents(), this);\n      this.update();\n      if (animFade) {\n        L.DomUtil.setOpacity(this._container, 1);\n      }\n      this.fire('open');\n      map.fire('popupopen', {\n        popup: this\n      });\n      if (this._source) {\n        this._source.fire('popupopen', {\n          popup: this\n        });\n      }\n    },\n    addTo: function addTo(map) {\n      map.addLayer(this);\n      return this;\n    },\n    openOn: function openOn(map) {\n      map.openPopup(this);\n      return this;\n    },\n    onRemove: function onRemove(map) {\n      map._panes.popupPane.removeChild(this._container);\n      L.Util.falseFn(this._container.offsetWidth); // force reflow\n\n      map.off(this._getEvents(), this);\n      if (map.options.fadeAnimation) {\n        L.DomUtil.setOpacity(this._container, 0);\n      }\n      this._map = null;\n      this.fire('close');\n      map.fire('popupclose', {\n        popup: this\n      });\n      if (this._source) {\n        this._source.fire('popupclose', {\n          popup: this\n        });\n      }\n    },\n    getLatLng: function getLatLng() {\n      return this._latlng;\n    },\n    setLatLng: function setLatLng(latlng) {\n      this._latlng = L.latLng(latlng);\n      if (this._map) {\n        this._updatePosition();\n        this._adjustPan();\n      }\n      return this;\n    },\n    getContent: function getContent() {\n      return this._content;\n    },\n    setContent: function setContent(content) {\n      this._content = content;\n      this.update();\n      return this;\n    },\n    update: function update() {\n      if (!this._map) {\n        return;\n      }\n      this._container.style.visibility = 'hidden';\n      this._updateContent();\n      this._updateLayout();\n      this._updatePosition();\n      this._container.style.visibility = '';\n      this._adjustPan();\n    },\n    _getEvents: function _getEvents() {\n      var events = {\n        viewreset: this._updatePosition\n      };\n      if (this._animated) {\n        events.zoomanim = this._zoomAnimation;\n      }\n      if ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\n        events.preclick = this._close;\n      }\n      if (this.options.keepInView) {\n        events.moveend = this._adjustPan;\n      }\n      return events;\n    },\n    _close: function _close() {\n      if (this._map) {\n        this._map.closePopup(this);\n      }\n    },\n    _initLayout: function _initLayout() {\n      var prefix = 'leaflet-popup',\n        containerClass = prefix + ' ' + this.options.className + ' leaflet-zoom-' + (this._animated ? 'animated' : 'hide'),\n        container = this._container = L.DomUtil.create('div', containerClass),\n        closeButton;\n      if (this.options.closeButton) {\n        closeButton = this._closeButton = L.DomUtil.create('a', prefix + '-close-button', container);\n        closeButton.href = '#close';\n        closeButton.innerHTML = '&#215;';\n        L.DomEvent.disableClickPropagation(closeButton);\n        L.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);\n      }\n      var wrapper = this._wrapper = L.DomUtil.create('div', prefix + '-content-wrapper', container);\n      L.DomEvent.disableClickPropagation(wrapper);\n      this._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);\n      L.DomEvent.disableScrollPropagation(this._contentNode);\n      L.DomEvent.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);\n      this._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);\n      this._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);\n    },\n    _updateContent: function _updateContent() {\n      if (!this._content) {\n        return;\n      }\n      if (typeof this._content === 'string') {\n        this._contentNode.innerHTML = this._content;\n      } else {\n        while (this._contentNode.hasChildNodes()) {\n          this._contentNode.removeChild(this._contentNode.firstChild);\n        }\n        this._contentNode.appendChild(this._content);\n      }\n      this.fire('contentupdate');\n    },\n    _updateLayout: function _updateLayout() {\n      var container = this._contentNode,\n        style = container.style;\n      style.width = '';\n      style.whiteSpace = 'nowrap';\n      var width = container.offsetWidth;\n      width = Math.min(width, this.options.maxWidth);\n      width = Math.max(width, this.options.minWidth);\n      style.width = width + 1 + 'px';\n      style.whiteSpace = '';\n      style.height = '';\n      var height = container.offsetHeight,\n        maxHeight = this.options.maxHeight,\n        scrolledClass = 'leaflet-popup-scrolled';\n      if (maxHeight && height > maxHeight) {\n        style.height = maxHeight + 'px';\n        L.DomUtil.addClass(container, scrolledClass);\n      } else {\n        L.DomUtil.removeClass(container, scrolledClass);\n      }\n      this._containerWidth = this._container.offsetWidth;\n    },\n    _updatePosition: function _updatePosition() {\n      if (!this._map) {\n        return;\n      }\n      var pos = this._map.latLngToLayerPoint(this._latlng),\n        animated = this._animated,\n        offset = L.point(this.options.offset);\n      if (animated) {\n        L.DomUtil.setPosition(this._container, pos);\n      }\n      this._containerBottom = -offset.y - (animated ? 0 : pos.y);\n      this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x + (animated ? 0 : pos.x);\n\n      // bottom position the popup in case the height of the popup changes (images loading etc)\n      this._container.style.bottom = this._containerBottom + 'px';\n      this._container.style.left = this._containerLeft + 'px';\n    },\n    _zoomAnimation: function _zoomAnimation(opt) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center);\n      L.DomUtil.setPosition(this._container, pos);\n    },\n    _adjustPan: function _adjustPan() {\n      if (!this.options.autoPan) {\n        return;\n      }\n      var map = this._map,\n        containerHeight = this._container.offsetHeight,\n        containerWidth = this._containerWidth,\n        layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);\n      if (this._animated) {\n        layerPos._add(L.DomUtil.getPosition(this._container));\n      }\n      var containerPos = map.layerPointToContainerPoint(layerPos),\n        padding = L.point(this.options.autoPanPadding),\n        paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),\n        paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),\n        size = map.getSize(),\n        dx = 0,\n        dy = 0;\n      if (containerPos.x + containerWidth + paddingBR.x > size.x) {\n        // right\n        dx = containerPos.x + containerWidth - size.x + paddingBR.x;\n      }\n      if (containerPos.x - dx - paddingTL.x < 0) {\n        // left\n        dx = containerPos.x - paddingTL.x;\n      }\n      if (containerPos.y + containerHeight + paddingBR.y > size.y) {\n        // bottom\n        dy = containerPos.y + containerHeight - size.y + paddingBR.y;\n      }\n      if (containerPos.y - dy - paddingTL.y < 0) {\n        // top\n        dy = containerPos.y - paddingTL.y;\n      }\n      if (dx || dy) {\n        map.fire('autopanstart').panBy([dx, dy]);\n      }\n    },\n    _onCloseButtonClick: function _onCloseButtonClick(e) {\n      this._close();\n      L.DomEvent.stop(e);\n    }\n  });\n  L.popup = function (options, source) {\n    return new L.Popup(options, source);\n  };\n  L.Map.include({\n    openPopup: function openPopup(popup, latlng, options) {\n      // (Popup) or (String || HTMLElement, LatLng[, Object])\n      this.closePopup();\n      if (!(popup instanceof L.Popup)) {\n        var content = popup;\n        popup = new L.Popup(options).setLatLng(latlng).setContent(content);\n      }\n      popup._isOpen = true;\n      this._popup = popup;\n      return this.addLayer(popup);\n    },\n    closePopup: function closePopup(popup) {\n      if (!popup || popup === this._popup) {\n        popup = this._popup;\n        this._popup = null;\n      }\n      if (popup) {\n        this.removeLayer(popup);\n        popup._isOpen = false;\n      }\n      return this;\n    }\n  });\n\n  /*\n  * Popup extension to L.Marker, adding popup-related methods.\n  */\n\n  L.Marker.include({\n    openPopup: function openPopup() {\n      if (this._popup && this._map && !this._map.hasLayer(this._popup)) {\n        this._popup.setLatLng(this._latlng);\n        this._map.openPopup(this._popup);\n      }\n      return this;\n    },\n    closePopup: function closePopup() {\n      if (this._popup) {\n        this._popup._close();\n      }\n      return this;\n    },\n    togglePopup: function togglePopup() {\n      if (this._popup) {\n        if (this._popup._isOpen) {\n          this.closePopup();\n        } else {\n          this.openPopup();\n        }\n      }\n      return this;\n    },\n    bindPopup: function bindPopup(content, options) {\n      var anchor = L.point(this.options.icon.options.popupAnchor || [0, 0]);\n      anchor = anchor.add(L.Popup.prototype.options.offset);\n      if (options && options.offset) {\n        anchor = anchor.add(options.offset);\n      }\n      options = L.extend({\n        offset: anchor\n      }, options);\n      if (!this._popupHandlersAdded) {\n        this.on('click', this.togglePopup, this).on('remove', this.closePopup, this).on('move', this._movePopup, this);\n        this._popupHandlersAdded = true;\n      }\n      if (content instanceof L.Popup) {\n        L.setOptions(content, options);\n        this._popup = content;\n        content._source = this;\n      } else {\n        this._popup = new L.Popup(options, this).setContent(content);\n      }\n      return this;\n    },\n    setPopupContent: function setPopupContent(content) {\n      if (this._popup) {\n        this._popup.setContent(content);\n      }\n      return this;\n    },\n    unbindPopup: function unbindPopup() {\n      if (this._popup) {\n        this._popup = null;\n        this.off('click', this.togglePopup, this).off('remove', this.closePopup, this).off('move', this._movePopup, this);\n        this._popupHandlersAdded = false;\n      }\n      return this;\n    },\n    getPopup: function getPopup() {\n      return this._popup;\n    },\n    _movePopup: function _movePopup(e) {\n      this._popup.setLatLng(e.latlng);\n    }\n  });\n\n  /*\n  * L.LayerGroup is a class to combine several layers into one so that\n  * you can manipulate the group (e.g. add/remove it) as one layer.\n  */\n\n  L.LayerGroup = L.Class.extend({\n    initialize: function initialize(layers) {\n      this._layers = {};\n      var i, len;\n      if (layers) {\n        for (i = 0, len = layers.length; i < len; i++) {\n          this.addLayer(layers[i]);\n        }\n      }\n    },\n    addLayer: function addLayer(layer) {\n      var id = this.getLayerId(layer);\n      this._layers[id] = layer;\n      if (this._map) {\n        this._map.addLayer(layer);\n      }\n      return this;\n    },\n    removeLayer: function removeLayer(layer) {\n      var id = layer in this._layers ? layer : this.getLayerId(layer);\n      if (this._map && this._layers[id]) {\n        this._map.removeLayer(this._layers[id]);\n      }\n      delete this._layers[id];\n      return this;\n    },\n    hasLayer: function hasLayer(layer) {\n      if (!layer) {\n        return false;\n      }\n      return layer in this._layers || this.getLayerId(layer) in this._layers;\n    },\n    clearLayers: function clearLayers() {\n      this.eachLayer(this.removeLayer, this);\n      return this;\n    },\n    invoke: function invoke(methodName) {\n      var args = Array.prototype.slice.call(arguments, 1),\n        i,\n        layer;\n      for (i in this._layers) {\n        layer = this._layers[i];\n        if (layer[methodName]) {\n          layer[methodName].apply(layer, args);\n        }\n      }\n      return this;\n    },\n    onAdd: function onAdd(map) {\n      this._map = map;\n      this.eachLayer(map.addLayer, map);\n    },\n    onRemove: function onRemove(map) {\n      this.eachLayer(map.removeLayer, map);\n      this._map = null;\n    },\n    addTo: function addTo(map) {\n      map.addLayer(this);\n      return this;\n    },\n    eachLayer: function eachLayer(method, context) {\n      for (var i in this._layers) {\n        method.call(context, this._layers[i]);\n      }\n      return this;\n    },\n    getLayer: function getLayer(id) {\n      return this._layers[id];\n    },\n    getLayers: function getLayers() {\n      var layers = [];\n      for (var i in this._layers) {\n        layers.push(this._layers[i]);\n      }\n      return layers;\n    },\n    setZIndex: function setZIndex(zIndex) {\n      return this.invoke('setZIndex', zIndex);\n    },\n    getLayerId: function getLayerId(layer) {\n      return L.stamp(layer);\n    }\n  });\n  L.layerGroup = function (layers) {\n    return new L.LayerGroup(layers);\n  };\n\n  /*\n  * L.FeatureGroup extends L.LayerGroup by introducing mouse events and additional methods\n  * shared between a group of interactive layers (like vectors or markers).\n  */\n\n  L.FeatureGroup = L.LayerGroup.extend({\n    includes: L.Mixin.Events,\n    statics: {\n      EVENTS: 'click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose'\n    },\n    addLayer: function addLayer(layer) {\n      if (this.hasLayer(layer)) {\n        return this;\n      }\n      if ('on' in layer) {\n        layer.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);\n      }\n      L.LayerGroup.prototype.addLayer.call(this, layer);\n      if (this._popupContent && layer.bindPopup) {\n        layer.bindPopup(this._popupContent, this._popupOptions);\n      }\n      return this.fire('layeradd', {\n        layer: layer\n      });\n    },\n    removeLayer: function removeLayer(layer) {\n      if (!this.hasLayer(layer)) {\n        return this;\n      }\n      if (layer in this._layers) {\n        layer = this._layers[layer];\n      }\n      if ('off' in layer) {\n        layer.off(L.FeatureGroup.EVENTS, this._propagateEvent, this);\n      }\n      L.LayerGroup.prototype.removeLayer.call(this, layer);\n      if (this._popupContent) {\n        this.invoke('unbindPopup');\n      }\n      return this.fire('layerremove', {\n        layer: layer\n      });\n    },\n    bindPopup: function bindPopup(content, options) {\n      this._popupContent = content;\n      this._popupOptions = options;\n      return this.invoke('bindPopup', content, options);\n    },\n    openPopup: function openPopup(latlng) {\n      // open popup on the first layer\n      for (var id in this._layers) {\n        this._layers[id].openPopup(latlng);\n        break;\n      }\n      return this;\n    },\n    setStyle: function setStyle(style) {\n      return this.invoke('setStyle', style);\n    },\n    bringToFront: function bringToFront() {\n      return this.invoke('bringToFront');\n    },\n    bringToBack: function bringToBack() {\n      return this.invoke('bringToBack');\n    },\n    getBounds: function getBounds() {\n      var bounds = new L.LatLngBounds();\n      this.eachLayer(function (layer) {\n        bounds.extend(layer instanceof L.Marker ? layer.getLatLng() : layer.getBounds());\n      });\n      return bounds;\n    },\n    _propagateEvent: function _propagateEvent(e) {\n      e = L.extend({\n        layer: e.target,\n        target: this\n      }, e);\n      this.fire(e.type, e);\n    }\n  });\n  L.featureGroup = function (layers) {\n    return new L.FeatureGroup(layers);\n  };\n\n  /*\n  * L.Path is a base class for rendering vector paths on a map. Inherited by Polyline, Circle, etc.\n  */\n\n  L.Path = L.Class.extend({\n    includes: [L.Mixin.Events],\n    statics: {\n      // how much to extend the clip area around the map view\n      // (relative to its size, e.g. 0.5 is half the screen in each direction)\n      // set it so that SVG element doesn't exceed 1280px (vectors flicker on dragend if it is)\n      CLIP_PADDING: function () {\n        var max = L.Browser.mobile ? 1280 : 2000,\n          target = (max / Math.max(window.outerWidth, window.outerHeight) - 1) / 2;\n        return Math.max(0, Math.min(0.5, target));\n      }()\n    },\n    options: {\n      stroke: true,\n      color: '#0033ff',\n      dashArray: null,\n      lineCap: null,\n      lineJoin: null,\n      weight: 5,\n      opacity: 0.5,\n      fill: false,\n      fillColor: null,\n      //same as color by default\n      fillOpacity: 0.2,\n      clickable: true\n    },\n    initialize: function initialize(options) {\n      L.setOptions(this, options);\n    },\n    onAdd: function onAdd(map) {\n      this._map = map;\n      if (!this._container) {\n        this._initElements();\n        this._initEvents();\n      }\n      this.projectLatlngs();\n      this._updatePath();\n      if (this._container) {\n        this._map._pathRoot.appendChild(this._container);\n      }\n      this.fire('add');\n      map.on({\n        'viewreset': this.projectLatlngs,\n        'moveend': this._updatePath\n      }, this);\n    },\n    addTo: function addTo(map) {\n      map.addLayer(this);\n      return this;\n    },\n    onRemove: function onRemove(map) {\n      map._pathRoot.removeChild(this._container);\n\n      // Need to fire remove event before we set _map to null as the event hooks might need the object\n      this.fire('remove');\n      this._map = null;\n      if (L.Browser.vml) {\n        this._container = null;\n        this._stroke = null;\n        this._fill = null;\n      }\n      map.off({\n        'viewreset': this.projectLatlngs,\n        'moveend': this._updatePath\n      }, this);\n    },\n    projectLatlngs: function projectLatlngs() {\n      // do all projection stuff here\n    },\n    setStyle: function setStyle(style) {\n      L.setOptions(this, style);\n      if (this._container) {\n        this._updateStyle();\n      }\n      return this;\n    },\n    redraw: function redraw() {\n      if (this._map) {\n        this.projectLatlngs();\n        this._updatePath();\n      }\n      return this;\n    }\n  });\n  L.Map.include({\n    _updatePathViewport: function _updatePathViewport() {\n      var p = L.Path.CLIP_PADDING,\n        size = this.getSize(),\n        panePos = L.DomUtil.getPosition(this._mapPane),\n        min = panePos.multiplyBy(-1)._subtract(size.multiplyBy(p)._round()),\n        max = min.add(size.multiplyBy(1 + p * 2)._round());\n      this._pathViewport = new L.Bounds(min, max);\n    }\n  });\n\n  /*\n  * Extends L.Path with SVG-specific rendering code.\n  */\n\n  L.Path.SVG_NS = 'http://www.w3.org/2000/svg';\n  L.Browser.svg = !!(document.createElementNS && document.createElementNS(L.Path.SVG_NS, 'svg').createSVGRect);\n  L.Path = L.Path.extend({\n    statics: {\n      SVG: L.Browser.svg\n    },\n    bringToFront: function bringToFront() {\n      var root = this._map._pathRoot,\n        path = this._container;\n      if (path && root.lastChild !== path) {\n        root.appendChild(path);\n      }\n      return this;\n    },\n    bringToBack: function bringToBack() {\n      var root = this._map._pathRoot,\n        path = this._container,\n        first = root.firstChild;\n      if (path && first !== path) {\n        root.insertBefore(path, first);\n      }\n      return this;\n    },\n    getPathString: function getPathString() {\n      // form path string here\n    },\n    _createElement: function _createElement(name) {\n      return document.createElementNS(L.Path.SVG_NS, name);\n    },\n    _initElements: function _initElements() {\n      this._map._initPathRoot();\n      this._initPath();\n      this._initStyle();\n    },\n    _initPath: function _initPath() {\n      this._container = this._createElement('g');\n      this._path = this._createElement('path');\n      if (this.options.className) {\n        L.DomUtil.addClass(this._path, this.options.className);\n      }\n      this._container.appendChild(this._path);\n    },\n    _initStyle: function _initStyle() {\n      if (this.options.stroke) {\n        this._path.setAttribute('stroke-linejoin', 'round');\n        this._path.setAttribute('stroke-linecap', 'round');\n      }\n      if (this.options.fill) {\n        this._path.setAttribute('fill-rule', 'evenodd');\n      }\n      if (this.options.pointerEvents) {\n        this._path.setAttribute('pointer-events', this.options.pointerEvents);\n      }\n      if (!this.options.clickable && !this.options.pointerEvents) {\n        this._path.setAttribute('pointer-events', 'none');\n      }\n      this._updateStyle();\n    },\n    _updateStyle: function _updateStyle() {\n      if (this.options.stroke) {\n        this._path.setAttribute('stroke', this.options.color);\n        this._path.setAttribute('stroke-opacity', this.options.opacity);\n        this._path.setAttribute('stroke-width', this.options.weight);\n        if (this.options.dashArray) {\n          this._path.setAttribute('stroke-dasharray', this.options.dashArray);\n        } else {\n          this._path.removeAttribute('stroke-dasharray');\n        }\n        if (this.options.lineCap) {\n          this._path.setAttribute('stroke-linecap', this.options.lineCap);\n        }\n        if (this.options.lineJoin) {\n          this._path.setAttribute('stroke-linejoin', this.options.lineJoin);\n        }\n      } else {\n        this._path.setAttribute('stroke', 'none');\n      }\n      if (this.options.fill) {\n        this._path.setAttribute('fill', this.options.fillColor || this.options.color);\n        this._path.setAttribute('fill-opacity', this.options.fillOpacity);\n      } else {\n        this._path.setAttribute('fill', 'none');\n      }\n    },\n    _updatePath: function _updatePath() {\n      var str = this.getPathString();\n      if (!str) {\n        // fix webkit empty string parsing bug\n        str = 'M0 0';\n      }\n      this._path.setAttribute('d', str);\n    },\n    // TODO remove duplication with L.Map\n    _initEvents: function _initEvents() {\n      if (this.options.clickable) {\n        if (L.Browser.svg || !L.Browser.vml) {\n          L.DomUtil.addClass(this._path, 'leaflet-clickable');\n        }\n        L.DomEvent.on(this._container, 'click', this._onMouseClick, this);\n        var events = ['dblclick', 'mousedown', 'mouseover', 'mouseout', 'mousemove', 'contextmenu'];\n        for (var i = 0; i < events.length; i++) {\n          L.DomEvent.on(this._container, events[i], this._fireMouseEvent, this);\n        }\n      }\n    },\n    _onMouseClick: function _onMouseClick(e) {\n      if (this._map.dragging && this._map.dragging.moved()) {\n        return;\n      }\n      this._fireMouseEvent(e);\n    },\n    _fireMouseEvent: function _fireMouseEvent(e) {\n      if (!this._map || !this.hasEventListeners(e.type)) {\n        return;\n      }\n      var map = this._map,\n        containerPoint = map.mouseEventToContainerPoint(e),\n        layerPoint = map.containerPointToLayerPoint(containerPoint),\n        latlng = map.layerPointToLatLng(layerPoint);\n      this.fire(e.type, {\n        latlng: latlng,\n        layerPoint: layerPoint,\n        containerPoint: containerPoint,\n        originalEvent: e\n      });\n      if (e.type === 'contextmenu') {\n        L.DomEvent.preventDefault(e);\n      }\n      if (e.type !== 'mousemove') {\n        L.DomEvent.stopPropagation(e);\n      }\n    }\n  });\n  L.Map.include({\n    _initPathRoot: function _initPathRoot() {\n      if (!this._pathRoot) {\n        this._pathRoot = L.Path.prototype._createElement('svg');\n        this._panes.overlayPane.appendChild(this._pathRoot);\n        if (this.options.zoomAnimation && L.Browser.any3d) {\n          L.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-animated');\n          this.on({\n            'zoomanim': this._animatePathZoom,\n            'zoomend': this._endPathZoom\n          });\n        } else {\n          L.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-hide');\n        }\n        this.on('moveend', this._updateSvgViewport);\n        this._updateSvgViewport();\n      }\n    },\n    _animatePathZoom: function _animatePathZoom(e) {\n      var scale = this.getZoomScale(e.zoom),\n        offset = this._getCenterOffset(e.center)._multiplyBy(-scale)._add(this._pathViewport.min);\n      this._pathRoot.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ') ';\n      this._pathZooming = true;\n    },\n    _endPathZoom: function _endPathZoom() {\n      this._pathZooming = false;\n    },\n    _updateSvgViewport: function _updateSvgViewport() {\n      if (this._pathZooming) {\n        // Do not update SVGs while a zoom animation is going on otherwise the animation will break.\n        // When the zoom animation ends we will be updated again anyway\n        // This fixes the case where you do a momentum move and zoom while the move is still ongoing.\n        return;\n      }\n      this._updatePathViewport();\n      var vp = this._pathViewport,\n        min = vp.min,\n        max = vp.max,\n        width = max.x - min.x,\n        height = max.y - min.y,\n        root = this._pathRoot,\n        pane = this._panes.overlayPane;\n\n      // Hack to make flicker on drag end on mobile webkit less irritating\n      if (L.Browser.mobileWebkit) {\n        pane.removeChild(root);\n      }\n      L.DomUtil.setPosition(root, min);\n      root.setAttribute('width', width);\n      root.setAttribute('height', height);\n      root.setAttribute('viewBox', [min.x, min.y, width, height].join(' '));\n      if (L.Browser.mobileWebkit) {\n        pane.appendChild(root);\n      }\n    }\n  });\n\n  /*\n  * Popup extension to L.Path (polylines, polygons, circles), adding popup-related methods.\n  */\n\n  L.Path.include({\n    bindPopup: function bindPopup(content, options) {\n      if (content instanceof L.Popup) {\n        this._popup = content;\n      } else {\n        if (!this._popup || options) {\n          this._popup = new L.Popup(options, this);\n        }\n        this._popup.setContent(content);\n      }\n      if (!this._popupHandlersAdded) {\n        this.on('click', this._openPopup, this).on('remove', this.closePopup, this);\n        this._popupHandlersAdded = true;\n      }\n      return this;\n    },\n    unbindPopup: function unbindPopup() {\n      if (this._popup) {\n        this._popup = null;\n        this.off('click', this._openPopup).off('remove', this.closePopup);\n        this._popupHandlersAdded = false;\n      }\n      return this;\n    },\n    openPopup: function openPopup(latlng) {\n      if (this._popup) {\n        // open the popup from one of the path's points if not specified\n        latlng = latlng || this._latlng || this._latlngs[Math.floor(this._latlngs.length / 2)];\n        this._openPopup({\n          latlng: latlng\n        });\n      }\n      return this;\n    },\n    closePopup: function closePopup() {\n      if (this._popup) {\n        this._popup._close();\n      }\n      return this;\n    },\n    _openPopup: function _openPopup(e) {\n      this._popup.setLatLng(e.latlng);\n      this._map.openPopup(this._popup);\n    }\n  });\n\n  /*\n  * Vector rendering for IE6-8 through VML.\n  * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\n  */\n\n  L.Browser.vml = !L.Browser.svg && function () {\n    try {\n      var div = document.createElement('div');\n      div.innerHTML = '<v:shape adj=\"1\"/>';\n      var shape = div.firstChild;\n      shape.style.behavior = 'url(#default#VML)';\n      return shape && _typeof(shape.adj) === 'object';\n    } catch (e) {\n      return false;\n    }\n  }();\n  L.Path = L.Browser.svg || !L.Browser.vml ? L.Path : L.Path.extend({\n    statics: {\n      VML: true,\n      CLIP_PADDING: 0.02\n    },\n    _createElement: function () {\n      try {\n        document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');\n        return function (name) {\n          return document.createElement('<lvml:' + name + ' class=\"lvml\">');\n        };\n      } catch (e) {\n        return function (name) {\n          return document.createElement('<' + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\n        };\n      }\n    }(),\n    _initPath: function _initPath() {\n      var container = this._container = this._createElement('shape');\n      L.DomUtil.addClass(container, 'leaflet-vml-shape' + (this.options.className ? ' ' + this.options.className : ''));\n      if (this.options.clickable) {\n        L.DomUtil.addClass(container, 'leaflet-clickable');\n      }\n      container.coordsize = '1 1';\n      this._path = this._createElement('path');\n      container.appendChild(this._path);\n      this._map._pathRoot.appendChild(container);\n    },\n    _initStyle: function _initStyle() {\n      this._updateStyle();\n    },\n    _updateStyle: function _updateStyle() {\n      var stroke = this._stroke,\n        fill = this._fill,\n        options = this.options,\n        container = this._container;\n      container.stroked = options.stroke;\n      container.filled = options.fill;\n      if (options.stroke) {\n        if (!stroke) {\n          stroke = this._stroke = this._createElement('stroke');\n          stroke.endcap = 'round';\n          container.appendChild(stroke);\n        }\n        stroke.weight = options.weight + 'px';\n        stroke.color = options.color;\n        stroke.opacity = options.opacity;\n        if (options.dashArray) {\n          stroke.dashStyle = L.Util.isArray(options.dashArray) ? options.dashArray.join(' ') : options.dashArray.replace(/( *, *)/g, ' ');\n        } else {\n          stroke.dashStyle = '';\n        }\n        if (options.lineCap) {\n          stroke.endcap = options.lineCap.replace('butt', 'flat');\n        }\n        if (options.lineJoin) {\n          stroke.joinstyle = options.lineJoin;\n        }\n      } else if (stroke) {\n        container.removeChild(stroke);\n        this._stroke = null;\n      }\n      if (options.fill) {\n        if (!fill) {\n          fill = this._fill = this._createElement('fill');\n          container.appendChild(fill);\n        }\n        fill.color = options.fillColor || options.color;\n        fill.opacity = options.fillOpacity;\n      } else if (fill) {\n        container.removeChild(fill);\n        this._fill = null;\n      }\n    },\n    _updatePath: function _updatePath() {\n      var style = this._container.style;\n      style.display = 'none';\n      this._path.v = this.getPathString() + ' '; // the space fixes IE empty path string bug\n      style.display = '';\n    }\n  });\n  L.Map.include(L.Browser.svg || !L.Browser.vml ? {} : {\n    _initPathRoot: function _initPathRoot() {\n      if (this._pathRoot) {\n        return;\n      }\n      var root = this._pathRoot = document.createElement('div');\n      root.className = 'leaflet-vml-container';\n      this._panes.overlayPane.appendChild(root);\n      this.on('moveend', this._updatePathViewport);\n      this._updatePathViewport();\n    }\n  });\n\n  /*\n  * Vector rendering for all browsers that support canvas.\n  */\n\n  L.Browser.canvas = function () {\n    return !!document.createElement('canvas').getContext;\n  }();\n  L.Path = L.Path.SVG && !window.L_PREFER_CANVAS || !L.Browser.canvas ? L.Path : L.Path.extend({\n    statics: {\n      //CLIP_PADDING: 0.02, // not sure if there's a need to set it to a small value\n      CANVAS: true,\n      SVG: false\n    },\n    redraw: function redraw() {\n      if (this._map) {\n        this.projectLatlngs();\n        this._requestUpdate();\n      }\n      return this;\n    },\n    setStyle: function setStyle(style) {\n      L.setOptions(this, style);\n      if (this._map) {\n        this._updateStyle();\n        this._requestUpdate();\n      }\n      return this;\n    },\n    onRemove: function onRemove(map) {\n      map.off('viewreset', this.projectLatlngs, this).off('moveend', this._updatePath, this);\n      if (this.options.clickable) {\n        this._map.off('click', this._onClick, this);\n        this._map.off('mousemove', this._onMouseMove, this);\n      }\n      this._requestUpdate();\n      this.fire('remove');\n      this._map = null;\n    },\n    _requestUpdate: function _requestUpdate() {\n      if (this._map && !L.Path._updateRequest) {\n        L.Path._updateRequest = L.Util.requestAnimFrame(this._fireMapMoveEnd, this._map);\n      }\n    },\n    _fireMapMoveEnd: function _fireMapMoveEnd() {\n      L.Path._updateRequest = null;\n      this.fire('moveend');\n    },\n    _initElements: function _initElements() {\n      this._map._initPathRoot();\n      this._ctx = this._map._canvasCtx;\n    },\n    _updateStyle: function _updateStyle() {\n      var options = this.options;\n      if (options.stroke) {\n        this._ctx.lineWidth = options.weight;\n        this._ctx.strokeStyle = options.color;\n      }\n      if (options.fill) {\n        this._ctx.fillStyle = options.fillColor || options.color;\n      }\n      if (options.lineCap) {\n        this._ctx.lineCap = options.lineCap;\n      }\n      if (options.lineJoin) {\n        this._ctx.lineJoin = options.lineJoin;\n      }\n    },\n    _drawPath: function _drawPath() {\n      var i, j, len, len2, point, drawMethod;\n      this._ctx.beginPath();\n      for (i = 0, len = this._parts.length; i < len; i++) {\n        for (j = 0, len2 = this._parts[i].length; j < len2; j++) {\n          point = this._parts[i][j];\n          drawMethod = (j === 0 ? 'move' : 'line') + 'To';\n          this._ctx[drawMethod](point.x, point.y);\n        }\n        // TODO refactor ugly hack\n        if (this instanceof L.Polygon) {\n          this._ctx.closePath();\n        }\n      }\n    },\n    _checkIfEmpty: function _checkIfEmpty() {\n      return !this._parts.length;\n    },\n    _updatePath: function _updatePath() {\n      if (this._checkIfEmpty()) {\n        return;\n      }\n      var ctx = this._ctx,\n        options = this.options;\n      this._drawPath();\n      ctx.save();\n      this._updateStyle();\n      if (options.fill) {\n        ctx.globalAlpha = options.fillOpacity;\n        ctx.fill(options.fillRule || 'evenodd');\n      }\n      if (options.stroke) {\n        ctx.globalAlpha = options.opacity;\n        ctx.stroke();\n      }\n      ctx.restore();\n\n      // TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\n    },\n    _initEvents: function _initEvents() {\n      if (this.options.clickable) {\n        this._map.on('mousemove', this._onMouseMove, this);\n        this._map.on('click dblclick contextmenu', this._fireMouseEvent, this);\n      }\n    },\n    _fireMouseEvent: function _fireMouseEvent(e) {\n      if (this._containsPoint(e.layerPoint)) {\n        this.fire(e.type, e);\n      }\n    },\n    _onMouseMove: function _onMouseMove(e) {\n      if (!this._map || this._map._animatingZoom) {\n        return;\n      }\n\n      // TODO don't do on each move\n      if (this._containsPoint(e.layerPoint)) {\n        this._ctx.canvas.style.cursor = 'pointer';\n        this._mouseInside = true;\n        this.fire('mouseover', e);\n      } else if (this._mouseInside) {\n        this._ctx.canvas.style.cursor = '';\n        this._mouseInside = false;\n        this.fire('mouseout', e);\n      }\n    }\n  });\n  L.Map.include(L.Path.SVG && !window.L_PREFER_CANVAS || !L.Browser.canvas ? {} : {\n    _initPathRoot: function _initPathRoot() {\n      var root = this._pathRoot,\n        ctx;\n      if (!root) {\n        root = this._pathRoot = document.createElement('canvas');\n        root.style.position = 'absolute';\n        ctx = this._canvasCtx = root.getContext('2d');\n        ctx.lineCap = 'round';\n        ctx.lineJoin = 'round';\n        this._panes.overlayPane.appendChild(root);\n        if (this.options.zoomAnimation) {\n          this._pathRoot.className = 'leaflet-zoom-animated';\n          this.on('zoomanim', this._animatePathZoom);\n          this.on('zoomend', this._endPathZoom);\n        }\n        this.on('moveend', this._updateCanvasViewport);\n        this._updateCanvasViewport();\n      }\n    },\n    _updateCanvasViewport: function _updateCanvasViewport() {\n      // don't redraw while zooming. See _updateSvgViewport for more details\n      if (this._pathZooming) {\n        return;\n      }\n      this._updatePathViewport();\n      var vp = this._pathViewport,\n        min = vp.min,\n        size = vp.max.subtract(min),\n        root = this._pathRoot;\n\n      //TODO check if this works properly on mobile webkit\n      L.DomUtil.setPosition(root, min);\n      root.width = size.x;\n      root.height = size.y;\n      root.getContext('2d').translate(-min.x, -min.y);\n    }\n  });\n\n  /*\n  * L.LineUtil contains different utility functions for line segments\n  * and polylines (clipping, simplification, distances, etc.)\n  */\n\n  /*jshint bitwise:false */ // allow bitwise operations for this file\n\n  L.LineUtil = {\n    // Simplify polyline with vertex reduction and Douglas-Peucker simplification.\n    // Improves rendering performance dramatically by lessening the number of points to draw.\n\n    simplify: function simplify( /*Point[]*/points, /*Number*/tolerance) {\n      if (!tolerance || !points.length) {\n        return points.slice();\n      }\n      var sqTolerance = tolerance * tolerance;\n\n      // stage 1: vertex reduction\n      points = this._reducePoints(points, sqTolerance);\n\n      // stage 2: Douglas-Peucker simplification\n      points = this._simplifyDP(points, sqTolerance);\n      return points;\n    },\n    // distance from a point to a segment between two points\n    pointToSegmentDistance: function pointToSegmentDistance( /*Point*/p, /*Point*/p1, /*Point*/p2) {\n      return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));\n    },\n    closestPointOnSegment: function closestPointOnSegment( /*Point*/p, /*Point*/p1, /*Point*/p2) {\n      return this._sqClosestPointOnSegment(p, p1, p2);\n    },\n    // Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm\n    _simplifyDP: function _simplifyDP(points, sqTolerance) {\n      var len = points.length,\n        ArrayConstructor = (typeof Uint8Array === \"undefined\" ? \"undefined\" : _typeof(Uint8Array)) !== undefined + '' ? Uint8Array : Array,\n        markers = new ArrayConstructor(len);\n      markers[0] = markers[len - 1] = 1;\n      this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\n      var i,\n        newPoints = [];\n      for (i = 0; i < len; i++) {\n        if (markers[i]) {\n          newPoints.push(points[i]);\n        }\n      }\n      return newPoints;\n    },\n    _simplifyDPStep: function _simplifyDPStep(points, markers, sqTolerance, first, last) {\n      var maxSqDist = 0,\n        index,\n        i,\n        sqDist;\n      for (i = first + 1; i <= last - 1; i++) {\n        sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);\n        if (sqDist > maxSqDist) {\n          index = i;\n          maxSqDist = sqDist;\n        }\n      }\n      if (maxSqDist > sqTolerance) {\n        markers[index] = 1;\n        this._simplifyDPStep(points, markers, sqTolerance, first, index);\n        this._simplifyDPStep(points, markers, sqTolerance, index, last);\n      }\n    },\n    // reduce points that are too close to each other to a single point\n    _reducePoints: function _reducePoints(points, sqTolerance) {\n      var reducedPoints = [points[0]];\n      for (var i = 1, prev = 0, len = points.length; i < len; i++) {\n        if (this._sqDist(points[i], points[prev]) > sqTolerance) {\n          reducedPoints.push(points[i]);\n          prev = i;\n        }\n      }\n      if (prev < len - 1) {\n        reducedPoints.push(points[len - 1]);\n      }\n      return reducedPoints;\n    },\n    // Cohen-Sutherland line clipping algorithm.\n    // Used to avoid rendering parts of a polyline that are not currently visible.\n\n    clipSegment: function clipSegment(a, b, bounds, useLastCode) {\n      var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),\n        codeB = this._getBitCode(b, bounds),\n        codeOut,\n        p,\n        newCode;\n\n      // save 2nd code to avoid calculating it on the next segment\n      this._lastCode = codeB;\n      while (true) {\n        // if a,b is inside the clip window (trivial accept)\n        if (!(codeA | codeB)) {\n          return [a, b];\n          // if a,b is outside the clip window (trivial reject)\n        } else if (codeA & codeB) {\n          return false;\n          // other cases\n        } else {\n          codeOut = codeA || codeB;\n          p = this._getEdgeIntersection(a, b, codeOut, bounds);\n          newCode = this._getBitCode(p, bounds);\n          if (codeOut === codeA) {\n            a = p;\n            codeA = newCode;\n          } else {\n            b = p;\n            codeB = newCode;\n          }\n        }\n      }\n    },\n    _getEdgeIntersection: function _getEdgeIntersection(a, b, code, bounds) {\n      var dx = b.x - a.x,\n        dy = b.y - a.y,\n        min = bounds.min,\n        max = bounds.max;\n      if (code & 8) {\n        // top\n        return new L.Point(a.x + dx * (max.y - a.y) / dy, max.y);\n      } else if (code & 4) {\n        // bottom\n        return new L.Point(a.x + dx * (min.y - a.y) / dy, min.y);\n      } else if (code & 2) {\n        // right\n        return new L.Point(max.x, a.y + dy * (max.x - a.x) / dx);\n      } else if (code & 1) {\n        // left\n        return new L.Point(min.x, a.y + dy * (min.x - a.x) / dx);\n      }\n    },\n    _getBitCode: function _getBitCode( /*Point*/p, bounds) {\n      var code = 0;\n      if (p.x < bounds.min.x) {\n        // left\n        code |= 1;\n      } else if (p.x > bounds.max.x) {\n        // right\n        code |= 2;\n      }\n      if (p.y < bounds.min.y) {\n        // bottom\n        code |= 4;\n      } else if (p.y > bounds.max.y) {\n        // top\n        code |= 8;\n      }\n      return code;\n    },\n    // square distance (to avoid unnecessary Math.sqrt calls)\n    _sqDist: function _sqDist(p1, p2) {\n      var dx = p2.x - p1.x,\n        dy = p2.y - p1.y;\n      return dx * dx + dy * dy;\n    },\n    // return closest point on segment or distance to that point\n    _sqClosestPointOnSegment: function _sqClosestPointOnSegment(p, p1, p2, sqDist) {\n      var x = p1.x,\n        y = p1.y,\n        dx = p2.x - x,\n        dy = p2.y - y,\n        dot = dx * dx + dy * dy,\n        t;\n      if (dot > 0) {\n        t = ((p.x - x) * dx + (p.y - y) * dy) / dot;\n        if (t > 1) {\n          x = p2.x;\n          y = p2.y;\n        } else if (t > 0) {\n          x += dx * t;\n          y += dy * t;\n        }\n      }\n      dx = p.x - x;\n      dy = p.y - y;\n      return sqDist ? dx * dx + dy * dy : new L.Point(x, y);\n    }\n  };\n\n  /*\n  * L.Polyline is used to display polylines on a map.\n  */\n\n  L.Polyline = L.Path.extend({\n    initialize: function initialize(latlngs, options) {\n      L.Path.prototype.initialize.call(this, options);\n      this._latlngs = this._convertLatLngs(latlngs);\n    },\n    options: {\n      // how much to simplify the polyline on each zoom level\n      // more = better performance and smoother look, less = more accurate\n      smoothFactor: 1.0,\n      noClip: false\n    },\n    projectLatlngs: function projectLatlngs() {\n      this._originalPoints = [];\n      for (var i = 0, len = this._latlngs.length; i < len; i++) {\n        this._originalPoints[i] = this._map.latLngToLayerPoint(this._latlngs[i]);\n      }\n    },\n    getPathString: function getPathString() {\n      for (var i = 0, len = this._parts.length, str = ''; i < len; i++) {\n        str += this._getPathPartStr(this._parts[i]);\n      }\n      return str;\n    },\n    getLatLngs: function getLatLngs() {\n      return this._latlngs;\n    },\n    setLatLngs: function setLatLngs(latlngs) {\n      this._latlngs = this._convertLatLngs(latlngs);\n      return this.redraw();\n    },\n    addLatLng: function addLatLng(latlng) {\n      this._latlngs.push(L.latLng(latlng));\n      return this.redraw();\n    },\n    spliceLatLngs: function spliceLatLngs() {\n      // (Number index, Number howMany)\n      var removed = [].splice.apply(this._latlngs, arguments);\n      this._convertLatLngs(this._latlngs, true);\n      this.redraw();\n      return removed;\n    },\n    closestLayerPoint: function closestLayerPoint(p) {\n      var minDistance = Infinity,\n        parts = this._parts,\n        p1,\n        p2,\n        minPoint = null;\n      for (var j = 0, jLen = parts.length; j < jLen; j++) {\n        var points = parts[j];\n        for (var i = 1, len = points.length; i < len; i++) {\n          p1 = points[i - 1];\n          p2 = points[i];\n          var sqDist = L.LineUtil._sqClosestPointOnSegment(p, p1, p2, true);\n          if (sqDist < minDistance) {\n            minDistance = sqDist;\n            minPoint = L.LineUtil._sqClosestPointOnSegment(p, p1, p2);\n          }\n        }\n      }\n      if (minPoint) {\n        minPoint.distance = Math.sqrt(minDistance);\n      }\n      return minPoint;\n    },\n    getBounds: function getBounds() {\n      return new L.LatLngBounds(this.getLatLngs());\n    },\n    _convertLatLngs: function _convertLatLngs(latlngs, overwrite) {\n      var i,\n        len,\n        target = overwrite ? latlngs : [];\n      for (i = 0, len = latlngs.length; i < len; i++) {\n        if (L.Util.isArray(latlngs[i]) && typeof latlngs[i][0] !== 'number') {\n          return;\n        }\n        target[i] = L.latLng(latlngs[i]);\n      }\n      return target;\n    },\n    _initEvents: function _initEvents() {\n      L.Path.prototype._initEvents.call(this);\n    },\n    _getPathPartStr: function _getPathPartStr(points) {\n      var round = L.Path.VML;\n      for (var j = 0, len2 = points.length, str = '', p; j < len2; j++) {\n        p = points[j];\n        if (round) {\n          p._round();\n        }\n        str += (j ? 'L' : 'M') + p.x + ' ' + p.y;\n      }\n      return str;\n    },\n    _clipPoints: function _clipPoints() {\n      var points = this._originalPoints,\n        len = points.length,\n        i,\n        k,\n        segment;\n      if (this.options.noClip) {\n        this._parts = [points];\n        return;\n      }\n      this._parts = [];\n      var parts = this._parts,\n        vp = this._map._pathViewport,\n        lu = L.LineUtil;\n      for (i = 0, k = 0; i < len - 1; i++) {\n        segment = lu.clipSegment(points[i], points[i + 1], vp, i);\n        if (!segment) {\n          continue;\n        }\n        parts[k] = parts[k] || [];\n        parts[k].push(segment[0]);\n\n        // if segment goes out of screen, or it's the last one, it's the end of the line part\n        if (segment[1] !== points[i + 1] || i === len - 2) {\n          parts[k].push(segment[1]);\n          k++;\n        }\n      }\n    },\n    // simplify each clipped part of the polyline\n    _simplifyPoints: function _simplifyPoints() {\n      var parts = this._parts,\n        lu = L.LineUtil;\n      for (var i = 0, len = parts.length; i < len; i++) {\n        parts[i] = lu.simplify(parts[i], this.options.smoothFactor);\n      }\n    },\n    _updatePath: function _updatePath() {\n      if (!this._map) {\n        return;\n      }\n      this._clipPoints();\n      this._simplifyPoints();\n      L.Path.prototype._updatePath.call(this);\n    }\n  });\n  L.polyline = function (latlngs, options) {\n    return new L.Polyline(latlngs, options);\n  };\n\n  /*\n  * L.PolyUtil contains utility functions for polygons (clipping, etc.).\n  */\n\n  /*jshint bitwise:false */ // allow bitwise operations here\n\n  L.PolyUtil = {};\n\n  /*\n  * Sutherland-Hodgeman polygon clipping algorithm.\n  * Used to avoid rendering parts of a polygon that are not currently visible.\n  */\n  L.PolyUtil.clipPolygon = function (points, bounds) {\n    var clippedPoints,\n      edges = [1, 4, 2, 8],\n      i,\n      j,\n      k,\n      a,\n      b,\n      len,\n      edge,\n      p,\n      lu = L.LineUtil;\n    for (i = 0, len = points.length; i < len; i++) {\n      points[i]._code = lu._getBitCode(points[i], bounds);\n    }\n\n    // for each edge (left, bottom, right, top)\n    for (k = 0; k < 4; k++) {\n      edge = edges[k];\n      clippedPoints = [];\n      for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n        a = points[i];\n        b = points[j];\n\n        // if a is inside the clip window\n        if (!(a._code & edge)) {\n          // if b is outside the clip window (a->b goes out of screen)\n          if (b._code & edge) {\n            p = lu._getEdgeIntersection(b, a, edge, bounds);\n            p._code = lu._getBitCode(p, bounds);\n            clippedPoints.push(p);\n          }\n          clippedPoints.push(a);\n\n          // else if b is inside the clip window (a->b enters the screen)\n        } else if (!(b._code & edge)) {\n          p = lu._getEdgeIntersection(b, a, edge, bounds);\n          p._code = lu._getBitCode(p, bounds);\n          clippedPoints.push(p);\n        }\n      }\n      points = clippedPoints;\n    }\n    return points;\n  };\n\n  /*\n  * L.Polygon is used to display polygons on a map.\n  */\n\n  L.Polygon = L.Polyline.extend({\n    options: {\n      fill: true\n    },\n    initialize: function initialize(latlngs, options) {\n      L.Polyline.prototype.initialize.call(this, latlngs, options);\n      this._initWithHoles(latlngs);\n    },\n    _initWithHoles: function _initWithHoles(latlngs) {\n      var i, len, hole;\n      if (latlngs && L.Util.isArray(latlngs[0]) && typeof latlngs[0][0] !== 'number') {\n        this._latlngs = this._convertLatLngs(latlngs[0]);\n        this._holes = latlngs.slice(1);\n        for (i = 0, len = this._holes.length; i < len; i++) {\n          hole = this._holes[i] = this._convertLatLngs(this._holes[i]);\n          if (hole[0].equals(hole[hole.length - 1])) {\n            hole.pop();\n          }\n        }\n      }\n\n      // filter out last point if its equal to the first one\n      latlngs = this._latlngs;\n      if (latlngs.length >= 2 && latlngs[0].equals(latlngs[latlngs.length - 1])) {\n        latlngs.pop();\n      }\n    },\n    projectLatlngs: function projectLatlngs() {\n      L.Polyline.prototype.projectLatlngs.call(this);\n\n      // project polygon holes points\n      // TODO move this logic to Polyline to get rid of duplication\n      this._holePoints = [];\n      if (!this._holes) {\n        return;\n      }\n      var i, j, len, len2;\n      for (i = 0, len = this._holes.length; i < len; i++) {\n        this._holePoints[i] = [];\n        for (j = 0, len2 = this._holes[i].length; j < len2; j++) {\n          this._holePoints[i][j] = this._map.latLngToLayerPoint(this._holes[i][j]);\n        }\n      }\n    },\n    setLatLngs: function setLatLngs(latlngs) {\n      if (latlngs && L.Util.isArray(latlngs[0]) && typeof latlngs[0][0] !== 'number') {\n        this._initWithHoles(latlngs);\n        return this.redraw();\n      } else {\n        return L.Polyline.prototype.setLatLngs.call(this, latlngs);\n      }\n    },\n    _clipPoints: function _clipPoints() {\n      var points = this._originalPoints,\n        newParts = [];\n      this._parts = [points].concat(this._holePoints);\n      if (this.options.noClip) {\n        return;\n      }\n      for (var i = 0, len = this._parts.length; i < len; i++) {\n        var clipped = L.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);\n        if (clipped.length) {\n          newParts.push(clipped);\n        }\n      }\n      this._parts = newParts;\n    },\n    _getPathPartStr: function _getPathPartStr(points) {\n      var str = L.Polyline.prototype._getPathPartStr.call(this, points);\n      return str + (L.Browser.svg ? 'z' : 'x');\n    }\n  });\n  L.polygon = function (latlngs, options) {\n    return new L.Polygon(latlngs, options);\n  };\n\n  /*\n  * Contains L.MultiPolyline and L.MultiPolygon layers.\n  */\n\n  (function () {\n    function createMulti(Klass) {\n      return L.FeatureGroup.extend({\n        initialize: function initialize(latlngs, options) {\n          this._layers = {};\n          this._options = options;\n          this.setLatLngs(latlngs);\n        },\n        setLatLngs: function setLatLngs(latlngs) {\n          var i = 0,\n            len = latlngs.length;\n          this.eachLayer(function (layer) {\n            if (i < len) {\n              layer.setLatLngs(latlngs[i++]);\n            } else {\n              this.removeLayer(layer);\n            }\n          }, this);\n          while (i < len) {\n            this.addLayer(new Klass(latlngs[i++], this._options));\n          }\n          return this;\n        },\n        getLatLngs: function getLatLngs() {\n          var latlngs = [];\n          this.eachLayer(function (layer) {\n            latlngs.push(layer.getLatLngs());\n          });\n          return latlngs;\n        }\n      });\n    }\n    L.MultiPolyline = createMulti(L.Polyline);\n    L.MultiPolygon = createMulti(L.Polygon);\n    L.multiPolyline = function (latlngs, options) {\n      return new L.MultiPolyline(latlngs, options);\n    };\n    L.multiPolygon = function (latlngs, options) {\n      return new L.MultiPolygon(latlngs, options);\n    };\n  })();\n\n  /*\n  * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\n  */\n\n  L.Rectangle = L.Polygon.extend({\n    initialize: function initialize(latLngBounds, options) {\n      L.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\n    },\n    setBounds: function setBounds(latLngBounds) {\n      this.setLatLngs(this._boundsToLatLngs(latLngBounds));\n    },\n    _boundsToLatLngs: function _boundsToLatLngs(latLngBounds) {\n      latLngBounds = L.latLngBounds(latLngBounds);\n      return [latLngBounds.getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast()];\n    }\n  });\n  L.rectangle = function (latLngBounds, options) {\n    return new L.Rectangle(latLngBounds, options);\n  };\n\n  /*\n  * L.Circle is a circle overlay (with a certain radius in meters).\n  */\n\n  L.Circle = L.Path.extend({\n    initialize: function initialize(latlng, radius, options) {\n      L.Path.prototype.initialize.call(this, options);\n      this._latlng = L.latLng(latlng);\n      this._mRadius = radius;\n    },\n    options: {\n      fill: true\n    },\n    setLatLng: function setLatLng(latlng) {\n      this._latlng = L.latLng(latlng);\n      return this.redraw();\n    },\n    setRadius: function setRadius(radius) {\n      this._mRadius = radius;\n      return this.redraw();\n    },\n    projectLatlngs: function projectLatlngs() {\n      var lngRadius = this._getLngRadius(),\n        latlng = this._latlng,\n        pointLeft = this._map.latLngToLayerPoint([latlng.lat, latlng.lng - lngRadius]);\n      this._point = this._map.latLngToLayerPoint(latlng);\n      this._radius = Math.max(this._point.x - pointLeft.x, 1);\n    },\n    getBounds: function getBounds() {\n      var lngRadius = this._getLngRadius(),\n        latRadius = this._mRadius / 40075017 * 360,\n        latlng = this._latlng;\n      return new L.LatLngBounds([latlng.lat - latRadius, latlng.lng - lngRadius], [latlng.lat + latRadius, latlng.lng + lngRadius]);\n    },\n    getLatLng: function getLatLng() {\n      return this._latlng;\n    },\n    getPathString: function getPathString() {\n      var p = this._point,\n        r = this._radius;\n      if (this._checkIfEmpty()) {\n        return '';\n      }\n      if (L.Browser.svg) {\n        return 'M' + p.x + ',' + (p.y - r) + 'A' + r + ',' + r + ',0,1,1,' + (p.x - 0.1) + ',' + (p.y - r) + ' z';\n      } else {\n        p._round();\n        r = Math.round(r);\n        return 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r + ' 0,' + 65535 * 360;\n      }\n    },\n    getRadius: function getRadius() {\n      return this._mRadius;\n    },\n    // TODO Earth hardcoded, move into projection code!\n\n    _getLatRadius: function _getLatRadius() {\n      return this._mRadius / 40075017 * 360;\n    },\n    _getLngRadius: function _getLngRadius() {\n      return this._getLatRadius() / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat);\n    },\n    _checkIfEmpty: function _checkIfEmpty() {\n      if (!this._map) {\n        return false;\n      }\n      var vp = this._map._pathViewport,\n        r = this._radius,\n        p = this._point;\n      return p.x - r > vp.max.x || p.y - r > vp.max.y || p.x + r < vp.min.x || p.y + r < vp.min.y;\n    }\n  });\n  L.circle = function (latlng, radius, options) {\n    return new L.Circle(latlng, radius, options);\n  };\n\n  /*\n  * L.CircleMarker is a circle overlay with a permanent pixel radius.\n  */\n\n  L.CircleMarker = L.Circle.extend({\n    options: {\n      radius: 10,\n      weight: 2\n    },\n    initialize: function initialize(latlng, options) {\n      L.Circle.prototype.initialize.call(this, latlng, null, options);\n      this._radius = this.options.radius;\n    },\n    projectLatlngs: function projectLatlngs() {\n      this._point = this._map.latLngToLayerPoint(this._latlng);\n    },\n    _updateStyle: function _updateStyle() {\n      L.Circle.prototype._updateStyle.call(this);\n      this.setRadius(this.options.radius);\n    },\n    setLatLng: function setLatLng(latlng) {\n      L.Circle.prototype.setLatLng.call(this, latlng);\n      if (this._popup && this._popup._isOpen) {\n        this._popup.setLatLng(latlng);\n      }\n      return this;\n    },\n    setRadius: function setRadius(radius) {\n      this.options.radius = this._radius = radius;\n      return this.redraw();\n    },\n    getRadius: function getRadius() {\n      return this._radius;\n    }\n  });\n  L.circleMarker = function (latlng, options) {\n    return new L.CircleMarker(latlng, options);\n  };\n\n  /*\n  * Extends L.Polyline to be able to manually detect clicks on Canvas-rendered polylines.\n  */\n\n  L.Polyline.include(!L.Path.CANVAS ? {} : {\n    _containsPoint: function _containsPoint(p, closed) {\n      var i,\n        j,\n        k,\n        len,\n        len2,\n        dist,\n        part,\n        w = this.options.weight / 2;\n      if (L.Browser.touch) {\n        w += 10; // polyline click tolerance on touch devices\n      }\n      for (i = 0, len = this._parts.length; i < len; i++) {\n        part = this._parts[i];\n        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n          if (!closed && j === 0) {\n            continue;\n          }\n          dist = L.LineUtil.pointToSegmentDistance(p, part[k], part[j]);\n          if (dist <= w) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n  });\n\n  /*\n  * Extends L.Polygon to be able to manually detect clicks on Canvas-rendered polygons.\n  */\n\n  L.Polygon.include(!L.Path.CANVAS ? {} : {\n    _containsPoint: function _containsPoint(p) {\n      var inside = false,\n        part,\n        p1,\n        p2,\n        i,\n        j,\n        k,\n        len,\n        len2;\n\n      // TODO optimization: check if within bounds first\n\n      if (L.Polyline.prototype._containsPoint.call(this, p, true)) {\n        // click on polygon border\n        return true;\n      }\n\n      // ray casting algorithm for detecting if point is in polygon\n\n      for (i = 0, len = this._parts.length; i < len; i++) {\n        part = this._parts[i];\n        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n          p1 = part[j];\n          p2 = part[k];\n          if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {\n            inside = !inside;\n          }\n        }\n      }\n      return inside;\n    }\n  });\n\n  /*\n  * Extends L.Circle with Canvas-specific code.\n  */\n\n  L.Circle.include(!L.Path.CANVAS ? {} : {\n    _drawPath: function _drawPath() {\n      var p = this._point;\n      this._ctx.beginPath();\n      this._ctx.arc(p.x, p.y, this._radius, 0, Math.PI * 2, false);\n    },\n    _containsPoint: function _containsPoint(p) {\n      var center = this._point,\n        w2 = this.options.stroke ? this.options.weight / 2 : 0;\n      return p.distanceTo(center) <= this._radius + w2;\n    }\n  });\n\n  /*\n  * CircleMarker canvas specific drawing parts.\n  */\n\n  L.CircleMarker.include(!L.Path.CANVAS ? {} : {\n    _updateStyle: function _updateStyle() {\n      L.Path.prototype._updateStyle.call(this);\n    }\n  });\n\n  /*\n  * L.GeoJSON turns any GeoJSON data into a Leaflet layer.\n  */\n\n  L.GeoJSON = L.FeatureGroup.extend({\n    initialize: function initialize(geojson, options) {\n      L.setOptions(this, options);\n      this._layers = {};\n      if (geojson) {\n        this.addData(geojson);\n      }\n    },\n    addData: function addData(geojson) {\n      var features = L.Util.isArray(geojson) ? geojson : geojson.features,\n        i,\n        len,\n        feature;\n      if (features) {\n        for (i = 0, len = features.length; i < len; i++) {\n          // Only add this if geometry or geometries are set and not null\n          feature = features[i];\n          if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\n            this.addData(features[i]);\n          }\n        }\n        return this;\n      }\n      var options = this.options;\n      if (options.filter && !options.filter(geojson)) {\n        return;\n      }\n      var layer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng, options);\n      layer.feature = L.GeoJSON.asFeature(geojson);\n      layer.defaultOptions = layer.options;\n      this.resetStyle(layer);\n      if (options.onEachFeature) {\n        options.onEachFeature(geojson, layer);\n      }\n      return this.addLayer(layer);\n    },\n    resetStyle: function resetStyle(layer) {\n      var style = this.options.style;\n      if (style) {\n        // reset any custom styles\n        L.Util.extend(layer.options, layer.defaultOptions);\n        this._setLayerStyle(layer, style);\n      }\n    },\n    setStyle: function setStyle(style) {\n      this.eachLayer(function (layer) {\n        this._setLayerStyle(layer, style);\n      }, this);\n    },\n    _setLayerStyle: function _setLayerStyle(layer, style) {\n      if (typeof style === 'function') {\n        style = style(layer.feature);\n      }\n      if (layer.setStyle) {\n        layer.setStyle(style);\n      }\n    }\n  });\n  L.extend(L.GeoJSON, {\n    geometryToLayer: function geometryToLayer(geojson, pointToLayer, coordsToLatLng, vectorOptions) {\n      var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\n        coords = geometry.coordinates,\n        layers = [],\n        latlng,\n        latlngs,\n        i,\n        len;\n      coordsToLatLng = coordsToLatLng || this.coordsToLatLng;\n      switch (geometry.type) {\n        case 'Point':\n          latlng = coordsToLatLng(coords);\n          return pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);\n        case 'MultiPoint':\n          for (i = 0, len = coords.length; i < len; i++) {\n            latlng = coordsToLatLng(coords[i]);\n            layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));\n          }\n          return new L.FeatureGroup(layers);\n        case 'LineString':\n          latlngs = this.coordsToLatLngs(coords, 0, coordsToLatLng);\n          return new L.Polyline(latlngs, vectorOptions);\n        case 'Polygon':\n          if (coords.length === 2 && !coords[1].length) {\n            throw new Error('Invalid GeoJSON object.');\n          }\n          latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);\n          return new L.Polygon(latlngs, vectorOptions);\n        case 'MultiLineString':\n          latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);\n          return new L.MultiPolyline(latlngs, vectorOptions);\n        case 'MultiPolygon':\n          latlngs = this.coordsToLatLngs(coords, 2, coordsToLatLng);\n          return new L.MultiPolygon(latlngs, vectorOptions);\n        case 'GeometryCollection':\n          for (i = 0, len = geometry.geometries.length; i < len; i++) {\n            layers.push(this.geometryToLayer({\n              geometry: geometry.geometries[i],\n              type: 'Feature',\n              properties: geojson.properties\n            }, pointToLayer, coordsToLatLng, vectorOptions));\n          }\n          return new L.FeatureGroup(layers);\n        default:\n          throw new Error('Invalid GeoJSON object.');\n      }\n    },\n    coordsToLatLng: function coordsToLatLng(coords) {\n      // (Array[, Boolean]) -> LatLng\n      return new L.LatLng(coords[1], coords[0], coords[2]);\n    },\n    coordsToLatLngs: function coordsToLatLngs(coords, levelsDeep, coordsToLatLng) {\n      // (Array[, Number, Function]) -> Array\n      var latlng,\n        i,\n        len,\n        latlngs = [];\n      for (i = 0, len = coords.length; i < len; i++) {\n        latlng = levelsDeep ? this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) : (coordsToLatLng || this.coordsToLatLng)(coords[i]);\n        latlngs.push(latlng);\n      }\n      return latlngs;\n    },\n    latLngToCoords: function latLngToCoords(latlng) {\n      var coords = [latlng.lng, latlng.lat];\n      if (latlng.alt !== undefined) {\n        coords.push(latlng.alt);\n      }\n      return coords;\n    },\n    latLngsToCoords: function latLngsToCoords(latLngs) {\n      var coords = [];\n      for (var i = 0, len = latLngs.length; i < len; i++) {\n        coords.push(L.GeoJSON.latLngToCoords(latLngs[i]));\n      }\n      return coords;\n    },\n    getFeature: function getFeature(layer, newGeometry) {\n      return layer.feature ? L.extend({}, layer.feature, {\n        geometry: newGeometry\n      }) : L.GeoJSON.asFeature(newGeometry);\n    },\n    asFeature: function asFeature(geoJSON) {\n      if (geoJSON.type === 'Feature') {\n        return geoJSON;\n      }\n      return {\n        type: 'Feature',\n        properties: {},\n        geometry: geoJSON\n      };\n    }\n  });\n  var PointToGeoJSON = {\n    toGeoJSON: function toGeoJSON() {\n      return L.GeoJSON.getFeature(this, {\n        type: 'Point',\n        coordinates: L.GeoJSON.latLngToCoords(this.getLatLng())\n      });\n    }\n  };\n  L.Marker.include(PointToGeoJSON);\n  L.Circle.include(PointToGeoJSON);\n  L.CircleMarker.include(PointToGeoJSON);\n  L.Polyline.include({\n    toGeoJSON: function toGeoJSON() {\n      return L.GeoJSON.getFeature(this, {\n        type: 'LineString',\n        coordinates: L.GeoJSON.latLngsToCoords(this.getLatLngs())\n      });\n    }\n  });\n  L.Polygon.include({\n    toGeoJSON: function toGeoJSON() {\n      var coords = [L.GeoJSON.latLngsToCoords(this.getLatLngs())],\n        i,\n        len,\n        hole;\n      coords[0].push(coords[0][0]);\n      if (this._holes) {\n        for (i = 0, len = this._holes.length; i < len; i++) {\n          hole = L.GeoJSON.latLngsToCoords(this._holes[i]);\n          hole.push(hole[0]);\n          coords.push(hole);\n        }\n      }\n      return L.GeoJSON.getFeature(this, {\n        type: 'Polygon',\n        coordinates: coords\n      });\n    }\n  });\n  (function () {\n    function multiToGeoJSON(type) {\n      return function () {\n        var coords = [];\n        this.eachLayer(function (layer) {\n          coords.push(layer.toGeoJSON().geometry.coordinates);\n        });\n        return L.GeoJSON.getFeature(this, {\n          type: type,\n          coordinates: coords\n        });\n      };\n    }\n    L.MultiPolyline.include({\n      toGeoJSON: multiToGeoJSON('MultiLineString')\n    });\n    L.MultiPolygon.include({\n      toGeoJSON: multiToGeoJSON('MultiPolygon')\n    });\n    L.LayerGroup.include({\n      toGeoJSON: function toGeoJSON() {\n        var geometry = this.feature && this.feature.geometry,\n          jsons = [],\n          json;\n        if (geometry && geometry.type === 'MultiPoint') {\n          return multiToGeoJSON('MultiPoint').call(this);\n        }\n        var isGeometryCollection = geometry && geometry.type === 'GeometryCollection';\n        this.eachLayer(function (layer) {\n          if (layer.toGeoJSON) {\n            json = layer.toGeoJSON();\n            jsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));\n          }\n        });\n        if (isGeometryCollection) {\n          return L.GeoJSON.getFeature(this, {\n            geometries: jsons,\n            type: 'GeometryCollection'\n          });\n        }\n        return {\n          type: 'FeatureCollection',\n          features: jsons\n        };\n      }\n    });\n  })();\n  L.geoJson = function (geojson, options) {\n    return new L.GeoJSON(geojson, options);\n  };\n\n  /*\n  * L.DomEvent contains functions for working with DOM events.\n  */\n\n  L.DomEvent = {\n    /* inspired by John Resig, Dean Edwards and YUI addEvent implementations */\n    addListener: function addListener(obj, type, fn, context) {\n      // (HTMLElement, String, Function[, Object])\n\n      var id = L.stamp(fn),\n        key = '_leaflet_' + type + id,\n        handler,\n        originalHandler,\n        newType;\n      if (obj[key]) {\n        return this;\n      }\n      handler = function handler(e) {\n        return fn.call(context || obj, e || L.DomEvent._getEvent());\n      };\n      if (L.Browser.pointer && type.indexOf('touch') === 0) {\n        return this.addPointerListener(obj, type, handler, id);\n      }\n      if (L.Browser.touch && type === 'dblclick' && this.addDoubleTapListener) {\n        this.addDoubleTapListener(obj, handler, id);\n      }\n      if ('addEventListener' in obj) {\n        if (type === 'mousewheel') {\n          obj.addEventListener('DOMMouseScroll', handler, false);\n          obj.addEventListener(type, handler, false);\n        } else if (type === 'mouseenter' || type === 'mouseleave') {\n          originalHandler = handler;\n          newType = type === 'mouseenter' ? 'mouseover' : 'mouseout';\n          handler = function handler(e) {\n            if (!L.DomEvent._checkMouse(obj, e)) {\n              return;\n            }\n            return originalHandler(e);\n          };\n          obj.addEventListener(newType, handler, false);\n        } else if (type === 'click' && L.Browser.android) {\n          originalHandler = handler;\n          handler = function handler(e) {\n            return L.DomEvent._filterClick(e, originalHandler);\n          };\n          obj.addEventListener(type, handler, false);\n        } else {\n          obj.addEventListener(type, handler, false);\n        }\n      } else if ('attachEvent' in obj) {\n        obj.attachEvent('on' + type, handler);\n      }\n      obj[key] = handler;\n      return this;\n    },\n    removeListener: function removeListener(obj, type, fn) {\n      // (HTMLElement, String, Function)\n\n      var id = L.stamp(fn),\n        key = '_leaflet_' + type + id,\n        handler = obj[key];\n      if (!handler) {\n        return this;\n      }\n      if (L.Browser.pointer && type.indexOf('touch') === 0) {\n        this.removePointerListener(obj, type, id);\n      } else if (L.Browser.touch && type === 'dblclick' && this.removeDoubleTapListener) {\n        this.removeDoubleTapListener(obj, id);\n      } else if ('removeEventListener' in obj) {\n        if (type === 'mousewheel') {\n          obj.removeEventListener('DOMMouseScroll', handler, false);\n          obj.removeEventListener(type, handler, false);\n        } else if (type === 'mouseenter' || type === 'mouseleave') {\n          obj.removeEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);\n        } else {\n          obj.removeEventListener(type, handler, false);\n        }\n      } else if ('detachEvent' in obj) {\n        obj.detachEvent('on' + type, handler);\n      }\n      obj[key] = null;\n      return this;\n    },\n    stopPropagation: function stopPropagation(e) {\n      if (e.stopPropagation) {\n        e.stopPropagation();\n      } else {\n        e.cancelBubble = true;\n      }\n      L.DomEvent._skipped(e);\n      return this;\n    },\n    disableScrollPropagation: function disableScrollPropagation(el) {\n      var stop = L.DomEvent.stopPropagation;\n      return L.DomEvent.on(el, 'mousewheel', stop).on(el, 'MozMousePixelScroll', stop);\n    },\n    disableClickPropagation: function disableClickPropagation(el) {\n      var stop = L.DomEvent.stopPropagation;\n      for (var i = L.Draggable.START.length - 1; i >= 0; i--) {\n        L.DomEvent.on(el, L.Draggable.START[i], stop);\n      }\n      return L.DomEvent.on(el, 'click', L.DomEvent._fakeStop).on(el, 'dblclick', stop);\n    },\n    preventDefault: function preventDefault(e) {\n      if (e.preventDefault) {\n        e.preventDefault();\n      } else {\n        e.returnValue = false;\n      }\n      return this;\n    },\n    stop: function stop(e) {\n      return L.DomEvent.preventDefault(e).stopPropagation(e);\n    },\n    getMousePosition: function getMousePosition(e, container) {\n      if (!container) {\n        return new L.Point(e.clientX, e.clientY);\n      }\n      var rect = container.getBoundingClientRect();\n      return new L.Point(e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop);\n    },\n    getWheelDelta: function getWheelDelta(e) {\n      var delta = 0;\n      if (e.wheelDelta) {\n        delta = e.wheelDelta / 120;\n      }\n      if (e.detail) {\n        delta = -e.detail / 3;\n      }\n      return delta;\n    },\n    _skipEvents: {},\n    _fakeStop: function _fakeStop(e) {\n      // fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)\n      L.DomEvent._skipEvents[e.type] = true;\n    },\n    _skipped: function _skipped(e) {\n      var skipped = this._skipEvents[e.type];\n      // reset when checking, as it's only used in map container and propagates outside of the map\n      this._skipEvents[e.type] = false;\n      return skipped;\n    },\n    // check if element really left/entered the event target (for mouseenter/mouseleave)\n    _checkMouse: function _checkMouse(el, e) {\n      var related = e.relatedTarget;\n      if (!related) {\n        return true;\n      }\n      try {\n        while (related && related !== el) {\n          related = related.parentNode;\n        }\n      } catch (err) {\n        return false;\n      }\n      return related !== el;\n    },\n    _getEvent: function _getEvent() {\n      // evil magic for IE\n      /*jshint noarg:false */\n      var e = window.event;\n      if (!e) {\n        var caller = arguments.callee.caller;\n        while (caller) {\n          e = caller['arguments'][0];\n          if (e && window.Event === e.constructor) {\n            break;\n          }\n          caller = caller.caller;\n        }\n      }\n      return e;\n    },\n    // this is a horrible workaround for a bug in Android where a single touch triggers two click events\n    _filterClick: function _filterClick(e, handler) {\n      var timeStamp = e.timeStamp || e.originalEvent.timeStamp,\n        elapsed = L.DomEvent._lastClick && timeStamp - L.DomEvent._lastClick;\n\n      // are they closer together than 500ms yet more than 100ms?\n      // Android typically triggers them ~300ms apart while multiple listeners\n      // on the same event should be triggered far faster;\n      // or check if click is simulated on the element, and if it is, reject any non-simulated events\n\n      if (elapsed && elapsed > 100 && elapsed < 500 || e.target._simulatedClick && !e._simulated) {\n        L.DomEvent.stop(e);\n        return;\n      }\n      L.DomEvent._lastClick = timeStamp;\n      return handler(e);\n    }\n  };\n  L.DomEvent.on = L.DomEvent.addListener;\n  L.DomEvent.off = L.DomEvent.removeListener;\n\n  /*\n  * L.Draggable allows you to add dragging capabilities to any element. Supports mobile devices too.\n  */\n\n  L.Draggable = L.Class.extend({\n    includes: L.Mixin.Events,\n    statics: {\n      START: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],\n      END: {\n        mousedown: 'mouseup',\n        touchstart: 'touchend',\n        pointerdown: 'touchend',\n        MSPointerDown: 'touchend'\n      },\n      MOVE: {\n        mousedown: 'mousemove',\n        touchstart: 'touchmove',\n        pointerdown: 'touchmove',\n        MSPointerDown: 'touchmove'\n      }\n    },\n    initialize: function initialize(element, dragStartTarget) {\n      this._element = element;\n      this._dragStartTarget = dragStartTarget || element;\n    },\n    enable: function enable() {\n      if (this._enabled) {\n        return;\n      }\n      for (var i = L.Draggable.START.length - 1; i >= 0; i--) {\n        L.DomEvent.on(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);\n      }\n      this._enabled = true;\n    },\n    disable: function disable() {\n      if (!this._enabled) {\n        return;\n      }\n      for (var i = L.Draggable.START.length - 1; i >= 0; i--) {\n        L.DomEvent.off(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);\n      }\n      this._enabled = false;\n      this._moved = false;\n    },\n    _onDown: function _onDown(e) {\n      this._moved = false;\n      if (e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {\n        return;\n      }\n      L.DomEvent.stopPropagation(e);\n      if (L.Draggable._disabled) {\n        return;\n      }\n      L.DomUtil.disableImageDrag();\n      L.DomUtil.disableTextSelection();\n      if (this._moving) {\n        return;\n      }\n      var first = e.touches ? e.touches[0] : e;\n      this._startPoint = new L.Point(first.clientX, first.clientY);\n      this._startPos = this._newPos = L.DomUtil.getPosition(this._element);\n      L.DomEvent.on(document, L.Draggable.MOVE[e.type], this._onMove, this).on(document, L.Draggable.END[e.type], this._onUp, this);\n    },\n    _onMove: function _onMove(e) {\n      if (e.touches && e.touches.length > 1) {\n        this._moved = true;\n        return;\n      }\n      var first = e.touches && e.touches.length === 1 ? e.touches[0] : e,\n        newPoint = new L.Point(first.clientX, first.clientY),\n        offset = newPoint.subtract(this._startPoint);\n      if (!offset.x && !offset.y) {\n        return;\n      }\n      if (L.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) {\n        return;\n      }\n      L.DomEvent.preventDefault(e);\n      if (!this._moved) {\n        this.fire('dragstart');\n        this._moved = true;\n        this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);\n        L.DomUtil.addClass(document.body, 'leaflet-dragging');\n        this._lastTarget = e.target || e.srcElement;\n        L.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');\n      }\n      this._newPos = this._startPos.add(offset);\n      this._moving = true;\n      L.Util.cancelAnimFrame(this._animRequest);\n      this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);\n    },\n    _updatePosition: function _updatePosition() {\n      this.fire('predrag');\n      L.DomUtil.setPosition(this._element, this._newPos);\n      this.fire('drag');\n    },\n    _onUp: function _onUp() {\n      L.DomUtil.removeClass(document.body, 'leaflet-dragging');\n      if (this._lastTarget) {\n        L.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');\n        this._lastTarget = null;\n      }\n      for (var i in L.Draggable.MOVE) {\n        L.DomEvent.off(document, L.Draggable.MOVE[i], this._onMove).off(document, L.Draggable.END[i], this._onUp);\n      }\n      L.DomUtil.enableImageDrag();\n      L.DomUtil.enableTextSelection();\n      if (this._moved && this._moving) {\n        // ensure drag is not fired after dragend\n        L.Util.cancelAnimFrame(this._animRequest);\n        this.fire('dragend', {\n          distance: this._newPos.distanceTo(this._startPos)\n        });\n      }\n      this._moving = false;\n    }\n  });\n\n  /*\n  L.Handler is a base class for handler classes that are used internally to inject\n  interaction features like dragging to classes like Map and Marker.\n  */\n\n  L.Handler = L.Class.extend({\n    initialize: function initialize(map) {\n      this._map = map;\n    },\n    enable: function enable() {\n      if (this._enabled) {\n        return;\n      }\n      this._enabled = true;\n      this.addHooks();\n    },\n    disable: function disable() {\n      if (!this._enabled) {\n        return;\n      }\n      this._enabled = false;\n      this.removeHooks();\n    },\n    enabled: function enabled() {\n      return !!this._enabled;\n    }\n  });\n\n  /*\n  * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n  */\n\n  L.Map.mergeOptions({\n    dragging: true,\n    inertia: !L.Browser.android23,\n    inertiaDeceleration: 3400,\n    // px/s^2\n    inertiaMaxSpeed: Infinity,\n    // px/s\n    inertiaThreshold: L.Browser.touch ? 32 : 18,\n    // ms\n    easeLinearity: 0.25,\n    // TODO refactor, move to CRS\n    worldCopyJump: false\n  });\n  L.Map.Drag = L.Handler.extend({\n    addHooks: function addHooks() {\n      if (!this._draggable) {\n        var map = this._map;\n        this._draggable = new L.Draggable(map._mapPane, map._container);\n        this._draggable.on({\n          'dragstart': this._onDragStart,\n          'drag': this._onDrag,\n          'dragend': this._onDragEnd\n        }, this);\n        if (map.options.worldCopyJump) {\n          this._draggable.on('predrag', this._onPreDrag, this);\n          map.on('viewreset', this._onViewReset, this);\n          map.whenReady(this._onViewReset, this);\n        }\n      }\n      this._draggable.enable();\n    },\n    removeHooks: function removeHooks() {\n      this._draggable.disable();\n    },\n    moved: function moved() {\n      return this._draggable && this._draggable._moved;\n    },\n    _onDragStart: function _onDragStart() {\n      var map = this._map;\n      if (map._panAnim) {\n        map._panAnim.stop();\n      }\n      map.fire('movestart').fire('dragstart');\n      if (map.options.inertia) {\n        this._positions = [];\n        this._times = [];\n      }\n    },\n    _onDrag: function _onDrag() {\n      if (this._map.options.inertia) {\n        var time = this._lastTime = +new Date(),\n          pos = this._lastPos = this._draggable._newPos;\n        this._positions.push(pos);\n        this._times.push(time);\n        if (time - this._times[0] > 200) {\n          this._positions.shift();\n          this._times.shift();\n        }\n      }\n      this._map.fire('move').fire('drag');\n    },\n    _onViewReset: function _onViewReset() {\n      // TODO fix hardcoded Earth values\n      var pxCenter = this._map.getSize()._divideBy(2),\n        pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);\n      this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n      this._worldWidth = this._map.project([0, 180]).x;\n    },\n    _onPreDrag: function _onPreDrag() {\n      // TODO refactor to be able to adjust map pane position after zoom\n      var worldWidth = this._worldWidth,\n        halfWidth = Math.round(worldWidth / 2),\n        dx = this._initialWorldOffset,\n        x = this._draggable._newPos.x,\n        newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,\n        newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,\n        newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n      this._draggable._newPos.x = newX;\n    },\n    _onDragEnd: function _onDragEnd(e) {\n      var map = this._map,\n        options = map.options,\n        delay = +new Date() - this._lastTime,\n        noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];\n      map.fire('dragend', e);\n      if (noInertia) {\n        map.fire('moveend');\n      } else {\n        var direction = this._lastPos.subtract(this._positions[0]),\n          duration = (this._lastTime + delay - this._times[0]) / 1000,\n          ease = options.easeLinearity,\n          speedVector = direction.multiplyBy(ease / duration),\n          speed = speedVector.distanceTo([0, 0]),\n          limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),\n          limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),\n          decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),\n          offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n        if (!offset.x || !offset.y) {\n          map.fire('moveend');\n        } else {\n          offset = map._limitOffset(offset, map.options.maxBounds);\n          L.Util.requestAnimFrame(function () {\n            map.panBy(offset, {\n              duration: decelerationDuration,\n              easeLinearity: ease,\n              noMoveStart: true\n            });\n          });\n        }\n      }\n    }\n  });\n  L.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);\n\n  /*\n  * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n  */\n\n  L.Map.mergeOptions({\n    doubleClickZoom: true\n  });\n  L.Map.DoubleClickZoom = L.Handler.extend({\n    addHooks: function addHooks() {\n      this._map.on('dblclick', this._onDoubleClick, this);\n    },\n    removeHooks: function removeHooks() {\n      this._map.off('dblclick', this._onDoubleClick, this);\n    },\n    _onDoubleClick: function _onDoubleClick(e) {\n      var map = this._map,\n        zoom = map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1);\n      if (map.options.doubleClickZoom === 'center') {\n        map.setZoom(zoom);\n      } else {\n        map.setZoomAround(e.containerPoint, zoom);\n      }\n    }\n  });\n  L.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);\n\n  /*\n  * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n  */\n\n  L.Map.mergeOptions({\n    scrollWheelZoom: true\n  });\n  L.Map.ScrollWheelZoom = L.Handler.extend({\n    addHooks: function addHooks() {\n      L.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);\n      L.DomEvent.on(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);\n      this._delta = 0;\n    },\n    removeHooks: function removeHooks() {\n      L.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll);\n      L.DomEvent.off(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);\n    },\n    _onWheelScroll: function _onWheelScroll(e) {\n      var delta = L.DomEvent.getWheelDelta(e);\n      this._delta += delta;\n      this._lastMousePos = this._map.mouseEventToContainerPoint(e);\n      if (!this._startTime) {\n        this._startTime = +new Date();\n      }\n      var left = Math.max(40 - (+new Date() - this._startTime), 0);\n      clearTimeout(this._timer);\n      this._timer = setTimeout(L.bind(this._performZoom, this), left);\n      L.DomEvent.preventDefault(e);\n      L.DomEvent.stopPropagation(e);\n    },\n    _performZoom: function _performZoom() {\n      var map = this._map,\n        delta = this._delta,\n        zoom = map.getZoom();\n      delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n      delta = Math.max(Math.min(delta, 4), -4);\n      delta = map._limitZoom(zoom + delta) - zoom;\n      this._delta = 0;\n      this._startTime = null;\n      if (!delta) {\n        return;\n      }\n      if (map.options.scrollWheelZoom === 'center') {\n        map.setZoom(zoom + delta);\n      } else {\n        map.setZoomAround(this._lastMousePos, zoom + delta);\n      }\n    }\n  });\n  L.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);\n\n  /*\n  * Extends the event handling code with double tap support for mobile browsers.\n  */\n\n  L.extend(L.DomEvent, {\n    _touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',\n    _touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',\n    // inspired by Zepto touch code by Thomas Fuchs\n    addDoubleTapListener: function addDoubleTapListener(obj, handler, id) {\n      var last,\n        doubleTap = false,\n        delay = 250,\n        touch,\n        pre = '_leaflet_',\n        touchstart = this._touchstart,\n        touchend = this._touchend,\n        trackedTouches = [];\n      function onTouchStart(e) {\n        var count;\n        if (L.Browser.pointer) {\n          trackedTouches.push(e.pointerId);\n          count = trackedTouches.length;\n        } else {\n          count = e.touches.length;\n        }\n        if (count > 1) {\n          return;\n        }\n        var now = Date.now(),\n          delta = now - (last || now);\n        touch = e.touches ? e.touches[0] : e;\n        doubleTap = delta > 0 && delta <= delay;\n        last = now;\n      }\n      function onTouchEnd(e) {\n        if (L.Browser.pointer) {\n          var idx = trackedTouches.indexOf(e.pointerId);\n          if (idx === -1) {\n            return;\n          }\n          trackedTouches.splice(idx, 1);\n        }\n        if (doubleTap) {\n          if (L.Browser.pointer) {\n            // work around .type being readonly with MSPointer* events\n            var newTouch = {},\n              prop;\n\n            // jshint forin:false\n            for (var i in touch) {\n              prop = touch[i];\n              if (typeof prop === 'function') {\n                newTouch[i] = prop.bind(touch);\n              } else {\n                newTouch[i] = prop;\n              }\n            }\n            touch = newTouch;\n          }\n          touch.type = 'dblclick';\n          handler(touch);\n          last = null;\n        }\n      }\n      obj[pre + touchstart + id] = onTouchStart;\n      obj[pre + touchend + id] = onTouchEnd;\n\n      // on pointer we need to listen on the document, otherwise a drag starting on the map and moving off screen\n      // will not come through to us, so we will lose track of how many touches are ongoing\n      var endElement = L.Browser.pointer ? document.documentElement : obj;\n      obj.addEventListener(touchstart, onTouchStart, false);\n      endElement.addEventListener(touchend, onTouchEnd, false);\n      if (L.Browser.pointer) {\n        endElement.addEventListener(L.DomEvent.POINTER_CANCEL, onTouchEnd, false);\n      }\n      return this;\n    },\n    removeDoubleTapListener: function removeDoubleTapListener(obj, id) {\n      var pre = '_leaflet_';\n      obj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);\n      (L.Browser.pointer ? document.documentElement : obj).removeEventListener(this._touchend, obj[pre + this._touchend + id], false);\n      if (L.Browser.pointer) {\n        document.documentElement.removeEventListener(L.DomEvent.POINTER_CANCEL, obj[pre + this._touchend + id], false);\n      }\n      return this;\n    }\n  });\n\n  /*\n  * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n  */\n\n  L.extend(L.DomEvent, {\n    //static\n    POINTER_DOWN: L.Browser.msPointer ? 'MSPointerDown' : 'pointerdown',\n    POINTER_MOVE: L.Browser.msPointer ? 'MSPointerMove' : 'pointermove',\n    POINTER_UP: L.Browser.msPointer ? 'MSPointerUp' : 'pointerup',\n    POINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',\n    _pointers: [],\n    _pointerDocumentListener: false,\n    // Provides a touch events wrapper for (ms)pointer events.\n    // Based on changes by veproza https://github.com/CloudMade/Leaflet/pull/1019\n    //ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n\n    addPointerListener: function addPointerListener(obj, type, handler, id) {\n      switch (type) {\n        case 'touchstart':\n          return this.addPointerListenerStart(obj, type, handler, id);\n        case 'touchend':\n          return this.addPointerListenerEnd(obj, type, handler, id);\n        case 'touchmove':\n          return this.addPointerListenerMove(obj, type, handler, id);\n        default:\n          throw 'Unknown touch event type';\n      }\n    },\n    addPointerListenerStart: function addPointerListenerStart(obj, type, handler, id) {\n      var pre = '_leaflet_',\n        pointers = this._pointers;\n      var cb = function cb(e) {\n        if (e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {\n          L.DomEvent.preventDefault(e);\n        }\n        var alreadyInArray = false;\n        for (var i = 0; i < pointers.length; i++) {\n          if (pointers[i].pointerId === e.pointerId) {\n            alreadyInArray = true;\n            break;\n          }\n        }\n        if (!alreadyInArray) {\n          pointers.push(e);\n        }\n        e.touches = pointers.slice();\n        e.changedTouches = [e];\n        handler(e);\n      };\n      obj[pre + 'touchstart' + id] = cb;\n      obj.addEventListener(this.POINTER_DOWN, cb, false);\n\n      // need to also listen for end events to keep the _pointers list accurate\n      // this needs to be on the body and never go away\n      if (!this._pointerDocumentListener) {\n        var internalCb = function internalCb(e) {\n          for (var i = 0; i < pointers.length; i++) {\n            if (pointers[i].pointerId === e.pointerId) {\n              pointers.splice(i, 1);\n              break;\n            }\n          }\n        };\n        //We listen on the documentElement as any drags that end by moving the touch off the screen get fired there\n        document.documentElement.addEventListener(this.POINTER_UP, internalCb, false);\n        document.documentElement.addEventListener(this.POINTER_CANCEL, internalCb, false);\n        this._pointerDocumentListener = true;\n      }\n      return this;\n    },\n    addPointerListenerMove: function addPointerListenerMove(obj, type, handler, id) {\n      var pre = '_leaflet_',\n        touches = this._pointers;\n      function cb(e) {\n        // don't fire touch moves when mouse isn't down\n        if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) {\n          return;\n        }\n        for (var i = 0; i < touches.length; i++) {\n          if (touches[i].pointerId === e.pointerId) {\n            touches[i] = e;\n            break;\n          }\n        }\n        e.touches = touches.slice();\n        e.changedTouches = [e];\n        handler(e);\n      }\n      obj[pre + 'touchmove' + id] = cb;\n      obj.addEventListener(this.POINTER_MOVE, cb, false);\n      return this;\n    },\n    addPointerListenerEnd: function addPointerListenerEnd(obj, type, handler, id) {\n      var pre = '_leaflet_',\n        touches = this._pointers;\n      var cb = function cb(e) {\n        for (var i = 0; i < touches.length; i++) {\n          if (touches[i].pointerId === e.pointerId) {\n            touches.splice(i, 1);\n            break;\n          }\n        }\n        e.touches = touches.slice();\n        e.changedTouches = [e];\n        handler(e);\n      };\n      obj[pre + 'touchend' + id] = cb;\n      obj.addEventListener(this.POINTER_UP, cb, false);\n      obj.addEventListener(this.POINTER_CANCEL, cb, false);\n      return this;\n    },\n    removePointerListener: function removePointerListener(obj, type, id) {\n      var pre = '_leaflet_',\n        cb = obj[pre + type + id];\n      switch (type) {\n        case 'touchstart':\n          obj.removeEventListener(this.POINTER_DOWN, cb, false);\n          break;\n        case 'touchmove':\n          obj.removeEventListener(this.POINTER_MOVE, cb, false);\n          break;\n        case 'touchend':\n          obj.removeEventListener(this.POINTER_UP, cb, false);\n          obj.removeEventListener(this.POINTER_CANCEL, cb, false);\n          break;\n      }\n      return this;\n    }\n  });\n\n  /*\n  * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n  */\n\n  L.Map.mergeOptions({\n    touchZoom: L.Browser.touch && !L.Browser.android23,\n    bounceAtZoomLimits: true\n  });\n  L.Map.TouchZoom = L.Handler.extend({\n    addHooks: function addHooks() {\n      L.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);\n    },\n    removeHooks: function removeHooks() {\n      L.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);\n    },\n    _onTouchStart: function _onTouchStart(e) {\n      var map = this._map;\n      if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {\n        return;\n      }\n      var p1 = map.mouseEventToLayerPoint(e.touches[0]),\n        p2 = map.mouseEventToLayerPoint(e.touches[1]),\n        viewCenter = map._getCenterLayerPoint();\n      this._startCenter = p1.add(p2)._divideBy(2);\n      this._startDist = p1.distanceTo(p2);\n      this._moved = false;\n      this._zooming = true;\n      this._centerOffset = viewCenter.subtract(this._startCenter);\n      if (map._panAnim) {\n        map._panAnim.stop();\n      }\n      L.DomEvent.on(document, 'touchmove', this._onTouchMove, this).on(document, 'touchend', this._onTouchEnd, this);\n      L.DomEvent.preventDefault(e);\n    },\n    _onTouchMove: function _onTouchMove(e) {\n      var map = this._map;\n      if (!e.touches || e.touches.length !== 2 || !this._zooming) {\n        return;\n      }\n      var p1 = map.mouseEventToLayerPoint(e.touches[0]),\n        p2 = map.mouseEventToLayerPoint(e.touches[1]);\n      this._scale = p1.distanceTo(p2) / this._startDist;\n      this._delta = p1._add(p2)._divideBy(2)._subtract(this._startCenter);\n      if (this._scale === 1) {\n        return;\n      }\n      if (!map.options.bounceAtZoomLimits) {\n        if (map.getZoom() === map.getMinZoom() && this._scale < 1 || map.getZoom() === map.getMaxZoom() && this._scale > 1) {\n          return;\n        }\n      }\n      if (!this._moved) {\n        L.DomUtil.addClass(map._mapPane, 'leaflet-touching');\n        map.fire('movestart').fire('zoomstart');\n        this._moved = true;\n      }\n      L.Util.cancelAnimFrame(this._animRequest);\n      this._animRequest = L.Util.requestAnimFrame(this._updateOnMove, this, true, this._map._container);\n      L.DomEvent.preventDefault(e);\n    },\n    _updateOnMove: function _updateOnMove() {\n      var map = this._map,\n        origin = this._getScaleOrigin(),\n        center = map.layerPointToLatLng(origin),\n        zoom = map.getScaleZoom(this._scale);\n      map._animateZoom(center, zoom, this._startCenter, this._scale, this._delta, false, true);\n    },\n    _onTouchEnd: function _onTouchEnd() {\n      if (!this._moved || !this._zooming) {\n        this._zooming = false;\n        return;\n      }\n      var map = this._map;\n      this._zooming = false;\n      L.DomUtil.removeClass(map._mapPane, 'leaflet-touching');\n      L.Util.cancelAnimFrame(this._animRequest);\n      L.DomEvent.off(document, 'touchmove', this._onTouchMove).off(document, 'touchend', this._onTouchEnd);\n      var origin = this._getScaleOrigin(),\n        center = map.layerPointToLatLng(origin),\n        oldZoom = map.getZoom(),\n        floatZoomDelta = map.getScaleZoom(this._scale) - oldZoom,\n        roundZoomDelta = floatZoomDelta > 0 ? Math.ceil(floatZoomDelta) : Math.floor(floatZoomDelta),\n        zoom = map._limitZoom(oldZoom + roundZoomDelta),\n        scale = map.getZoomScale(zoom) / this._scale;\n      map._animateZoom(center, zoom, origin, scale);\n    },\n    _getScaleOrigin: function _getScaleOrigin() {\n      var centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);\n      return this._startCenter.add(centerOffset);\n    }\n  });\n  L.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);\n\n  /*\n  * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.\n  */\n\n  L.Map.mergeOptions({\n    tap: true,\n    tapTolerance: 15\n  });\n  L.Map.Tap = L.Handler.extend({\n    addHooks: function addHooks() {\n      L.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);\n    },\n    removeHooks: function removeHooks() {\n      L.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);\n    },\n    _onDown: function _onDown(e) {\n      if (!e.touches) {\n        return;\n      }\n      L.DomEvent.preventDefault(e);\n      this._fireClick = true;\n\n      // don't simulate click or track longpress if more than 1 touch\n      if (e.touches.length > 1) {\n        this._fireClick = false;\n        clearTimeout(this._holdTimeout);\n        return;\n      }\n      var first = e.touches[0],\n        el = first.target;\n      this._startPos = this._newPos = new L.Point(first.clientX, first.clientY);\n\n      // if touching a link, highlight it\n      if (el.tagName && el.tagName.toLowerCase() === 'a') {\n        L.DomUtil.addClass(el, 'leaflet-active');\n      }\n\n      // simulate long hold but setting a timeout\n      this._holdTimeout = setTimeout(L.bind(function () {\n        if (this._isTapValid()) {\n          this._fireClick = false;\n          this._onUp();\n          this._simulateEvent('contextmenu', first);\n        }\n      }, this), 1000);\n      L.DomEvent.on(document, 'touchmove', this._onMove, this).on(document, 'touchend', this._onUp, this);\n    },\n    _onUp: function _onUp(e) {\n      clearTimeout(this._holdTimeout);\n      L.DomEvent.off(document, 'touchmove', this._onMove, this).off(document, 'touchend', this._onUp, this);\n      if (this._fireClick && e && e.changedTouches) {\n        var first = e.changedTouches[0],\n          el = first.target;\n        if (el && el.tagName && el.tagName.toLowerCase() === 'a') {\n          L.DomUtil.removeClass(el, 'leaflet-active');\n        }\n\n        // simulate click if the touch didn't move too much\n        if (this._isTapValid()) {\n          this._simulateEvent('click', first);\n        }\n      }\n    },\n    _isTapValid: function _isTapValid() {\n      return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n    },\n    _onMove: function _onMove(e) {\n      var first = e.touches[0];\n      this._newPos = new L.Point(first.clientX, first.clientY);\n    },\n    _simulateEvent: function _simulateEvent(type, e) {\n      var simulatedEvent = document.createEvent('MouseEvents');\n      simulatedEvent._simulated = true;\n      e.target._simulatedClick = true;\n      simulatedEvent.initMouseEvent(type, true, true, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, false, false, false, false, 0, null);\n      e.target.dispatchEvent(simulatedEvent);\n    }\n  });\n  if (L.Browser.touch && !L.Browser.pointer) {\n    L.Map.addInitHook('addHandler', 'tap', L.Map.Tap);\n  }\n\n  /*\n  * L.Handler.ShiftDragZoom is used to add shift-drag zoom interaction to the map\n  * (zoom to a selected bounding box), enabled by default.\n  */\n\n  L.Map.mergeOptions({\n    boxZoom: true\n  });\n  L.Map.BoxZoom = L.Handler.extend({\n    initialize: function initialize(map) {\n      this._map = map;\n      this._container = map._container;\n      this._pane = map._panes.overlayPane;\n      this._moved = false;\n    },\n    addHooks: function addHooks() {\n      L.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);\n    },\n    removeHooks: function removeHooks() {\n      L.DomEvent.off(this._container, 'mousedown', this._onMouseDown);\n      this._moved = false;\n    },\n    moved: function moved() {\n      return this._moved;\n    },\n    _onMouseDown: function _onMouseDown(e) {\n      this._moved = false;\n      if (!e.shiftKey || e.which !== 1 && e.button !== 1) {\n        return false;\n      }\n      L.DomUtil.disableTextSelection();\n      L.DomUtil.disableImageDrag();\n      this._startLayerPoint = this._map.mouseEventToLayerPoint(e);\n      L.DomEvent.on(document, 'mousemove', this._onMouseMove, this).on(document, 'mouseup', this._onMouseUp, this).on(document, 'keydown', this._onKeyDown, this);\n    },\n    _onMouseMove: function _onMouseMove(e) {\n      if (!this._moved) {\n        this._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._pane);\n        L.DomUtil.setPosition(this._box, this._startLayerPoint);\n\n        //TODO refactor: move cursor to styles\n        this._container.style.cursor = 'crosshair';\n        this._map.fire('boxzoomstart');\n      }\n      var startPoint = this._startLayerPoint,\n        box = this._box,\n        layerPoint = this._map.mouseEventToLayerPoint(e),\n        offset = layerPoint.subtract(startPoint),\n        newPos = new L.Point(Math.min(layerPoint.x, startPoint.x), Math.min(layerPoint.y, startPoint.y));\n      L.DomUtil.setPosition(box, newPos);\n      this._moved = true;\n\n      // TODO refactor: remove hardcoded 4 pixels\n      box.style.width = Math.max(0, Math.abs(offset.x) - 4) + 'px';\n      box.style.height = Math.max(0, Math.abs(offset.y) - 4) + 'px';\n    },\n    _finish: function _finish() {\n      if (this._moved) {\n        this._pane.removeChild(this._box);\n        this._container.style.cursor = '';\n      }\n      L.DomUtil.enableTextSelection();\n      L.DomUtil.enableImageDrag();\n      L.DomEvent.off(document, 'mousemove', this._onMouseMove).off(document, 'mouseup', this._onMouseUp).off(document, 'keydown', this._onKeyDown);\n    },\n    _onMouseUp: function _onMouseUp(e) {\n      this._finish();\n      var map = this._map,\n        layerPoint = map.mouseEventToLayerPoint(e);\n      if (this._startLayerPoint.equals(layerPoint)) {\n        return;\n      }\n      var bounds = new L.LatLngBounds(map.layerPointToLatLng(this._startLayerPoint), map.layerPointToLatLng(layerPoint));\n      map.fitBounds(bounds);\n      map.fire('boxzoomend', {\n        boxZoomBounds: bounds\n      });\n    },\n    _onKeyDown: function _onKeyDown(e) {\n      if (e.keyCode === 27) {\n        this._finish();\n      }\n    }\n  });\n  L.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);\n\n  /*\n  * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n  */\n\n  L.Map.mergeOptions({\n    keyboard: true,\n    keyboardPanOffset: 80,\n    keyboardZoomOffset: 1\n  });\n  L.Map.Keyboard = L.Handler.extend({\n    keyCodes: {\n      left: [37],\n      right: [39],\n      down: [40],\n      up: [38],\n      zoomIn: [187, 107, 61, 171],\n      zoomOut: [189, 109, 173]\n    },\n    initialize: function initialize(map) {\n      this._map = map;\n      this._setPanOffset(map.options.keyboardPanOffset);\n      this._setZoomOffset(map.options.keyboardZoomOffset);\n    },\n    addHooks: function addHooks() {\n      var container = this._map._container;\n\n      // make the container focusable by tabbing\n      if (container.tabIndex === -1) {\n        container.tabIndex = '0';\n      }\n      L.DomEvent.on(container, 'focus', this._onFocus, this).on(container, 'blur', this._onBlur, this).on(container, 'mousedown', this._onMouseDown, this);\n      this._map.on('focus', this._addHooks, this).on('blur', this._removeHooks, this);\n    },\n    removeHooks: function removeHooks() {\n      this._removeHooks();\n      var container = this._map._container;\n      L.DomEvent.off(container, 'focus', this._onFocus, this).off(container, 'blur', this._onBlur, this).off(container, 'mousedown', this._onMouseDown, this);\n      this._map.off('focus', this._addHooks, this).off('blur', this._removeHooks, this);\n    },\n    _onMouseDown: function _onMouseDown() {\n      if (this._focused) {\n        return;\n      }\n      var body = document.body,\n        docEl = document.documentElement,\n        top = body.scrollTop || docEl.scrollTop,\n        left = body.scrollLeft || docEl.scrollLeft;\n      this._map._container.focus();\n      window.scrollTo(left, top);\n    },\n    _onFocus: function _onFocus() {\n      this._focused = true;\n      this._map.fire('focus');\n    },\n    _onBlur: function _onBlur() {\n      this._focused = false;\n      this._map.fire('blur');\n    },\n    _setPanOffset: function _setPanOffset(pan) {\n      var keys = this._panKeys = {},\n        codes = this.keyCodes,\n        i,\n        len;\n      for (i = 0, len = codes.left.length; i < len; i++) {\n        keys[codes.left[i]] = [-1 * pan, 0];\n      }\n      for (i = 0, len = codes.right.length; i < len; i++) {\n        keys[codes.right[i]] = [pan, 0];\n      }\n      for (i = 0, len = codes.down.length; i < len; i++) {\n        keys[codes.down[i]] = [0, pan];\n      }\n      for (i = 0, len = codes.up.length; i < len; i++) {\n        keys[codes.up[i]] = [0, -1 * pan];\n      }\n    },\n    _setZoomOffset: function _setZoomOffset(zoom) {\n      var keys = this._zoomKeys = {},\n        codes = this.keyCodes,\n        i,\n        len;\n      for (i = 0, len = codes.zoomIn.length; i < len; i++) {\n        keys[codes.zoomIn[i]] = zoom;\n      }\n      for (i = 0, len = codes.zoomOut.length; i < len; i++) {\n        keys[codes.zoomOut[i]] = -zoom;\n      }\n    },\n    _addHooks: function _addHooks() {\n      L.DomEvent.on(document, 'keydown', this._onKeyDown, this);\n    },\n    _removeHooks: function _removeHooks() {\n      L.DomEvent.off(document, 'keydown', this._onKeyDown, this);\n    },\n    _onKeyDown: function _onKeyDown(e) {\n      var key = e.keyCode,\n        map = this._map;\n      if (key in this._panKeys) {\n        if (map._panAnim && map._panAnim._inProgress) {\n          return;\n        }\n        map.panBy(this._panKeys[key]);\n        if (map.options.maxBounds) {\n          map.panInsideBounds(map.options.maxBounds);\n        }\n      } else if (key in this._zoomKeys) {\n        map.setZoom(map.getZoom() + this._zoomKeys[key]);\n      } else {\n        return;\n      }\n      L.DomEvent.stop(e);\n    }\n  });\n  L.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);\n\n  /*\n  * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n  */\n\n  L.Handler.MarkerDrag = L.Handler.extend({\n    initialize: function initialize(marker) {\n      this._marker = marker;\n    },\n    addHooks: function addHooks() {\n      var icon = this._marker._icon;\n      if (!this._draggable) {\n        this._draggable = new L.Draggable(icon, icon);\n      }\n      this._draggable.on('dragstart', this._onDragStart, this).on('drag', this._onDrag, this).on('dragend', this._onDragEnd, this);\n      this._draggable.enable();\n      L.DomUtil.addClass(this._marker._icon, 'leaflet-marker-draggable');\n    },\n    removeHooks: function removeHooks() {\n      this._draggable.off('dragstart', this._onDragStart, this).off('drag', this._onDrag, this).off('dragend', this._onDragEnd, this);\n      this._draggable.disable();\n      L.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');\n    },\n    moved: function moved() {\n      return this._draggable && this._draggable._moved;\n    },\n    _onDragStart: function _onDragStart() {\n      this._marker.closePopup().fire('movestart').fire('dragstart');\n    },\n    _onDrag: function _onDrag() {\n      var marker = this._marker,\n        shadow = marker._shadow,\n        iconPos = L.DomUtil.getPosition(marker._icon),\n        latlng = marker._map.layerPointToLatLng(iconPos);\n\n      // update shadow position\n      if (shadow) {\n        L.DomUtil.setPosition(shadow, iconPos);\n      }\n      marker._latlng = latlng;\n      marker.fire('move', {\n        latlng: latlng\n      }).fire('drag');\n    },\n    _onDragEnd: function _onDragEnd(e) {\n      this._marker.fire('moveend').fire('dragend', e);\n    }\n  });\n\n  /*\n  * L.Control is a base class for implementing map controls. Handles positioning.\n  * All other controls extend from this class.\n  */\n\n  L.Control = L.Class.extend({\n    options: {\n      position: 'topright'\n    },\n    initialize: function initialize(options) {\n      L.setOptions(this, options);\n    },\n    getPosition: function getPosition() {\n      return this.options.position;\n    },\n    setPosition: function setPosition(position) {\n      var map = this._map;\n      if (map) {\n        map.removeControl(this);\n      }\n      this.options.position = position;\n      if (map) {\n        map.addControl(this);\n      }\n      return this;\n    },\n    getContainer: function getContainer() {\n      return this._container;\n    },\n    addTo: function addTo(map) {\n      this._map = map;\n      var container = this._container = this.onAdd(map),\n        pos = this.getPosition(),\n        corner = map._controlCorners[pos];\n      L.DomUtil.addClass(container, 'leaflet-control');\n      if (pos.indexOf('bottom') !== -1) {\n        corner.insertBefore(container, corner.firstChild);\n      } else {\n        corner.appendChild(container);\n      }\n      return this;\n    },\n    removeFrom: function removeFrom(map) {\n      var pos = this.getPosition(),\n        corner = map._controlCorners[pos];\n      corner.removeChild(this._container);\n      this._map = null;\n      if (this.onRemove) {\n        this.onRemove(map);\n      }\n      return this;\n    },\n    _refocusOnMap: function _refocusOnMap() {\n      if (this._map) {\n        this._map.getContainer().focus();\n      }\n    }\n  });\n  L.control = function (options) {\n    return new L.Control(options);\n  };\n\n  // adds control-related methods to L.Map\n\n  L.Map.include({\n    addControl: function addControl(control) {\n      control.addTo(this);\n      return this;\n    },\n    removeControl: function removeControl(control) {\n      control.removeFrom(this);\n      return this;\n    },\n    _initControlPos: function _initControlPos() {\n      var corners = this._controlCorners = {},\n        l = 'leaflet-',\n        container = this._controlContainer = L.DomUtil.create('div', l + 'control-container', this._container);\n      function createCorner(vSide, hSide) {\n        var className = l + vSide + ' ' + l + hSide;\n        corners[vSide + hSide] = L.DomUtil.create('div', className, container);\n      }\n      createCorner('top', 'left');\n      createCorner('top', 'right');\n      createCorner('bottom', 'left');\n      createCorner('bottom', 'right');\n    },\n    _clearControlPos: function _clearControlPos() {\n      this._container.removeChild(this._controlContainer);\n    }\n  });\n\n  /*\n  * L.Control.Zoom is used for the default zoom buttons on the map.\n  */\n\n  L.Control.Zoom = L.Control.extend({\n    options: {\n      position: 'topleft',\n      zoomInText: '+',\n      zoomInTitle: 'Zoom in',\n      zoomOutText: '-',\n      zoomOutTitle: 'Zoom out'\n    },\n    onAdd: function onAdd(map) {\n      var zoomName = 'leaflet-control-zoom',\n        container = L.DomUtil.create('div', zoomName + ' leaflet-bar');\n      this._map = map;\n      this._zoomInButton = this._createButton(this.options.zoomInText, this.options.zoomInTitle, zoomName + '-in', container, this._zoomIn, this);\n      this._zoomOutButton = this._createButton(this.options.zoomOutText, this.options.zoomOutTitle, zoomName + '-out', container, this._zoomOut, this);\n      this._updateDisabled();\n      map.on('zoomend zoomlevelschange', this._updateDisabled, this);\n      return container;\n    },\n    onRemove: function onRemove(map) {\n      map.off('zoomend zoomlevelschange', this._updateDisabled, this);\n    },\n    _zoomIn: function _zoomIn(e) {\n      this._map.zoomIn(e.shiftKey ? 3 : 1);\n    },\n    _zoomOut: function _zoomOut(e) {\n      this._map.zoomOut(e.shiftKey ? 3 : 1);\n    },\n    _createButton: function _createButton(html, title, className, container, fn, context) {\n      var link = L.DomUtil.create('a', className, container);\n      link.innerHTML = html;\n      link.href = '#';\n      link.title = title;\n      var stop = L.DomEvent.stopPropagation;\n      L.DomEvent.on(link, 'click', stop).on(link, 'mousedown', stop).on(link, 'dblclick', stop).on(link, 'click', L.DomEvent.preventDefault).on(link, 'click', fn, context).on(link, 'click', this._refocusOnMap, context);\n      return link;\n    },\n    _updateDisabled: function _updateDisabled() {\n      var map = this._map,\n        className = 'leaflet-disabled';\n      L.DomUtil.removeClass(this._zoomInButton, className);\n      L.DomUtil.removeClass(this._zoomOutButton, className);\n      if (map._zoom === map.getMinZoom()) {\n        L.DomUtil.addClass(this._zoomOutButton, className);\n      }\n      if (map._zoom === map.getMaxZoom()) {\n        L.DomUtil.addClass(this._zoomInButton, className);\n      }\n    }\n  });\n  L.Map.mergeOptions({\n    zoomControl: true\n  });\n  L.Map.addInitHook(function () {\n    if (this.options.zoomControl) {\n      this.zoomControl = new L.Control.Zoom();\n      this.addControl(this.zoomControl);\n    }\n  });\n  L.control.zoom = function (options) {\n    return new L.Control.Zoom(options);\n  };\n\n  /*\n  * L.Control.Attribution is used for displaying attribution on the map (added by default).\n  */\n\n  L.Control.Attribution = L.Control.extend({\n    options: {\n      position: 'bottomright',\n      prefix: '<a href=\"http://leafletjs.com\" title=\"A JS library for interactive maps\">Leaflet</a>'\n    },\n    initialize: function initialize(options) {\n      L.setOptions(this, options);\n      this._attributions = {};\n    },\n    onAdd: function onAdd(map) {\n      this._container = L.DomUtil.create('div', 'leaflet-control-attribution');\n      L.DomEvent.disableClickPropagation(this._container);\n      for (var i in map._layers) {\n        if (map._layers[i].getAttribution) {\n          this.addAttribution(map._layers[i].getAttribution());\n        }\n      }\n      map.on('layeradd', this._onLayerAdd, this).on('layerremove', this._onLayerRemove, this);\n      this._update();\n      return this._container;\n    },\n    onRemove: function onRemove(map) {\n      map.off('layeradd', this._onLayerAdd).off('layerremove', this._onLayerRemove);\n    },\n    setPrefix: function setPrefix(prefix) {\n      this.options.prefix = prefix;\n      this._update();\n      return this;\n    },\n    addAttribution: function addAttribution(text) {\n      if (!text) {\n        return;\n      }\n      if (!this._attributions[text]) {\n        this._attributions[text] = 0;\n      }\n      this._attributions[text]++;\n      this._update();\n      return this;\n    },\n    removeAttribution: function removeAttribution(text) {\n      if (!text) {\n        return;\n      }\n      if (this._attributions[text]) {\n        this._attributions[text]--;\n        this._update();\n      }\n      return this;\n    },\n    _update: function _update() {\n      if (!this._map) {\n        return;\n      }\n      var attribs = [];\n      for (var i in this._attributions) {\n        if (this._attributions[i]) {\n          attribs.push(i);\n        }\n      }\n      var prefixAndAttribs = [];\n      if (this.options.prefix) {\n        prefixAndAttribs.push(this.options.prefix);\n      }\n      if (attribs.length) {\n        prefixAndAttribs.push(attribs.join(', '));\n      }\n      this._container.innerHTML = prefixAndAttribs.join(' | ');\n    },\n    _onLayerAdd: function _onLayerAdd(e) {\n      if (e.layer.getAttribution) {\n        this.addAttribution(e.layer.getAttribution());\n      }\n    },\n    _onLayerRemove: function _onLayerRemove(e) {\n      if (e.layer.getAttribution) {\n        this.removeAttribution(e.layer.getAttribution());\n      }\n    }\n  });\n  L.Map.mergeOptions({\n    attributionControl: true\n  });\n  L.Map.addInitHook(function () {\n    if (this.options.attributionControl) {\n      this.attributionControl = new L.Control.Attribution().addTo(this);\n    }\n  });\n  L.control.attribution = function (options) {\n    return new L.Control.Attribution(options);\n  };\n\n  /*\n  * L.Control.Scale is used for displaying metric/imperial scale on the map.\n  */\n\n  L.Control.Scale = L.Control.extend({\n    options: {\n      position: 'bottomleft',\n      maxWidth: 100,\n      metric: true,\n      imperial: true,\n      updateWhenIdle: false\n    },\n    onAdd: function onAdd(map) {\n      this._map = map;\n      var className = 'leaflet-control-scale',\n        container = L.DomUtil.create('div', className),\n        options = this.options;\n      this._addScales(options, className, container);\n      map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n      map.whenReady(this._update, this);\n      return container;\n    },\n    onRemove: function onRemove(map) {\n      map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n    },\n    _addScales: function _addScales(options, className, container) {\n      if (options.metric) {\n        this._mScale = L.DomUtil.create('div', className + '-line', container);\n      }\n      if (options.imperial) {\n        this._iScale = L.DomUtil.create('div', className + '-line', container);\n      }\n    },\n    _update: function _update() {\n      var bounds = this._map.getBounds(),\n        centerLat = bounds.getCenter().lat,\n        halfWorldMeters = 6378137 * Math.PI * Math.cos(centerLat * Math.PI / 180),\n        dist = halfWorldMeters * (bounds.getNorthEast().lng - bounds.getSouthWest().lng) / 180,\n        size = this._map.getSize(),\n        options = this.options,\n        maxMeters = 0;\n      if (size.x > 0) {\n        maxMeters = dist * (options.maxWidth / size.x);\n      }\n      this._updateScales(options, maxMeters);\n    },\n    _updateScales: function _updateScales(options, maxMeters) {\n      if (options.metric && maxMeters) {\n        this._updateMetric(maxMeters);\n      }\n      if (options.imperial && maxMeters) {\n        this._updateImperial(maxMeters);\n      }\n    },\n    _updateMetric: function _updateMetric(maxMeters) {\n      var meters = this._getRoundNum(maxMeters);\n      this._mScale.style.width = this._getScaleWidth(meters / maxMeters) + 'px';\n      this._mScale.innerHTML = meters < 1000 ? meters + ' m' : meters / 1000 + ' km';\n    },\n    _updateImperial: function _updateImperial(maxMeters) {\n      var maxFeet = maxMeters * 3.2808399,\n        scale = this._iScale,\n        maxMiles,\n        miles,\n        feet;\n      if (maxFeet > 5280) {\n        maxMiles = maxFeet / 5280;\n        miles = this._getRoundNum(maxMiles);\n        scale.style.width = this._getScaleWidth(miles / maxMiles) + 'px';\n        scale.innerHTML = miles + ' mi';\n      } else {\n        feet = this._getRoundNum(maxFeet);\n        scale.style.width = this._getScaleWidth(feet / maxFeet) + 'px';\n        scale.innerHTML = feet + ' ft';\n      }\n    },\n    _getScaleWidth: function _getScaleWidth(ratio) {\n      return Math.round(this.options.maxWidth * ratio) - 10;\n    },\n    _getRoundNum: function _getRoundNum(num) {\n      var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),\n        d = num / pow10;\n      d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;\n      return pow10 * d;\n    }\n  });\n  L.control.scale = function (options) {\n    return new L.Control.Scale(options);\n  };\n\n  /*\n  * L.Control.Layers is a control to allow users to switch between different layers on the map.\n  */\n\n  L.Control.Layers = L.Control.extend({\n    options: {\n      collapsed: true,\n      position: 'topright',\n      autoZIndex: true\n    },\n    initialize: function initialize(baseLayers, overlays, options) {\n      L.setOptions(this, options);\n      this._layers = {};\n      this._lastZIndex = 0;\n      this._handlingClick = false;\n      for (var i in baseLayers) {\n        this._addLayer(baseLayers[i], i);\n      }\n      for (i in overlays) {\n        this._addLayer(overlays[i], i, true);\n      }\n    },\n    onAdd: function onAdd(map) {\n      this._initLayout();\n      this._update();\n      map.on('layeradd', this._onLayerChange, this).on('layerremove', this._onLayerChange, this);\n      return this._container;\n    },\n    onRemove: function onRemove(map) {\n      map.off('layeradd', this._onLayerChange, this).off('layerremove', this._onLayerChange, this);\n    },\n    addBaseLayer: function addBaseLayer(layer, name) {\n      this._addLayer(layer, name);\n      this._update();\n      return this;\n    },\n    addOverlay: function addOverlay(layer, name) {\n      this._addLayer(layer, name, true);\n      this._update();\n      return this;\n    },\n    removeLayer: function removeLayer(layer) {\n      var id = L.stamp(layer);\n      delete this._layers[id];\n      this._update();\n      return this;\n    },\n    _initLayout: function _initLayout() {\n      var className = 'leaflet-control-layers',\n        container = this._container = L.DomUtil.create('div', className);\n\n      //Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released\n      container.setAttribute('aria-haspopup', true);\n      if (!L.Browser.touch) {\n        L.DomEvent.disableClickPropagation(container).disableScrollPropagation(container);\n      } else {\n        L.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);\n      }\n      var form = this._form = L.DomUtil.create('form', className + '-list');\n      if (this.options.collapsed) {\n        if (!L.Browser.android) {\n          L.DomEvent.on(container, 'mouseover', this._expand, this).on(container, 'mouseout', this._collapse, this);\n        }\n        var link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);\n        link.href = '#';\n        link.title = 'Layers';\n        if (L.Browser.touch) {\n          L.DomEvent.on(link, 'click', L.DomEvent.stop).on(link, 'click', this._expand, this);\n        } else {\n          L.DomEvent.on(link, 'focus', this._expand, this);\n        }\n        //Work around for Firefox android issue https://github.com/Leaflet/Leaflet/issues/2033\n        L.DomEvent.on(form, 'click', function () {\n          setTimeout(L.bind(this._onInputClick, this), 0);\n        }, this);\n        this._map.on('click', this._collapse, this);\n        // TODO keyboard accessibility\n      } else {\n        this._expand();\n      }\n      this._baseLayersList = L.DomUtil.create('div', className + '-base', form);\n      this._separator = L.DomUtil.create('div', className + '-separator', form);\n      this._overlaysList = L.DomUtil.create('div', className + '-overlays', form);\n      container.appendChild(form);\n    },\n    _addLayer: function _addLayer(layer, name, overlay) {\n      var id = L.stamp(layer);\n      this._layers[id] = {\n        layer: layer,\n        name: name,\n        overlay: overlay\n      };\n      if (this.options.autoZIndex && layer.setZIndex) {\n        this._lastZIndex++;\n        layer.setZIndex(this._lastZIndex);\n      }\n    },\n    _update: function _update() {\n      if (!this._container) {\n        return;\n      }\n      this._baseLayersList.innerHTML = '';\n      this._overlaysList.innerHTML = '';\n      var baseLayersPresent = false,\n        overlaysPresent = false,\n        i,\n        obj;\n      for (i in this._layers) {\n        obj = this._layers[i];\n        this._addItem(obj);\n        overlaysPresent = overlaysPresent || obj.overlay;\n        baseLayersPresent = baseLayersPresent || !obj.overlay;\n      }\n      this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';\n    },\n    _onLayerChange: function _onLayerChange(e) {\n      var obj = this._layers[L.stamp(e.layer)];\n      if (!obj) {\n        return;\n      }\n      if (!this._handlingClick) {\n        this._update();\n      }\n      var type = obj.overlay ? e.type === 'layeradd' ? 'overlayadd' : 'overlayremove' : e.type === 'layeradd' ? 'baselayerchange' : null;\n      if (type) {\n        this._map.fire(type, obj);\n      }\n    },\n    // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)\n    _createRadioElement: function _createRadioElement(name, checked) {\n      var radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' + name + '\"';\n      if (checked) {\n        radioHtml += ' checked=\"checked\"';\n      }\n      radioHtml += '/>';\n      var radioFragment = document.createElement('div');\n      radioFragment.innerHTML = radioHtml;\n      return radioFragment.firstChild;\n    },\n    _addItem: function _addItem(obj) {\n      var label = document.createElement('label'),\n        input,\n        checked = this._map.hasLayer(obj.layer);\n      if (obj.overlay) {\n        input = document.createElement('input');\n        input.type = 'checkbox';\n        input.className = 'leaflet-control-layers-selector';\n        input.defaultChecked = checked;\n      } else {\n        input = this._createRadioElement('leaflet-base-layers', checked);\n      }\n      input.layerId = L.stamp(obj.layer);\n      L.DomEvent.on(input, 'click', this._onInputClick, this);\n      var name = document.createElement('span');\n      name.innerHTML = ' ' + obj.name;\n      label.appendChild(input);\n      label.appendChild(name);\n      var container = obj.overlay ? this._overlaysList : this._baseLayersList;\n      container.appendChild(label);\n      return label;\n    },\n    _onInputClick: function _onInputClick() {\n      var i,\n        input,\n        obj,\n        inputs = this._form.getElementsByTagName('input'),\n        inputsLen = inputs.length;\n      this._handlingClick = true;\n      for (i = 0; i < inputsLen; i++) {\n        input = inputs[i];\n        obj = this._layers[input.layerId];\n        if (input.checked && !this._map.hasLayer(obj.layer)) {\n          this._map.addLayer(obj.layer);\n        } else if (!input.checked && this._map.hasLayer(obj.layer)) {\n          this._map.removeLayer(obj.layer);\n        }\n      }\n      this._handlingClick = false;\n      this._refocusOnMap();\n    },\n    _expand: function _expand() {\n      L.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');\n    },\n    _collapse: function _collapse() {\n      this._container.className = this._container.className.replace(' leaflet-control-layers-expanded', '');\n    }\n  });\n  L.control.layers = function (baseLayers, overlays, options) {\n    return new L.Control.Layers(baseLayers, overlays, options);\n  };\n\n  /*\n  * L.PosAnimation is used by Leaflet internally for pan animations.\n  */\n\n  L.PosAnimation = L.Class.extend({\n    includes: L.Mixin.Events,\n    run: function run(el, newPos, duration, easeLinearity) {\n      // (HTMLElement, Point[, Number, Number])\n      this.stop();\n      this._el = el;\n      this._inProgress = true;\n      this._newPos = newPos;\n      this.fire('start');\n      el.style[L.DomUtil.TRANSITION] = 'all ' + (duration || 0.25) + 's cubic-bezier(0,0,' + (easeLinearity || 0.5) + ',1)';\n      L.DomEvent.on(el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);\n      L.DomUtil.setPosition(el, newPos);\n\n      // toggle reflow, Chrome flickers for some reason if you don't do this\n      L.Util.falseFn(el.offsetWidth);\n\n      // there's no native way to track value updates of transitioned properties, so we imitate this\n      this._stepTimer = setInterval(L.bind(this._onStep, this), 50);\n    },\n    stop: function stop() {\n      if (!this._inProgress) {\n        return;\n      }\n\n      // if we just removed the transition property, the element would jump to its final position,\n      // so we need to make it stay at the current position\n\n      L.DomUtil.setPosition(this._el, this._getPos());\n      this._onTransitionEnd();\n      L.Util.falseFn(this._el.offsetWidth); // force reflow in case we are about to start a new animation\n    },\n    _onStep: function _onStep() {\n      var stepPos = this._getPos();\n      if (!stepPos) {\n        this._onTransitionEnd();\n        return;\n      }\n      // jshint camelcase: false\n      // make L.DomUtil.getPosition return intermediate position value during animation\n      this._el._leaflet_pos = stepPos;\n      this.fire('step');\n    },\n    // you can't easily get intermediate values of properties animated with CSS3 Transitions,\n    // we need to parse computed style (in case of transform it returns matrix string)\n\n    _transformRe: /([-+]?(?:\\d*\\.)?\\d+)\\D*, ([-+]?(?:\\d*\\.)?\\d+)\\D*\\)/,\n    _getPos: function _getPos() {\n      var left,\n        top,\n        matches,\n        el = this._el,\n        style = window.getComputedStyle(el);\n      if (L.Browser.any3d) {\n        matches = style[L.DomUtil.TRANSFORM].match(this._transformRe);\n        if (!matches) {\n          return;\n        }\n        left = parseFloat(matches[1]);\n        top = parseFloat(matches[2]);\n      } else {\n        left = parseFloat(style.left);\n        top = parseFloat(style.top);\n      }\n      return new L.Point(left, top, true);\n    },\n    _onTransitionEnd: function _onTransitionEnd() {\n      L.DomEvent.off(this._el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);\n      if (!this._inProgress) {\n        return;\n      }\n      this._inProgress = false;\n      this._el.style[L.DomUtil.TRANSITION] = '';\n\n      // jshint camelcase: false\n      // make sure L.DomUtil.getPosition returns the final position value after animation\n      this._el._leaflet_pos = this._newPos;\n      clearInterval(this._stepTimer);\n      this.fire('step').fire('end');\n    }\n  });\n\n  /*\n  * Extends L.Map to handle panning animations.\n  */\n\n  L.Map.include({\n    setView: function setView(center, zoom, options) {\n      zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\n      center = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);\n      options = options || {};\n      if (this._panAnim) {\n        this._panAnim.stop();\n      }\n      if (this._loaded && !options.reset && options !== true) {\n        if (options.animate !== undefined) {\n          options.zoom = L.extend({\n            animate: options.animate\n          }, options.zoom);\n          options.pan = L.extend({\n            animate: options.animate\n          }, options.pan);\n        }\n\n        // try animating pan or zoom\n        var animated = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);\n        if (animated) {\n          // prevent resize handler call, the view will refresh after animation anyway\n          clearTimeout(this._sizeTimer);\n          return this;\n        }\n      }\n\n      // animation didn't start, just reset the map view\n      this._resetView(center, zoom);\n      return this;\n    },\n    panBy: function panBy(offset, options) {\n      offset = L.point(offset).round();\n      options = options || {};\n      if (!offset.x && !offset.y) {\n        return this;\n      }\n      if (!this._panAnim) {\n        this._panAnim = new L.PosAnimation();\n        this._panAnim.on({\n          'step': this._onPanTransitionStep,\n          'end': this._onPanTransitionEnd\n        }, this);\n      }\n\n      // don't fire movestart if animating inertia\n      if (!options.noMoveStart) {\n        this.fire('movestart');\n      }\n\n      // animate pan unless animate: false specified\n      if (options.animate !== false) {\n        L.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');\n        var newPos = this._getMapPanePos().subtract(offset);\n        this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\n      } else {\n        this._rawPanBy(offset);\n        this.fire('move').fire('moveend');\n      }\n      return this;\n    },\n    _onPanTransitionStep: function _onPanTransitionStep() {\n      this.fire('move');\n    },\n    _onPanTransitionEnd: function _onPanTransitionEnd() {\n      L.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');\n      this.fire('moveend');\n    },\n    _tryAnimatedPan: function _tryAnimatedPan(center, options) {\n      // difference between the new and current centers in pixels\n      var offset = this._getCenterOffset(center)._floor();\n\n      // don't animate too far unless animate: true specified in options\n      if ((options && options.animate) !== true && !this.getSize().contains(offset)) {\n        return false;\n      }\n      this.panBy(offset, options);\n      return true;\n    }\n  });\n\n  /*\n  * L.PosAnimation fallback implementation that powers Leaflet pan animations\n  * in browsers that don't support CSS3 Transitions.\n  */\n\n  L.PosAnimation = L.DomUtil.TRANSITION ? L.PosAnimation : L.PosAnimation.extend({\n    run: function run(el, newPos, duration, easeLinearity) {\n      // (HTMLElement, Point[, Number, Number])\n      this.stop();\n      this._el = el;\n      this._inProgress = true;\n      this._duration = duration || 0.25;\n      this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n      this._startPos = L.DomUtil.getPosition(el);\n      this._offset = newPos.subtract(this._startPos);\n      this._startTime = +new Date();\n      this.fire('start');\n      this._animate();\n    },\n    stop: function stop() {\n      if (!this._inProgress) {\n        return;\n      }\n      this._step();\n      this._complete();\n    },\n    _animate: function _animate() {\n      // animation loop\n      this._animId = L.Util.requestAnimFrame(this._animate, this);\n      this._step();\n    },\n    _step: function _step() {\n      var elapsed = +new Date() - this._startTime,\n        duration = this._duration * 1000;\n      if (elapsed < duration) {\n        this._runFrame(this._easeOut(elapsed / duration));\n      } else {\n        this._runFrame(1);\n        this._complete();\n      }\n    },\n    _runFrame: function _runFrame(progress) {\n      var pos = this._startPos.add(this._offset.multiplyBy(progress));\n      L.DomUtil.setPosition(this._el, pos);\n      this.fire('step');\n    },\n    _complete: function _complete() {\n      L.Util.cancelAnimFrame(this._animId);\n      this._inProgress = false;\n      this.fire('end');\n    },\n    _easeOut: function _easeOut(t) {\n      return 1 - Math.pow(1 - t, this._easeOutPower);\n    }\n  });\n\n  /*\n  * Extends L.Map to handle zoom animations.\n  */\n\n  L.Map.mergeOptions({\n    zoomAnimation: true,\n    zoomAnimationThreshold: 4\n  });\n  if (L.DomUtil.TRANSITION) {\n    L.Map.addInitHook(function () {\n      // don't animate on browsers without hardware-accelerated transitions or old Android/Opera\n      this._zoomAnimated = this.options.zoomAnimation && L.DomUtil.TRANSITION && L.Browser.any3d && !L.Browser.android23 && !L.Browser.mobileOpera;\n\n      // zoom transitions run with the same duration for all layers, so if one of transitionend events\n      // happens after starting zoom animation (propagating to the map pane), we know that it ended globally\n      if (this._zoomAnimated) {\n        L.DomEvent.on(this._mapPane, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);\n      }\n    });\n  }\n  L.Map.include(!L.DomUtil.TRANSITION ? {} : {\n    _catchTransitionEnd: function _catchTransitionEnd(e) {\n      if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\n        this._onZoomTransitionEnd();\n      }\n    },\n    _nothingToAnimate: function _nothingToAnimate() {\n      return !this._container.getElementsByClassName('leaflet-zoom-animated').length;\n    },\n    _tryAnimatedZoom: function _tryAnimatedZoom(center, zoom, options) {\n      if (this._animatingZoom) {\n        return true;\n      }\n      options = options || {};\n\n      // don't animate if disabled, not supported or zoom difference is too large\n      if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {\n        return false;\n      }\n\n      // offset is the pixel coords of the zoom origin relative to the current center\n      var scale = this.getZoomScale(zoom),\n        offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale),\n        origin = this._getCenterLayerPoint()._add(offset);\n\n      // don't animate if the zoom origin isn't within one screen from the current center, unless forced\n      if (options.animate !== true && !this.getSize().contains(offset)) {\n        return false;\n      }\n      this.fire('movestart').fire('zoomstart');\n      this._animateZoom(center, zoom, origin, scale, null, true);\n      return true;\n    },\n    _animateZoom: function _animateZoom(center, zoom, origin, scale, delta, backwards, forTouchZoom) {\n      if (!forTouchZoom) {\n        this._animatingZoom = true;\n      }\n\n      // put transform transition on all layers with leaflet-zoom-animated class\n      L.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');\n\n      // remember what center/zoom to set after animation\n      this._animateToCenter = center;\n      this._animateToZoom = zoom;\n\n      // disable any dragging during animation\n      if (L.Draggable) {\n        L.Draggable._disabled = true;\n      }\n      L.Util.requestAnimFrame(function () {\n        this.fire('zoomanim', {\n          center: center,\n          zoom: zoom,\n          origin: origin,\n          scale: scale,\n          delta: delta,\n          backwards: backwards\n        });\n        // horrible hack to work around a Chrome bug https://github.com/Leaflet/Leaflet/issues/3689\n        setTimeout(L.bind(this._onZoomTransitionEnd, this), 250);\n      }, this);\n    },\n    _onZoomTransitionEnd: function _onZoomTransitionEnd() {\n      if (!this._animatingZoom) {\n        return;\n      }\n      this._animatingZoom = false;\n      L.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');\n      L.Util.requestAnimFrame(function () {\n        this._resetView(this._animateToCenter, this._animateToZoom, true, true);\n        if (L.Draggable) {\n          L.Draggable._disabled = false;\n        }\n      }, this);\n    }\n  });\n\n  /*\n  Zoom animation logic for L.TileLayer.\n  */\n\n  L.TileLayer.include({\n    _animateZoom: function _animateZoom(e) {\n      if (!this._animating) {\n        this._animating = true;\n        this._prepareBgBuffer();\n      }\n      var bg = this._bgBuffer,\n        transform = L.DomUtil.TRANSFORM,\n        initialTransform = e.delta ? L.DomUtil.getTranslateString(e.delta) : bg.style[transform],\n        scaleStr = L.DomUtil.getScaleString(e.scale, e.origin);\n      bg.style[transform] = e.backwards ? scaleStr + ' ' + initialTransform : initialTransform + ' ' + scaleStr;\n    },\n    _endZoomAnim: function _endZoomAnim() {\n      var front = this._tileContainer,\n        bg = this._bgBuffer;\n      front.style.visibility = '';\n      front.parentNode.appendChild(front); // Bring to fore\n\n      // force reflow\n      L.Util.falseFn(bg.offsetWidth);\n      var zoom = this._map.getZoom();\n      if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n        this._clearBgBuffer();\n      }\n      this._animating = false;\n    },\n    _clearBgBuffer: function _clearBgBuffer() {\n      var map = this._map;\n      if (map && !map._animatingZoom && !map.touchZoom._zooming) {\n        this._bgBuffer.innerHTML = '';\n        this._bgBuffer.style[L.DomUtil.TRANSFORM] = '';\n      }\n    },\n    _prepareBgBuffer: function _prepareBgBuffer() {\n      var front = this._tileContainer,\n        bg = this._bgBuffer;\n\n      // if foreground layer doesn't have many tiles but bg layer does,\n      // keep the existing bg layer and just zoom it some more\n\n      var bgLoaded = this._getLoadedTilesPercentage(bg),\n        frontLoaded = this._getLoadedTilesPercentage(front);\n      if (bg && bgLoaded > 0.5 && frontLoaded < 0.5) {\n        front.style.visibility = 'hidden';\n        this._stopLoadingImages(front);\n        return;\n      }\n\n      // prepare the buffer to become the front tile pane\n      bg.style.visibility = 'hidden';\n      bg.style[L.DomUtil.TRANSFORM] = '';\n\n      // switch out the current layer to be the new bg layer (and vice-versa)\n      this._tileContainer = bg;\n      bg = this._bgBuffer = front;\n      this._stopLoadingImages(bg);\n\n      //prevent bg buffer from clearing right after zoom\n      clearTimeout(this._clearBgBufferTimer);\n    },\n    _getLoadedTilesPercentage: function _getLoadedTilesPercentage(container) {\n      var tiles = container.getElementsByTagName('img'),\n        i,\n        len,\n        count = 0;\n      for (i = 0, len = tiles.length; i < len; i++) {\n        if (tiles[i].complete) {\n          count++;\n        }\n      }\n      return count / len;\n    },\n    // stops loading all tiles in the background layer\n    _stopLoadingImages: function _stopLoadingImages(container) {\n      var tiles = Array.prototype.slice.call(container.getElementsByTagName('img')),\n        i,\n        len,\n        tile;\n      for (i = 0, len = tiles.length; i < len; i++) {\n        tile = tiles[i];\n        if (!tile.complete) {\n          tile.onload = L.Util.falseFn;\n          tile.onerror = L.Util.falseFn;\n          tile.src = L.Util.emptyImageUrl;\n          tile.parentNode.removeChild(tile);\n        }\n      }\n    }\n  });\n\n  /*\n  * Provides L.Map with convenient shortcuts for using browser geolocation features.\n  */\n\n  L.Map.include({\n    _defaultLocateOptions: {\n      watch: false,\n      setView: false,\n      maxZoom: Infinity,\n      timeout: 10000,\n      maximumAge: 0,\n      enableHighAccuracy: false\n    },\n    locate: function locate( /*Object*/options) {\n      options = this._locateOptions = L.extend(this._defaultLocateOptions, options);\n      if (!navigator.geolocation) {\n        this._handleGeolocationError({\n          code: 0,\n          message: 'Geolocation not supported.'\n        });\n        return this;\n      }\n      var onResponse = L.bind(this._handleGeolocationResponse, this),\n        onError = L.bind(this._handleGeolocationError, this);\n      if (options.watch) {\n        this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);\n      } else {\n        navigator.geolocation.getCurrentPosition(onResponse, onError, options);\n      }\n      return this;\n    },\n    stopLocate: function stopLocate() {\n      if (navigator.geolocation) {\n        navigator.geolocation.clearWatch(this._locationWatchId);\n      }\n      if (this._locateOptions) {\n        this._locateOptions.setView = false;\n      }\n      return this;\n    },\n    _handleGeolocationError: function _handleGeolocationError(error) {\n      var c = error.code,\n        message = error.message || (c === 1 ? 'permission denied' : c === 2 ? 'position unavailable' : 'timeout');\n      if (this._locateOptions.setView && !this._loaded) {\n        this.fitWorld();\n      }\n      this.fire('locationerror', {\n        code: c,\n        message: 'Geolocation error: ' + message + '.'\n      });\n    },\n    _handleGeolocationResponse: function _handleGeolocationResponse(pos) {\n      var lat = pos.coords.latitude,\n        lng = pos.coords.longitude,\n        latlng = new L.LatLng(lat, lng),\n        latAccuracy = 180 * pos.coords.accuracy / 40075017,\n        lngAccuracy = latAccuracy / Math.cos(L.LatLng.DEG_TO_RAD * lat),\n        bounds = L.latLngBounds([lat - latAccuracy, lng - lngAccuracy], [lat + latAccuracy, lng + lngAccuracy]),\n        options = this._locateOptions;\n      if (options.setView) {\n        var zoom = Math.min(this.getBoundsZoom(bounds), options.maxZoom);\n        this.setView(latlng, zoom);\n      }\n      var data = {\n        latlng: latlng,\n        bounds: bounds,\n        timestamp: pos.timestamp\n      };\n      for (var i in pos.coords) {\n        if (typeof pos.coords[i] === 'number') {\n          data[i] = pos.coords[i];\n        }\n      }\n      this.fire('locationfound', data);\n    }\n  });\n})(window, document);","/*\n Leaflet.markercluster, Provides Beautiful Animated Marker Clustering functionality for Leaflet, a JS library for interactive maps.\n https://github.com/Leaflet/Leaflet.markercluster\n (c) 2012-2013, Dave Leaver, smartrak\n*/\n!function (t, e) {\n  L.MarkerClusterGroup = L.FeatureGroup.extend({\n    options: {\n      maxClusterRadius: 80,\n      iconCreateFunction: null,\n      spiderfyOnMaxZoom: !0,\n      showCoverageOnHover: !0,\n      zoomToBoundsOnClick: !0,\n      singleMarkerMode: !1,\n      disableClusteringAtZoom: null,\n      removeOutsideVisibleBounds: !0,\n      animateAddingMarkers: !1,\n      spiderfyDistanceMultiplier: 1,\n      chunkedLoading: !1,\n      chunkInterval: 200,\n      chunkDelay: 50,\n      chunkProgress: null,\n      polygonOptions: {}\n    },\n    initialize: function initialize(t) {\n      L.Util.setOptions(this, t), this.options.iconCreateFunction || (this.options.iconCreateFunction = this._defaultIconCreateFunction), this._featureGroup = L.featureGroup(), this._featureGroup.on(L.FeatureGroup.EVENTS, this._propagateEvent, this), this._nonPointGroup = L.featureGroup(), this._nonPointGroup.on(L.FeatureGroup.EVENTS, this._propagateEvent, this), this._inZoomAnimation = 0, this._needsClustering = [], this._needsRemoving = [], this._currentShownBounds = null, this._queue = [];\n    },\n    addLayer: function addLayer(t) {\n      if (t instanceof L.LayerGroup) {\n        var e = [];\n        for (var i in t._layers) e.push(t._layers[i]);\n        return this.addLayers(e);\n      }\n      if (!t.getLatLng) return this._nonPointGroup.addLayer(t), this;\n      if (!this._map) return this._needsClustering.push(t), this;\n      if (this.hasLayer(t)) return this;\n      this._unspiderfy && this._unspiderfy(), this._addLayer(t, this._maxZoom);\n      var n = t,\n        s = this._map.getZoom();\n      if (t.__parent) for (; n.__parent._zoom >= s;) n = n.__parent;\n      return this._currentShownBounds.contains(n.getLatLng()) && (this.options.animateAddingMarkers ? this._animationAddLayer(t, n) : this._animationAddLayerNonAnimated(t, n)), this;\n    },\n    removeLayer: function removeLayer(t) {\n      if (t instanceof L.LayerGroup) {\n        var e = [];\n        for (var i in t._layers) e.push(t._layers[i]);\n        return this.removeLayers(e);\n      }\n      return t.getLatLng ? this._map ? t.__parent ? (this._unspiderfy && (this._unspiderfy(), this._unspiderfyLayer(t)), this._removeLayer(t, !0), this._featureGroup.hasLayer(t) && (this._featureGroup.removeLayer(t), t.setOpacity && t.setOpacity(1)), this) : this : (!this._arraySplice(this._needsClustering, t) && this.hasLayer(t) && this._needsRemoving.push(t), this) : (this._nonPointGroup.removeLayer(t), this);\n    },\n    addLayers: function addLayers(t) {\n      var e,\n        i,\n        n,\n        s,\n        r = this._featureGroup,\n        o = this._nonPointGroup,\n        a = this.options.chunkedLoading,\n        h = this.options.chunkInterval,\n        _ = this.options.chunkProgress;\n      if (this._map) {\n        var u = 0,\n          l = new Date().getTime(),\n          d = L.bind(function () {\n            for (var e = new Date().getTime(); u < t.length; u++) {\n              if (a && 0 === u % 200) {\n                var i = new Date().getTime() - e;\n                if (i > h) break;\n              }\n              if (s = t[u], s.getLatLng) {\n                if (!this.hasLayer(s) && (this._addLayer(s, this._maxZoom), s.__parent && 2 === s.__parent.getChildCount())) {\n                  var n = s.__parent.getAllChildMarkers(),\n                    p = n[0] === s ? n[1] : n[0];\n                  r.removeLayer(p);\n                }\n              } else o.addLayer(s);\n            }\n            _ && _(u, t.length, new Date().getTime() - l), u === t.length ? (this._featureGroup.eachLayer(function (t) {\n              t instanceof L.MarkerCluster && t._iconNeedsUpdate && t._updateIcon();\n            }), this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds)) : setTimeout(d, this.options.chunkDelay);\n          }, this);\n        d();\n      } else {\n        for (e = [], i = 0, n = t.length; n > i; i++) s = t[i], s.getLatLng ? this.hasLayer(s) || e.push(s) : o.addLayer(s);\n        this._needsClustering = this._needsClustering.concat(e);\n      }\n      return this;\n    },\n    removeLayers: function removeLayers(t) {\n      var e,\n        i,\n        n,\n        s = this._featureGroup,\n        r = this._nonPointGroup;\n      if (!this._map) {\n        for (e = 0, i = t.length; i > e; e++) n = t[e], this._arraySplice(this._needsClustering, n), r.removeLayer(n);\n        return this;\n      }\n      for (e = 0, i = t.length; i > e; e++) n = t[e], n.__parent ? (this._removeLayer(n, !0, !0), s.hasLayer(n) && (s.removeLayer(n), n.setOpacity && n.setOpacity(1))) : r.removeLayer(n);\n      return this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds), s.eachLayer(function (t) {\n        t instanceof L.MarkerCluster && t._updateIcon();\n      }), this;\n    },\n    clearLayers: function clearLayers() {\n      return this._map || (this._needsClustering = [], delete this._gridClusters, delete this._gridUnclustered), this._noanimationUnspiderfy && this._noanimationUnspiderfy(), this._featureGroup.clearLayers(), this._nonPointGroup.clearLayers(), this.eachLayer(function (t) {\n        delete t.__parent;\n      }), this._map && this._generateInitialClusters(), this;\n    },\n    getBounds: function getBounds() {\n      var t = new L.LatLngBounds();\n      this._topClusterLevel && t.extend(this._topClusterLevel._bounds);\n      for (var e = this._needsClustering.length - 1; e >= 0; e--) t.extend(this._needsClustering[e].getLatLng());\n      return t.extend(this._nonPointGroup.getBounds()), t;\n    },\n    eachLayer: function eachLayer(t, e) {\n      var i,\n        n = this._needsClustering.slice();\n      for (this._topClusterLevel && this._topClusterLevel.getAllChildMarkers(n), i = n.length - 1; i >= 0; i--) t.call(e, n[i]);\n      this._nonPointGroup.eachLayer(t, e);\n    },\n    getLayers: function getLayers() {\n      var t = [];\n      return this.eachLayer(function (e) {\n        t.push(e);\n      }), t;\n    },\n    getLayer: function getLayer(t) {\n      var e = null;\n      return this.eachLayer(function (i) {\n        L.stamp(i) === t && (e = i);\n      }), e;\n    },\n    hasLayer: function hasLayer(t) {\n      if (!t) return !1;\n      var e,\n        i = this._needsClustering;\n      for (e = i.length - 1; e >= 0; e--) if (i[e] === t) return !0;\n      for (i = this._needsRemoving, e = i.length - 1; e >= 0; e--) if (i[e] === t) return !1;\n      return !(!t.__parent || t.__parent._group !== this) || this._nonPointGroup.hasLayer(t);\n    },\n    zoomToShowLayer: function zoomToShowLayer(t, e) {\n      var i = function i() {\n        if ((t._icon || t.__parent._icon) && !this._inZoomAnimation) if (this._map.off(\"moveend\", i, this), this.off(\"animationend\", i, this), t._icon) e();else if (t.__parent._icon) {\n          var n = function n() {\n            this.off(\"spiderfied\", n, this), e();\n          };\n          this.on(\"spiderfied\", n, this), t.__parent.spiderfy();\n        }\n      };\n      if (t._icon && this._map.getBounds().contains(t.getLatLng())) e();else if (t.__parent._zoom < this._map.getZoom()) this._map.on(\"moveend\", i, this), this._map.panTo(t.getLatLng());else {\n        var _n = function n() {\n          this._map.off(\"movestart\", _n, this), _n = null;\n        };\n        this._map.on(\"movestart\", _n, this), this._map.on(\"moveend\", i, this), this.on(\"animationend\", i, this), t.__parent.zoomToBounds(), _n && i.call(this);\n      }\n    },\n    onAdd: function onAdd(t) {\n      this._map = t;\n      var e, i, n;\n      if (!isFinite(this._map.getMaxZoom())) throw \"Map has no maxZoom specified\";\n      for (this._featureGroup.onAdd(t), this._nonPointGroup.onAdd(t), this._gridClusters || this._generateInitialClusters(), e = 0, i = this._needsRemoving.length; i > e; e++) n = this._needsRemoving[e], this._removeLayer(n, !0);\n      this._needsRemoving = [], this._zoom = this._map.getZoom(), this._currentShownBounds = this._getExpandedVisibleBounds(), this._map.on(\"zoomend\", this._zoomEnd, this), this._map.on(\"moveend\", this._moveEnd, this), this._spiderfierOnAdd && this._spiderfierOnAdd(), this._bindEvents(), i = this._needsClustering, this._needsClustering = [], this.addLayers(i);\n    },\n    onRemove: function onRemove(t) {\n      t.off(\"zoomend\", this._zoomEnd, this), t.off(\"moveend\", this._moveEnd, this), this._unbindEvents(), this._map._mapPane.className = this._map._mapPane.className.replace(\" leaflet-cluster-anim\", \"\"), this._spiderfierOnRemove && this._spiderfierOnRemove(), this._hideCoverage(), this._featureGroup.onRemove(t), this._nonPointGroup.onRemove(t), this._featureGroup.clearLayers(), this._map = null;\n    },\n    getVisibleParent: function getVisibleParent(t) {\n      for (var e = t; e && !e._icon;) e = e.__parent;\n      return e || null;\n    },\n    _arraySplice: function _arraySplice(t, e) {\n      for (var i = t.length - 1; i >= 0; i--) if (t[i] === e) return t.splice(i, 1), !0;\n    },\n    _removeLayer: function _removeLayer(t, e, i) {\n      var n = this._gridClusters,\n        s = this._gridUnclustered,\n        r = this._featureGroup,\n        o = this._map;\n      if (e) for (var a = this._maxZoom; a >= 0 && s[a].removeObject(t, o.project(t.getLatLng(), a)); a--);\n      var h,\n        _ = t.__parent,\n        u = _._markers;\n      for (this._arraySplice(u, t); _ && (_._childCount--, !(_._zoom < 0));) e && _._childCount <= 1 ? (h = _._markers[0] === t ? _._markers[1] : _._markers[0], n[_._zoom].removeObject(_, o.project(_._cLatLng, _._zoom)), s[_._zoom].addObject(h, o.project(h.getLatLng(), _._zoom)), this._arraySplice(_.__parent._childClusters, _), _.__parent._markers.push(h), h.__parent = _.__parent, _._icon && (r.removeLayer(_), i || r.addLayer(h))) : (_._recalculateBounds(), i && _._icon || _._updateIcon()), _ = _.__parent;\n      delete t.__parent;\n    },\n    _isOrIsParent: function _isOrIsParent(t, e) {\n      for (; e;) {\n        if (t === e) return !0;\n        e = e.parentNode;\n      }\n      return !1;\n    },\n    _propagateEvent: function _propagateEvent(t) {\n      if (t.layer instanceof L.MarkerCluster) {\n        if (t.originalEvent && this._isOrIsParent(t.layer._icon, t.originalEvent.relatedTarget)) return;\n        t.type = \"cluster\" + t.type;\n      }\n      this.fire(t.type, t);\n    },\n    _defaultIconCreateFunction: function _defaultIconCreateFunction(t) {\n      var e = t.getChildCount(),\n        i = \" marker-cluster-\";\n      return i += 10 > e ? \"small\" : 100 > e ? \"medium\" : \"large\", new L.DivIcon({\n        html: \"<div><span>\" + e + \"</span></div>\",\n        className: \"marker-cluster\" + i,\n        iconSize: new L.Point(40, 40)\n      });\n    },\n    _bindEvents: function _bindEvents() {\n      var t = this._map,\n        e = this.options.spiderfyOnMaxZoom,\n        i = this.options.showCoverageOnHover,\n        n = this.options.zoomToBoundsOnClick;\n      (e || n) && this.on(\"clusterclick\", this._zoomOrSpiderfy, this), i && (this.on(\"clustermouseover\", this._showCoverage, this), this.on(\"clustermouseout\", this._hideCoverage, this), t.on(\"zoomend\", this._hideCoverage, this));\n    },\n    _zoomOrSpiderfy: function _zoomOrSpiderfy(t) {\n      var e = this._map;\n      e.getMaxZoom() === e.getZoom() ? this.options.spiderfyOnMaxZoom && t.layer.spiderfy() : this.options.zoomToBoundsOnClick && t.layer.zoomToBounds(), t.originalEvent && 13 === t.originalEvent.keyCode && e._container.focus();\n    },\n    _showCoverage: function _showCoverage(t) {\n      var e = this._map;\n      this._inZoomAnimation || (this._shownPolygon && e.removeLayer(this._shownPolygon), t.layer.getChildCount() > 2 && t.layer !== this._spiderfied && (this._shownPolygon = new L.Polygon(t.layer.getConvexHull(), this.options.polygonOptions), e.addLayer(this._shownPolygon)));\n    },\n    _hideCoverage: function _hideCoverage() {\n      this._shownPolygon && (this._map.removeLayer(this._shownPolygon), this._shownPolygon = null);\n    },\n    _unbindEvents: function _unbindEvents() {\n      var t = this.options.spiderfyOnMaxZoom,\n        e = this.options.showCoverageOnHover,\n        i = this.options.zoomToBoundsOnClick,\n        n = this._map;\n      (t || i) && this.off(\"clusterclick\", this._zoomOrSpiderfy, this), e && (this.off(\"clustermouseover\", this._showCoverage, this), this.off(\"clustermouseout\", this._hideCoverage, this), n.off(\"zoomend\", this._hideCoverage, this));\n    },\n    _zoomEnd: function _zoomEnd() {\n      this._map && (this._mergeSplitClusters(), this._zoom = this._map._zoom, this._currentShownBounds = this._getExpandedVisibleBounds());\n    },\n    _moveEnd: function _moveEnd() {\n      if (!this._inZoomAnimation) {\n        var t = this._getExpandedVisibleBounds();\n        this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, this._zoom, t), this._topClusterLevel._recursivelyAddChildrenToMap(null, this._map._zoom, t), this._currentShownBounds = t;\n      }\n    },\n    _generateInitialClusters: function _generateInitialClusters() {\n      var t = this._map.getMaxZoom(),\n        e = this.options.maxClusterRadius,\n        i = e;\n      \"function\" != typeof e && (i = function i() {\n        return e;\n      }), this.options.disableClusteringAtZoom && (t = this.options.disableClusteringAtZoom - 1), this._maxZoom = t, this._gridClusters = {}, this._gridUnclustered = {};\n      for (var n = t; n >= 0; n--) this._gridClusters[n] = new L.DistanceGrid(i(n)), this._gridUnclustered[n] = new L.DistanceGrid(i(n));\n      this._topClusterLevel = new L.MarkerCluster(this, -1);\n    },\n    _addLayer: function _addLayer(t, e) {\n      var i,\n        n,\n        s = this._gridClusters,\n        r = this._gridUnclustered;\n      for (this.options.singleMarkerMode && (t.options.icon = this.options.iconCreateFunction({\n        getChildCount: function getChildCount() {\n          return 1;\n        },\n        getAllChildMarkers: function getAllChildMarkers() {\n          return [t];\n        }\n      })); e >= 0; e--) {\n        i = this._map.project(t.getLatLng(), e);\n        var o = s[e].getNearObject(i);\n        if (o) return o._addChild(t), t.__parent = o, void 0;\n        if (o = r[e].getNearObject(i)) {\n          var a = o.__parent;\n          a && this._removeLayer(o, !1);\n          var h = new L.MarkerCluster(this, e, o, t);\n          s[e].addObject(h, this._map.project(h._cLatLng, e)), o.__parent = h, t.__parent = h;\n          var _ = h;\n          for (n = e - 1; n > a._zoom; n--) _ = new L.MarkerCluster(this, n, _), s[n].addObject(_, this._map.project(o.getLatLng(), n));\n          for (a._addChild(_), n = e; n >= 0 && r[n].removeObject(o, this._map.project(o.getLatLng(), n)); n--);\n          return;\n        }\n        r[e].addObject(t, i);\n      }\n      this._topClusterLevel._addChild(t), t.__parent = this._topClusterLevel;\n    },\n    _enqueue: function _enqueue(t) {\n      this._queue.push(t), this._queueTimeout || (this._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300));\n    },\n    _processQueue: function _processQueue() {\n      for (var t = 0; t < this._queue.length; t++) this._queue[t].call(this);\n      this._queue.length = 0, clearTimeout(this._queueTimeout), this._queueTimeout = null;\n    },\n    _mergeSplitClusters: function _mergeSplitClusters() {\n      this._processQueue(), this._zoom < this._map._zoom && this._currentShownBounds.intersects(this._getExpandedVisibleBounds()) ? (this._animationStart(), this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, this._zoom, this._getExpandedVisibleBounds()), this._animationZoomIn(this._zoom, this._map._zoom)) : this._zoom > this._map._zoom ? (this._animationStart(), this._animationZoomOut(this._zoom, this._map._zoom)) : this._moveEnd();\n    },\n    _getExpandedVisibleBounds: function _getExpandedVisibleBounds() {\n      if (!this.options.removeOutsideVisibleBounds) return this._map.getBounds();\n      var t = this._map,\n        e = t.getBounds(),\n        i = e._southWest,\n        n = e._northEast,\n        s = L.Browser.mobile ? 0 : Math.abs(i.lat - n.lat),\n        r = L.Browser.mobile ? 0 : Math.abs(i.lng - n.lng);\n      return new L.LatLngBounds(new L.LatLng(i.lat - s, i.lng - r, !0), new L.LatLng(n.lat + s, n.lng + r, !0));\n    },\n    _animationAddLayerNonAnimated: function _animationAddLayerNonAnimated(t, e) {\n      if (e === t) this._featureGroup.addLayer(t);else if (2 === e._childCount) {\n        e._addToMap();\n        var i = e.getAllChildMarkers();\n        this._featureGroup.removeLayer(i[0]), this._featureGroup.removeLayer(i[1]);\n      } else e._updateIcon();\n    }\n  }), L.MarkerClusterGroup.include(L.DomUtil.TRANSITION ? {\n    _animationStart: function _animationStart() {\n      this._map._mapPane.className += \" leaflet-cluster-anim\", this._inZoomAnimation++;\n    },\n    _animationEnd: function _animationEnd() {\n      this._map && (this._map._mapPane.className = this._map._mapPane.className.replace(\" leaflet-cluster-anim\", \"\")), this._inZoomAnimation--, this.fire(\"animationend\");\n    },\n    _animationZoomIn: function _animationZoomIn(t, e) {\n      var i,\n        n = this._getExpandedVisibleBounds(),\n        s = this._featureGroup;\n      this._topClusterLevel._recursively(n, t, 0, function (r) {\n        var o,\n          a = r._latlng,\n          h = r._markers;\n        for (n.contains(a) || (a = null), r._isSingleParent() && t + 1 === e ? (s.removeLayer(r), r._recursivelyAddChildrenToMap(null, e, n)) : (r.setOpacity(0), r._recursivelyAddChildrenToMap(a, e, n)), i = h.length - 1; i >= 0; i--) o = h[i], n.contains(o._latlng) || s.removeLayer(o);\n      }), this._forceLayout(), this._topClusterLevel._recursivelyBecomeVisible(n, e), s.eachLayer(function (t) {\n        t instanceof L.MarkerCluster || !t._icon || t.setOpacity(1);\n      }), this._topClusterLevel._recursively(n, t, e, function (t) {\n        t._recursivelyRestoreChildPositions(e);\n      }), this._enqueue(function () {\n        this._topClusterLevel._recursively(n, t, 0, function (t) {\n          s.removeLayer(t), t.setOpacity(1);\n        }), this._animationEnd();\n      });\n    },\n    _animationZoomOut: function _animationZoomOut(t, e) {\n      this._animationZoomOutSingle(this._topClusterLevel, t - 1, e), this._topClusterLevel._recursivelyAddChildrenToMap(null, e, this._getExpandedVisibleBounds()), this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, t, this._getExpandedVisibleBounds());\n    },\n    _animationZoomOutSingle: function _animationZoomOutSingle(t, e, i) {\n      var n = this._getExpandedVisibleBounds();\n      t._recursivelyAnimateChildrenInAndAddSelfToMap(n, e + 1, i);\n      var s = this;\n      this._forceLayout(), t._recursivelyBecomeVisible(n, i), this._enqueue(function () {\n        if (1 === t._childCount) {\n          var r = t._markers[0];\n          r.setLatLng(r.getLatLng()), r.setOpacity && r.setOpacity(1);\n        } else t._recursively(n, i, 0, function (t) {\n          t._recursivelyRemoveChildrenFromMap(n, e + 1);\n        });\n        s._animationEnd();\n      });\n    },\n    _animationAddLayer: function _animationAddLayer(t, e) {\n      var i = this,\n        n = this._featureGroup;\n      n.addLayer(t), e !== t && (e._childCount > 2 ? (e._updateIcon(), this._forceLayout(), this._animationStart(), t._setPos(this._map.latLngToLayerPoint(e.getLatLng())), t.setOpacity(0), this._enqueue(function () {\n        n.removeLayer(t), t.setOpacity(1), i._animationEnd();\n      })) : (this._forceLayout(), i._animationStart(), i._animationZoomOutSingle(e, this._map.getMaxZoom(), this._map.getZoom())));\n    },\n    _forceLayout: function _forceLayout() {\n      L.Util.falseFn(e.body.offsetWidth);\n    }\n  } : {\n    _animationStart: function _animationStart() {},\n    _animationZoomIn: function _animationZoomIn(t, e) {\n      this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, t), this._topClusterLevel._recursivelyAddChildrenToMap(null, e, this._getExpandedVisibleBounds()), this.fire(\"animationend\");\n    },\n    _animationZoomOut: function _animationZoomOut(t, e) {\n      this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, t), this._topClusterLevel._recursivelyAddChildrenToMap(null, e, this._getExpandedVisibleBounds()), this.fire(\"animationend\");\n    },\n    _animationAddLayer: function _animationAddLayer(t, e) {\n      this._animationAddLayerNonAnimated(t, e);\n    }\n  }), L.markerClusterGroup = function (t) {\n    return new L.MarkerClusterGroup(t);\n  }, L.MarkerCluster = L.Marker.extend({\n    initialize: function initialize(t, e, i, n) {\n      L.Marker.prototype.initialize.call(this, i ? i._cLatLng || i.getLatLng() : new L.LatLng(0, 0), {\n        icon: this\n      }), this._group = t, this._zoom = e, this._markers = [], this._childClusters = [], this._childCount = 0, this._iconNeedsUpdate = !0, this._bounds = new L.LatLngBounds(), i && this._addChild(i), n && this._addChild(n);\n    },\n    getAllChildMarkers: function getAllChildMarkers(t) {\n      t = t || [];\n      for (var e = this._childClusters.length - 1; e >= 0; e--) this._childClusters[e].getAllChildMarkers(t);\n      for (var i = this._markers.length - 1; i >= 0; i--) t.push(this._markers[i]);\n      return t;\n    },\n    getChildCount: function getChildCount() {\n      return this._childCount;\n    },\n    zoomToBounds: function zoomToBounds() {\n      for (var t, e = this._childClusters.slice(), i = this._group._map, n = i.getBoundsZoom(this._bounds), s = this._zoom + 1, r = i.getZoom(); e.length > 0 && n > s;) {\n        s++;\n        var o = [];\n        for (t = 0; t < e.length; t++) o = o.concat(e[t]._childClusters);\n        e = o;\n      }\n      n > s ? this._group._map.setView(this._latlng, s) : r >= n ? this._group._map.setView(this._latlng, r + 1) : this._group._map.fitBounds(this._bounds);\n    },\n    getBounds: function getBounds() {\n      var t = new L.LatLngBounds();\n      return t.extend(this._bounds), t;\n    },\n    _updateIcon: function _updateIcon() {\n      this._iconNeedsUpdate = !0, this._icon && this.setIcon(this);\n    },\n    createIcon: function createIcon() {\n      return this._iconNeedsUpdate && (this._iconObj = this._group.options.iconCreateFunction(this), this._iconNeedsUpdate = !1), this._iconObj.createIcon();\n    },\n    createShadow: function createShadow() {\n      return this._iconObj.createShadow();\n    },\n    _addChild: function _addChild(t, e) {\n      this._iconNeedsUpdate = !0, this._expandBounds(t), t instanceof L.MarkerCluster ? (e || (this._childClusters.push(t), t.__parent = this), this._childCount += t._childCount) : (e || this._markers.push(t), this._childCount++), this.__parent && this.__parent._addChild(t, !0);\n    },\n    _expandBounds: function _expandBounds(t) {\n      var e,\n        i = t._wLatLng || t._latlng;\n      t instanceof L.MarkerCluster ? (this._bounds.extend(t._bounds), e = t._childCount) : (this._bounds.extend(i), e = 1), this._cLatLng || (this._cLatLng = t._cLatLng || i);\n      var n = this._childCount + e;\n      this._wLatLng ? (this._wLatLng.lat = (i.lat * e + this._wLatLng.lat * this._childCount) / n, this._wLatLng.lng = (i.lng * e + this._wLatLng.lng * this._childCount) / n) : this._latlng = this._wLatLng = new L.LatLng(i.lat, i.lng);\n    },\n    _addToMap: function _addToMap(t) {\n      t && (this._backupLatlng = this._latlng, this.setLatLng(t)), this._group._featureGroup.addLayer(this);\n    },\n    _recursivelyAnimateChildrenIn: function _recursivelyAnimateChildrenIn(t, e, i) {\n      this._recursively(t, 0, i - 1, function (t) {\n        var i,\n          n,\n          s = t._markers;\n        for (i = s.length - 1; i >= 0; i--) n = s[i], n._icon && (n._setPos(e), n.setOpacity(0));\n      }, function (t) {\n        var i,\n          n,\n          s = t._childClusters;\n        for (i = s.length - 1; i >= 0; i--) n = s[i], n._icon && (n._setPos(e), n.setOpacity(0));\n      });\n    },\n    _recursivelyAnimateChildrenInAndAddSelfToMap: function _recursivelyAnimateChildrenInAndAddSelfToMap(t, e, i) {\n      this._recursively(t, i, 0, function (n) {\n        n._recursivelyAnimateChildrenIn(t, n._group._map.latLngToLayerPoint(n.getLatLng()).round(), e), n._isSingleParent() && e - 1 === i ? (n.setOpacity(1), n._recursivelyRemoveChildrenFromMap(t, e)) : n.setOpacity(0), n._addToMap();\n      });\n    },\n    _recursivelyBecomeVisible: function _recursivelyBecomeVisible(t, e) {\n      this._recursively(t, 0, e, null, function (t) {\n        t.setOpacity(1);\n      });\n    },\n    _recursivelyAddChildrenToMap: function _recursivelyAddChildrenToMap(t, e, i) {\n      this._recursively(i, -1, e, function (n) {\n        if (e !== n._zoom) for (var s = n._markers.length - 1; s >= 0; s--) {\n          var r = n._markers[s];\n          i.contains(r._latlng) && (t && (r._backupLatlng = r.getLatLng(), r.setLatLng(t), r.setOpacity && r.setOpacity(0)), n._group._featureGroup.addLayer(r));\n        }\n      }, function (e) {\n        e._addToMap(t);\n      });\n    },\n    _recursivelyRestoreChildPositions: function _recursivelyRestoreChildPositions(t) {\n      for (var e = this._markers.length - 1; e >= 0; e--) {\n        var i = this._markers[e];\n        i._backupLatlng && (i.setLatLng(i._backupLatlng), delete i._backupLatlng);\n      }\n      if (t - 1 === this._zoom) for (var n = this._childClusters.length - 1; n >= 0; n--) this._childClusters[n]._restorePosition();else for (var s = this._childClusters.length - 1; s >= 0; s--) this._childClusters[s]._recursivelyRestoreChildPositions(t);\n    },\n    _restorePosition: function _restorePosition() {\n      this._backupLatlng && (this.setLatLng(this._backupLatlng), delete this._backupLatlng);\n    },\n    _recursivelyRemoveChildrenFromMap: function _recursivelyRemoveChildrenFromMap(t, e, i) {\n      var n, s;\n      this._recursively(t, -1, e - 1, function (t) {\n        for (s = t._markers.length - 1; s >= 0; s--) n = t._markers[s], i && i.contains(n._latlng) || (t._group._featureGroup.removeLayer(n), n.setOpacity && n.setOpacity(1));\n      }, function (t) {\n        for (s = t._childClusters.length - 1; s >= 0; s--) n = t._childClusters[s], i && i.contains(n._latlng) || (t._group._featureGroup.removeLayer(n), n.setOpacity && n.setOpacity(1));\n      });\n    },\n    _recursively: function _recursively(t, e, i, n, s) {\n      var r,\n        o,\n        a = this._childClusters,\n        h = this._zoom;\n      if (e > h) for (r = a.length - 1; r >= 0; r--) o = a[r], t.intersects(o._bounds) && o._recursively(t, e, i, n, s);else if (n && n(this), s && this._zoom === i && s(this), i > h) for (r = a.length - 1; r >= 0; r--) o = a[r], t.intersects(o._bounds) && o._recursively(t, e, i, n, s);\n    },\n    _recalculateBounds: function _recalculateBounds() {\n      var t,\n        e = this._markers,\n        i = this._childClusters;\n      for (this._bounds = new L.LatLngBounds(), delete this._wLatLng, t = e.length - 1; t >= 0; t--) this._expandBounds(e[t]);\n      for (t = i.length - 1; t >= 0; t--) this._expandBounds(i[t]);\n    },\n    _isSingleParent: function _isSingleParent() {\n      return this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;\n    }\n  }), L.DistanceGrid = function (t) {\n    this._cellSize = t, this._sqCellSize = t * t, this._grid = {}, this._objectPoint = {};\n  }, L.DistanceGrid.prototype = {\n    addObject: function addObject(t, e) {\n      var i = this._getCoord(e.x),\n        n = this._getCoord(e.y),\n        s = this._grid,\n        r = s[n] = s[n] || {},\n        o = r[i] = r[i] || [],\n        a = L.Util.stamp(t);\n      this._objectPoint[a] = e, o.push(t);\n    },\n    updateObject: function updateObject(t, e) {\n      this.removeObject(t), this.addObject(t, e);\n    },\n    removeObject: function removeObject(t, e) {\n      var i,\n        n,\n        s = this._getCoord(e.x),\n        r = this._getCoord(e.y),\n        o = this._grid,\n        a = o[r] = o[r] || {},\n        h = a[s] = a[s] || [];\n      for (delete this._objectPoint[L.Util.stamp(t)], i = 0, n = h.length; n > i; i++) if (h[i] === t) return h.splice(i, 1), 1 === n && delete a[s], !0;\n    },\n    eachObject: function eachObject(t, e) {\n      var i,\n        n,\n        s,\n        r,\n        o,\n        a,\n        h,\n        _ = this._grid;\n      for (i in _) {\n        o = _[i];\n        for (n in o) for (a = o[n], s = 0, r = a.length; r > s; s++) h = t.call(e, a[s]), h && (s--, r--);\n      }\n    },\n    getNearObject: function getNearObject(t) {\n      var e,\n        i,\n        n,\n        s,\n        r,\n        o,\n        a,\n        h,\n        _ = this._getCoord(t.x),\n        u = this._getCoord(t.y),\n        l = this._objectPoint,\n        d = this._sqCellSize,\n        p = null;\n      for (e = u - 1; u + 1 >= e; e++) if (s = this._grid[e]) for (i = _ - 1; _ + 1 >= i; i++) if (r = s[i]) for (n = 0, o = r.length; o > n; n++) a = r[n], h = this._sqDist(l[L.Util.stamp(a)], t), d > h && (d = h, p = a);\n      return p;\n    },\n    _getCoord: function _getCoord(t) {\n      return Math.floor(t / this._cellSize);\n    },\n    _sqDist: function _sqDist(t, e) {\n      var i = e.x - t.x,\n        n = e.y - t.y;\n      return i * i + n * n;\n    }\n  }, function () {\n    L.QuickHull = {\n      getDistant: function getDistant(t, e) {\n        var i = e[1].lat - e[0].lat,\n          n = e[0].lng - e[1].lng;\n        return n * (t.lat - e[0].lat) + i * (t.lng - e[0].lng);\n      },\n      findMostDistantPointFromBaseLine: function findMostDistantPointFromBaseLine(t, e) {\n        var i,\n          n,\n          s,\n          r = 0,\n          o = null,\n          a = [];\n        for (i = e.length - 1; i >= 0; i--) n = e[i], s = this.getDistant(n, t), s > 0 && (a.push(n), s > r && (r = s, o = n));\n        return {\n          maxPoint: o,\n          newPoints: a\n        };\n      },\n      buildConvexHull: function buildConvexHull(t, e) {\n        var i = [],\n          n = this.findMostDistantPointFromBaseLine(t, e);\n        return n.maxPoint ? (i = i.concat(this.buildConvexHull([t[0], n.maxPoint], n.newPoints)), i = i.concat(this.buildConvexHull([n.maxPoint, t[1]], n.newPoints))) : [t[0]];\n      },\n      getConvexHull: function getConvexHull(t) {\n        var e,\n          i = !1,\n          n = !1,\n          s = null,\n          r = null;\n        for (e = t.length - 1; e >= 0; e--) {\n          var o = t[e];\n          (i === !1 || o.lat > i) && (s = o, i = o.lat), (n === !1 || o.lat < n) && (r = o, n = o.lat);\n        }\n        var a = [].concat(this.buildConvexHull([r, s], t), this.buildConvexHull([s, r], t));\n        return a;\n      }\n    };\n  }(), L.MarkerCluster.include({\n    getConvexHull: function getConvexHull() {\n      var t,\n        e,\n        i = this.getAllChildMarkers(),\n        n = [];\n      for (e = i.length - 1; e >= 0; e--) t = i[e].getLatLng(), n.push(t);\n      return L.QuickHull.getConvexHull(n);\n    }\n  }), L.MarkerCluster.include({\n    _2PI: 2 * Math.PI,\n    _circleFootSeparation: 25,\n    _circleStartAngle: Math.PI / 6,\n    _spiralFootSeparation: 28,\n    _spiralLengthStart: 11,\n    _spiralLengthFactor: 5,\n    _circleSpiralSwitchover: 9,\n    spiderfy: function spiderfy() {\n      if (this._group._spiderfied !== this && !this._group._inZoomAnimation) {\n        var t,\n          e = this.getAllChildMarkers(),\n          i = this._group,\n          n = i._map,\n          s = n.latLngToLayerPoint(this._latlng);\n        this._group._unspiderfy(), this._group._spiderfied = this, e.length >= this._circleSpiralSwitchover ? t = this._generatePointsSpiral(e.length, s) : (s.y += 10, t = this._generatePointsCircle(e.length, s)), this._animationSpiderfy(e, t);\n      }\n    },\n    unspiderfy: function unspiderfy(t) {\n      this._group._inZoomAnimation || (this._animationUnspiderfy(t), this._group._spiderfied = null);\n    },\n    _generatePointsCircle: function _generatePointsCircle(t, e) {\n      var i,\n        n,\n        s = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + t),\n        r = s / this._2PI,\n        o = this._2PI / t,\n        a = [];\n      for (a.length = t, i = t - 1; i >= 0; i--) n = this._circleStartAngle + i * o, a[i] = new L.Point(e.x + r * Math.cos(n), e.y + r * Math.sin(n))._round();\n      return a;\n    },\n    _generatePointsSpiral: function _generatePointsSpiral(t, e) {\n      var i,\n        n = this._group.options.spiderfyDistanceMultiplier * this._spiralLengthStart,\n        s = this._group.options.spiderfyDistanceMultiplier * this._spiralFootSeparation,\n        r = this._group.options.spiderfyDistanceMultiplier * this._spiralLengthFactor,\n        o = 0,\n        a = [];\n      for (a.length = t, i = t - 1; i >= 0; i--) o += s / n + 5e-4 * i, a[i] = new L.Point(e.x + n * Math.cos(o), e.y + n * Math.sin(o))._round(), n += this._2PI * r / o;\n      return a;\n    },\n    _noanimationUnspiderfy: function _noanimationUnspiderfy() {\n      var t,\n        e,\n        i = this._group,\n        n = i._map,\n        s = i._featureGroup,\n        r = this.getAllChildMarkers();\n      for (this.setOpacity(1), e = r.length - 1; e >= 0; e--) t = r[e], s.removeLayer(t), t._preSpiderfyLatlng && (t.setLatLng(t._preSpiderfyLatlng), delete t._preSpiderfyLatlng), t.setZIndexOffset && t.setZIndexOffset(0), t._spiderLeg && (n.removeLayer(t._spiderLeg), delete t._spiderLeg);\n      i._spiderfied = null;\n    }\n  }), L.MarkerCluster.include(L.DomUtil.TRANSITION ? {\n    SVG_ANIMATION: function () {\n      return e.createElementNS(\"http://www.w3.org/2000/svg\", \"animate\").toString().indexOf(\"SVGAnimate\") > -1;\n    }(),\n    _animationSpiderfy: function _animationSpiderfy(t, i) {\n      var n,\n        s,\n        r,\n        o,\n        a = this,\n        h = this._group,\n        _ = h._map,\n        u = h._featureGroup,\n        l = _.latLngToLayerPoint(this._latlng);\n      for (n = t.length - 1; n >= 0; n--) s = t[n], s.setOpacity ? (s.setZIndexOffset(1e6), s.setOpacity(0), u.addLayer(s), s._setPos(l)) : u.addLayer(s);\n      h._forceLayout(), h._animationStart();\n      var d = L.Path.SVG ? 0 : .3,\n        p = L.Path.SVG_NS;\n      for (n = t.length - 1; n >= 0; n--) if (o = _.layerPointToLatLng(i[n]), s = t[n], s._preSpiderfyLatlng = s._latlng, s.setLatLng(o), s.setOpacity && s.setOpacity(1), r = new L.Polyline([a._latlng, o], {\n        weight: 1.5,\n        color: \"#222\",\n        opacity: d\n      }), _.addLayer(r), s._spiderLeg = r, L.Path.SVG && this.SVG_ANIMATION) {\n        var c = r._path.getTotalLength();\n        r._path.setAttribute(\"stroke-dasharray\", c + \",\" + c);\n        var f = e.createElementNS(p, \"animate\");\n        f.setAttribute(\"attributeName\", \"stroke-dashoffset\"), f.setAttribute(\"begin\", \"indefinite\"), f.setAttribute(\"from\", c), f.setAttribute(\"to\", 0), f.setAttribute(\"dur\", .25), r._path.appendChild(f), f.beginElement(), f = e.createElementNS(p, \"animate\"), f.setAttribute(\"attributeName\", \"stroke-opacity\"), f.setAttribute(\"attributeName\", \"stroke-opacity\"), f.setAttribute(\"begin\", \"indefinite\"), f.setAttribute(\"from\", 0), f.setAttribute(\"to\", .5), f.setAttribute(\"dur\", .25), r._path.appendChild(f), f.beginElement();\n      }\n      if (a.setOpacity(.3), L.Path.SVG) for (this._group._forceLayout(), n = t.length - 1; n >= 0; n--) s = t[n]._spiderLeg, s.options.opacity = .5, s._path.setAttribute(\"stroke-opacity\", .5);\n      setTimeout(function () {\n        h._animationEnd(), h.fire(\"spiderfied\");\n      }, 200);\n    },\n    _animationUnspiderfy: function _animationUnspiderfy(t) {\n      var e,\n        i,\n        n,\n        s = this._group,\n        r = s._map,\n        o = s._featureGroup,\n        a = t ? r._latLngToNewLayerPoint(this._latlng, t.zoom, t.center) : r.latLngToLayerPoint(this._latlng),\n        h = this.getAllChildMarkers(),\n        _ = L.Path.SVG && this.SVG_ANIMATION;\n      for (s._animationStart(), this.setOpacity(1), i = h.length - 1; i >= 0; i--) e = h[i], e._preSpiderfyLatlng && (e.setLatLng(e._preSpiderfyLatlng), delete e._preSpiderfyLatlng, e.setOpacity ? (e._setPos(a), e.setOpacity(0)) : o.removeLayer(e), _ && (n = e._spiderLeg._path.childNodes[0], n.setAttribute(\"to\", n.getAttribute(\"from\")), n.setAttribute(\"from\", 0), n.beginElement(), n = e._spiderLeg._path.childNodes[1], n.setAttribute(\"from\", .5), n.setAttribute(\"to\", 0), n.setAttribute(\"stroke-opacity\", 0), n.beginElement(), e._spiderLeg._path.setAttribute(\"stroke-opacity\", 0)));\n      setTimeout(function () {\n        var t = 0;\n        for (i = h.length - 1; i >= 0; i--) e = h[i], e._spiderLeg && t++;\n        for (i = h.length - 1; i >= 0; i--) e = h[i], e._spiderLeg && (e.setOpacity && (e.setOpacity(1), e.setZIndexOffset(0)), t > 1 && o.removeLayer(e), r.removeLayer(e._spiderLeg), delete e._spiderLeg);\n        s._animationEnd();\n      }, 200);\n    }\n  } : {\n    _animationSpiderfy: function _animationSpiderfy(t, e) {\n      var i,\n        n,\n        s,\n        r,\n        o = this._group,\n        a = o._map,\n        h = o._featureGroup;\n      for (i = t.length - 1; i >= 0; i--) r = a.layerPointToLatLng(e[i]), n = t[i], n._preSpiderfyLatlng = n._latlng, n.setLatLng(r), n.setZIndexOffset && n.setZIndexOffset(1e6), h.addLayer(n), s = new L.Polyline([this._latlng, r], {\n        weight: 1.5,\n        color: \"#222\"\n      }), a.addLayer(s), n._spiderLeg = s;\n      this.setOpacity(.3), o.fire(\"spiderfied\");\n    },\n    _animationUnspiderfy: function _animationUnspiderfy() {\n      this._noanimationUnspiderfy();\n    }\n  }), L.MarkerClusterGroup.include({\n    _spiderfied: null,\n    _spiderfierOnAdd: function _spiderfierOnAdd() {\n      this._map.on(\"click\", this._unspiderfyWrapper, this), this._map.options.zoomAnimation && this._map.on(\"zoomstart\", this._unspiderfyZoomStart, this), this._map.on(\"zoomend\", this._noanimationUnspiderfy, this), L.Path.SVG && !L.Browser.touch && this._map._initPathRoot();\n    },\n    _spiderfierOnRemove: function _spiderfierOnRemove() {\n      this._map.off(\"click\", this._unspiderfyWrapper, this), this._map.off(\"zoomstart\", this._unspiderfyZoomStart, this), this._map.off(\"zoomanim\", this._unspiderfyZoomAnim, this), this._unspiderfy();\n    },\n    _unspiderfyZoomStart: function _unspiderfyZoomStart() {\n      this._map && this._map.on(\"zoomanim\", this._unspiderfyZoomAnim, this);\n    },\n    _unspiderfyZoomAnim: function _unspiderfyZoomAnim(t) {\n      L.DomUtil.hasClass(this._map._mapPane, \"leaflet-touching\") || (this._map.off(\"zoomanim\", this._unspiderfyZoomAnim, this), this._unspiderfy(t));\n    },\n    _unspiderfyWrapper: function _unspiderfyWrapper() {\n      this._unspiderfy();\n    },\n    _unspiderfy: function _unspiderfy(t) {\n      this._spiderfied && this._spiderfied.unspiderfy(t);\n    },\n    _noanimationUnspiderfy: function _noanimationUnspiderfy() {\n      this._spiderfied && this._spiderfied._noanimationUnspiderfy();\n    },\n    _unspiderfyLayer: function _unspiderfyLayer(t) {\n      t._spiderLeg && (this._featureGroup.removeLayer(t), t.setOpacity(1), t.setZIndexOffset(0), this._map.removeLayer(t._spiderLeg), delete t._spiderLeg);\n    }\n  });\n}(window, document);","// https://github.com/consbio/Leaflet.ZoomBox\n// Copyright (c) 2014, Conservation Biology Institute\n//\n// Permission to use, copy, modify, and/or distribute this software for any\n// purpose with or without fee is hereby granted, provided that the above\n// copyright notice and this permission notice appear in all copies.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\nL.Control.ZoomBox = L.Control.extend({\n  _active: false,\n  _map: null,\n  includes: L.Mixin.Events,\n  options: {\n    position: \"topleft\",\n    className: \"fa fa-search-plus\",\n    modal: false\n  },\n  onAdd: function onAdd(map) {\n    this._map = map;\n    this._container = L.DomUtil.create(\"div\", \"leaflet-zoom-box-control leaflet-bar\");\n    this._container.title = \"Zoom to specific area\";\n    var link = L.DomUtil.create(\"a\", this.options.className, this._container);\n    link.href = \"#\";\n    var _origMouseDown = map.boxZoom._onMouseDown;\n    map.boxZoom._onMouseDown = function (e) {\n      _origMouseDown.call(map.boxZoom, {\n        clientX: e.clientX,\n        clientY: e.clientY,\n        which: 1,\n        shiftKey: true\n      });\n    };\n    map.on(\"zoomend\", function () {\n      if (map.getZoom() == map.getMaxZoom()) {\n        L.DomUtil.addClass(link, \"leaflet-disabled\");\n      } else {\n        L.DomUtil.removeClass(link, \"leaflet-disabled\");\n      }\n    }, this);\n    if (!this.options.modal) {\n      map.on(\"boxzoomend\", this.deactivate, this);\n    }\n    L.DomEvent.on(this._container, \"dblclick\", L.DomEvent.stop).on(this._container, \"click\", L.DomEvent.stop).on(this._container, \"click\", function () {\n      this._active = !this._active;\n      if (this._active && map.getZoom() != map.getMaxZoom()) {\n        this.activate();\n      } else {\n        this.deactivate();\n      }\n    }, this);\n    return this._container;\n  },\n  activate: function activate() {\n    L.DomUtil.addClass(this._container, \"active\");\n    this._map.dragging.disable();\n    this._map.boxZoom.addHooks();\n    L.DomUtil.addClass(this._map.getContainer(), \"leaflet-zoom-box-crosshair\");\n  },\n  deactivate: function deactivate() {\n    L.DomUtil.removeClass(this._container, \"active\");\n    this._map.dragging.enable();\n    this._map.boxZoom.removeHooks();\n    L.DomUtil.removeClass(this._map.getContainer(), \"leaflet-zoom-box-crosshair\");\n    this._active = false;\n    this._map.boxZoom._moved = false;\n  }\n});\nL.control.zoomBox = function (options) {\n  return new L.Control.ZoomBox(options);\n};","function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nimport d3v3 from 'd3v3';\nimport HueColors from \"../utils/hueColors\";\nvar nv = window.nv || {};\nnv.version = '1.1.15b';\nnv.dev = false; //set false when in production\n\nwindow.nv = nv;\nnv.tooltip = nv.tooltip || {}; // For the tooltip system\nnv.utils = nv.utils || {}; // Utility subsystem\nnv.models = nv.models || {}; //stores all the possible models/components\nnv.charts = {}; //stores all the ready to use charts\nnv.graphs = []; //stores all the graphs currently on the page\nnv.logs = {}; //stores some statistics and potential error messages\nnv.dom = {}; //DOM manipulation functions\n\nnv.dispatch = d3v3.dispatch('render_start', 'render_end');\n\n// *************************************************************************\n//  Development render timers - disabled if dev = false\n\nif (nv.dev) {\n  nv.dispatch.on('render_start', function (e) {\n    nv.logs.startTime = +new Date();\n  });\n  nv.dispatch.on('render_end', function (e) {\n    nv.logs.endTime = +new Date();\n    nv.logs.totalTime = nv.logs.endTime - nv.logs.startTime;\n    nv.log('total', nv.logs.totalTime); // used for development, to keep track of graph generation times\n  });\n}\n\n// ********************************************\n//  Public Core NV functions\n\n// Logs all arguments, and returns the last so you can test things in place\n// Note: in IE8 console.log is an object not a function, and if modernizr is used\n// then calling Function.prototype.bind with with anything other than a function\n// causes a TypeError to be thrown.\nnv.log = function () {\n  if (nv.dev && console.log && console.log.apply) console.log.apply(console, arguments);else if (nv.dev && typeof console.log == \"function\" && Function.prototype.bind) {\n    var log = Function.prototype.bind.call(console.log, console);\n    log.apply(console, arguments);\n  }\n  return arguments[arguments.length - 1];\n};\nnv.render = function () {\n  nv.render.active = true;\n  nv.dispatch.render_start();\n  var renderLoop = function renderLoop() {\n    if (!nv.render.queue.length) {\n      nv.dispatch.render_end();\n      nv.render.active = false;\n      return;\n    }\n    var graph = nv.render.queue.shift();\n    var chart = graph.generate();\n    if (typeof graph.callback === 'function') {\n      graph.callback(chart);\n    }\n    nv.graphs.push(chart);\n    window.setTimeout(renderLoop, 0);\n  };\n  window.setTimeout(renderLoop, 0);\n};\nnv.render.active = false;\nnv.render.queue = [];\nnv.addGraph = function (obj) {\n  if (_typeof(arguments[0]) === (typeof Function === \"undefined\" ? \"undefined\" : _typeof(Function))) obj = {\n    generate: arguments[0],\n    callback: arguments[1]\n  };\n  nv.render.queue.push(obj);\n  if (!nv.render.active) nv.render();\n};\nnv.identity = function (d) {\n  return d;\n};\nnv.strip = function (s) {\n  return s.replace(/(\\s|&)/g, '');\n};\nfunction daysInMonth(month, year) {\n  return new Date(year, month + 1, 0).getDate();\n}\nfunction d3_time_range(floor, step, number) {\n  return function (t0, t1, dt) {\n    var time = floor(t0),\n      times = [];\n    if (time < t0) step(time);\n    if (dt > 1) {\n      while (time < t1) {\n        var date = new Date(+time);\n        if (number(date) % dt === 0) times.push(date);\n        step(time);\n      }\n    } else {\n      while (time < t1) {\n        times.push(new Date(+time));\n        step(time);\n      }\n    }\n    return times;\n  };\n}\nd3v3.time.monthEnd = function (date) {\n  return new Date(date.getFullYear(), date.getMonth(), 0);\n};\nd3v3.time.monthEnds = d3_time_range(d3v3.time.monthEnd, function (date) {\n  date.setUTCDate(date.getUTCDate() + 1);\n  date.setDate(daysInMonth(date.getMonth() + 1, date.getFullYear()));\n}, function (date) {\n  return date.getMonth();\n});\n\n/* Utility class to handle creation of an interactive layer.\nThis places a rectangle on top of the chart. When you mouse move over it, it sends a dispatch\ncontaining the X-coordinate. It can also render a vertical line where the mouse is located.\n\ndispatch.elementMousemove is the important event to latch onto.  It is fired whenever the mouse moves over\nthe rectangle. The dispatch is given one object which contains the mouseX/Y location.\nIt also has 'pointXValue', which is the conversion of mouseX to the x-axis scale.\n*/\nnv.interactiveGuideline = function () {\n  \"use strict\";\n\n  var tooltip = nv.models.tooltip();\n  //Public settings\n  var width = null,\n    height = null\n    //Please pass in the bounding chart's top and left margins\n    //This is important for calculating the correct mouseX/Y positions.\n    ,\n    margin = {\n      left: 0,\n      top: 0\n    },\n    xScale = d3v3.scale.linear(),\n    yScale = d3v3.scale.linear(),\n    dispatch = d3v3.dispatch('elementMousemove', 'elementMouseout', 'elementDblclick'),\n    showGuideLine = true,\n    svgContainer = null\n    //Must pass in the bounding chart's <svg> container.\n    //The mousemove event is attached to this container.\n  ;\n\n  //Private variables\n  var isMSIE = navigator.userAgent.indexOf(\"MSIE\") !== -1 //Check user-agent for Microsoft Internet Explorer.\n  ;\n  function layer(selection) {\n    selection.each(function (data) {\n      var container = d3v3.select(this);\n      var availableWidth = width || 960,\n        availableHeight = height || 400;\n      var wrap = container.selectAll(\"g.nv-wrap.nv-interactiveLineLayer\").data([data]);\n      var wrapEnter = wrap.enter().append(\"g\").attr(\"class\", \" nv-wrap nv-interactiveLineLayer\");\n      wrapEnter.append(\"g\").attr(\"class\", \"nv-interactiveGuideLine\");\n      if (!svgContainer) {\n        return;\n      }\n      function mouseHandler() {\n        var d3mouse = d3v3.mouse(this);\n        var mouseX = d3mouse[0];\n        var mouseY = d3mouse[1];\n        var subtractMargin = true;\n        var mouseOutAnyReason = false;\n        if (isMSIE) {\n          /*\n             d3v3.js (or maybe SVG.getScreenCTM) has a nasty bug in Internet Explorer 10.\n             d3v3.mouse() returns incorrect X,Y mouse coordinates when mouse moving\n             over a rect in IE 10.\n             However, d3v3.event.offsetX/Y also returns the mouse coordinates\n             relative to the triggering <rect>. So we use offsetX/Y on IE.  \n          */\n          mouseX = d3v3.event.offsetX;\n          mouseY = d3v3.event.offsetY;\n\n          /*\n             On IE, if you attach a mouse event listener to the <svg> container,\n             it will actually trigger it for all the child elements (like <path>, <circle>, etc).\n             When this happens on IE, the offsetX/Y is set to where ever the child element\n             is located.\n             As a result, we do NOT need to subtract margins to figure out the mouse X/Y\n             position under this scenario. Removing the line below *will* cause \n             the interactive layer to not work right on IE.\n          */\n          if (d3v3.event.target.tagName !== \"svg\") subtractMargin = false;\n          if (d3v3.event.target.className.baseVal.match(\"nv-legend\")) mouseOutAnyReason = true;\n        }\n        if (subtractMargin) {\n          mouseX -= margin.left;\n          mouseY -= margin.top;\n        }\n\n        /* If mouseX/Y is outside of the chart's bounds,\n        trigger a mouseOut event.\n        */\n        if (mouseX < 0 || mouseY < 0 || mouseX > availableWidth || mouseY > availableHeight || d3v3.event.relatedTarget && d3v3.event.relatedTarget.ownerSVGElement === undefined || mouseOutAnyReason) {\n          if (isMSIE) {\n            if (d3v3.event.relatedTarget && d3v3.event.relatedTarget.ownerSVGElement === undefined && d3v3.event.relatedTarget.className.match(tooltip.nvPointerEventsClass)) {\n              return;\n            }\n          }\n          dispatch.elementMouseout({\n            mouseX: mouseX,\n            mouseY: mouseY\n          });\n          layer.renderGuideLine(null); //hide the guideline\n          return;\n        }\n        var pointXValue = xScale.invert(mouseX);\n        dispatch.elementMousemove({\n          mouseX: mouseX,\n          mouseY: mouseY,\n          pointXValue: pointXValue\n        });\n\n        //If user double clicks the layer, fire a elementDblclick dispatch.\n        if (d3v3.event.type === \"dblclick\") {\n          dispatch.elementDblclick({\n            mouseX: mouseX,\n            mouseY: mouseY,\n            pointXValue: pointXValue\n          });\n        }\n      }\n      svgContainer.on(\"mousemove\", mouseHandler, true).on(\"mouseout\", mouseHandler, true).on(\"dblclick\", mouseHandler);\n\n      //Draws a vertical guideline at the given X postion.\n      layer.renderGuideLine = function (x) {\n        if (!showGuideLine) return;\n        var line = wrap.select(\".nv-interactiveGuideLine\").selectAll(\"line\").data(x != null ? [nv.utils.NaNtoZero(x)] : [], String);\n        line.enter().append(\"line\").attr(\"class\", \"nv-guideline\").attr(\"x1\", function (d) {\n          return d;\n        }).attr(\"x2\", function (d) {\n          return d;\n        }).attr(\"y1\", availableHeight).attr(\"y2\", 0);\n        line.exit().remove();\n      };\n    });\n  }\n  layer.dispatch = dispatch;\n  layer.tooltip = tooltip;\n  layer.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return layer;\n  };\n  layer.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return layer;\n  };\n  layer.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return layer;\n  };\n  layer.xScale = function (_) {\n    if (!arguments.length) return xScale;\n    xScale = _;\n    return layer;\n  };\n  layer.showGuideLine = function (_) {\n    if (!arguments.length) return showGuideLine;\n    showGuideLine = _;\n    return layer;\n  };\n  layer.svgContainer = function (_) {\n    if (!arguments.length) return svgContainer;\n    svgContainer = _;\n    return layer;\n  };\n  return layer;\n};\n\n/* Utility class that uses d3v3.bisect to find the index in a given array, where a search value can be inserted.\nThis is different from normal bisectLeft; this function finds the nearest index to insert the search value.\n\nFor instance, lets say your array is [1,2,3,5,10,30], and you search for 28. \nNormal d3v3.bisectLeft will return 4, because 28 is inserted after the number 10.  But interactiveBisect will return 5\nbecause 28 is closer to 30 than 10.\n\nUnit tests can be found in: interactiveBisectTest.html\n\nHas the following known issues:\n   * Will not work if the data points move backwards (ie, 10,9,8,7, etc) or if the data points are in random order.\n   * Won't work if there are duplicate x coordinate values.\n*/\nnv.interactiveBisect = function (values, searchVal, xAccessor) {\n  \"use strict\";\n\n  if (!values instanceof Array) return null;\n  if (typeof xAccessor !== 'function') xAccessor = function xAccessor(d, i) {\n    return d.x;\n  };\n  var bisect = d3v3.bisector(xAccessor).left;\n  var index = d3v3.max([0, bisect(values, searchVal) - 1]);\n  var currentValue = xAccessor(values[index], index);\n  if (typeof currentValue === 'undefined') currentValue = index;\n  if (currentValue === searchVal) return index; //found exact match\n\n  var nextIndex = d3v3.min([index + 1, values.length - 1]);\n  var nextValue = xAccessor(values[nextIndex], nextIndex);\n  if (typeof nextValue === 'undefined') nextValue = nextIndex;\n  if (Math.abs(nextValue - searchVal) >= Math.abs(currentValue - searchVal)) return index;else return nextIndex;\n};\n\n/*\nReturns the index in the array \"values\" that is closest to searchVal.\nOnly returns an index if searchVal is within some \"threshold\".\nOtherwise, returns null.\n*/\nnv.nearestValueIndex = function (values, searchVal, threshold) {\n  \"use strict\";\n\n  var yDistMax = Infinity,\n    indexToHighlight = null;\n  values.forEach(function (d, i) {\n    var delta = Math.abs(searchVal - d);\n    if (delta <= yDistMax && delta < threshold) {\n      yDistMax = delta;\n      indexToHighlight = i;\n    }\n  });\n  return indexToHighlight;\n}; /* Tooltip rendering model for nvd3 charts.\n   window.nv.models.tooltip is the updated,new way to render tooltips.\n   window.nv.tooltip.show is the old tooltip code.\n   window.nv.tooltip.* also has various helper methods.\n   */\n(function () {\n  \"use strict\";\n\n  window.nv.tooltip = {};\n\n  /* Model which can be instantiated to handle tooltip rendering.\n    Example usage: \n    var tip = nv.models.tooltip().gravity('w').distance(23)\n                .data(myDataObject);\n         tip();    //just invoke the returned function to render tooltip.\n  */\n  window.nv.models.tooltip = function () {\n    var content = null //HTML contents of the tooltip.  If null, the content is generated via the data variable.\n      ,\n      data = null /* Tooltip data. If data is given in the proper format, a consistent tooltip is generated.\n                  Format of data:\n                  {\n                  key: \"Date\",\n                  value: \"August 2009\", \n                  series: [\n                  {\n                  key: \"Series 1\",\n                  value: \"Value 1\",\n                  color: \"#000\"\n                  },\n                  {\n                  key: \"Series 2\",\n                  value: \"Value 2\",\n                  color: \"#00f\"\n                  }\n                  ]\n                  }\n                  */,\n      gravity = 'w' //Can be 'n','s','e','w'. Determines how tooltip is positioned.\n      ,\n      distance = 50 //Distance to offset tooltip from the mouse location.\n      ,\n      snapDistance = 25 //Tolerance allowed before tooltip is moved from its current position (creates 'snapping' effect)\n      ,\n      fixedTop = null //If not null, this fixes the top position of the tooltip.\n      ,\n      classes = null //Attaches additional CSS classes to the tooltip DIV that is created.\n      ,\n      chartContainer = null //Parent DIV, of the SVG Container that holds the chart.\n      ,\n      tooltipElem = null //actual DOM element representing the tooltip.\n      ,\n      position = {\n        left: null,\n        top: null\n      } //Relative position of the tooltip inside chartContainer.\n      ,\n      enabled = true //True -> tooltips are rendered. False -> don't render tooltips.\n      //Generates a unique id when you create a new tooltip() object\n      ,\n      id = \"nvtooltip-\" + Math.floor(Math.random() * 100000);\n\n    //CSS class to specify whether element should not have mouse events.\n    var nvPointerEventsClass = \"nv-pointer-events-none\";\n\n    //Format function for the tooltip values column\n    var valueFormatter = function valueFormatter(d, i) {\n      return d;\n    };\n\n    //Format function for the tooltip header value.\n    var headerFormatter = function headerFormatter(d) {\n      return d;\n    };\n\n    //By default, the tooltip model renders a beautiful table inside a DIV.\n    //You can override this function if a custom tooltip is desired.\n    var contentGenerator = function contentGenerator(d) {\n      if (content != null) return content;\n      if (d == null) return '';\n      var table = d3v3.select(document.createElement(\"table\"));\n      var theadEnter = table.selectAll(\"thead\").data([d]).enter().append(\"thead\");\n      theadEnter.append(\"tr\").append(\"td\").attr(\"colspan\", 3).append(\"strong\").classed(\"x-value\", true).html(headerFormatter(d.value));\n      var tbodyEnter = table.selectAll(\"tbody\").data([d]).enter().append(\"tbody\");\n      var trowEnter = tbodyEnter.selectAll(\"tr\").data(function (p) {\n        return p.series;\n      }).enter().append(\"tr\").classed(\"highlight\", function (p) {\n        return p.highlight;\n      });\n      trowEnter.append(\"td\").classed(\"legend-color-guide\", true).append(\"div\").style(\"background-color\", function (p) {\n        return p.color;\n      });\n      trowEnter.append(\"td\").classed(\"key\", true).html(function (p) {\n        return p.key;\n      });\n      trowEnter.append(\"td\").classed(\"value\", true).html(function (p, i) {\n        return valueFormatter(p.value, i);\n      });\n      trowEnter.selectAll(\"td\").each(function (p) {\n        if (p.highlight) {\n          var opacityScale = d3v3.scale.linear().domain([0, 1]).range([\"#fff\", p.color]);\n          var opacity = 0.6;\n          d3v3.select(this).style(\"border-bottom-color\", opacityScale(opacity)).style(\"border-top-color\", opacityScale(opacity));\n        }\n      });\n      var html = table.node().outerHTML;\n      if (d.footer !== undefined) html += \"<div class='footer'>\" + d.footer + \"</div>\";\n      return html;\n    };\n    var dataSeriesExists = function dataSeriesExists(d) {\n      if (d && d.series && d.series.length > 0) return true;\n      return false;\n    };\n\n    //In situations where the chart is in a 'viewBox', re-position the tooltip based on how far chart is zoomed.\n    function convertViewBoxRatio() {\n      if (chartContainer) {\n        var svg = d3v3.select(chartContainer);\n        if (svg.node().tagName !== \"svg\") {\n          svg = svg.select(\"svg\");\n        }\n        var viewBox = svg.node() ? svg.attr('viewBox') : null;\n        if (viewBox) {\n          viewBox = viewBox.split(' ');\n          var ratio = parseInt(svg.style('width')) / viewBox[2];\n          position.left = position.left * ratio;\n          position.top = position.top * ratio;\n        }\n      }\n    }\n\n    //Creates new tooltip container, or uses existing one on DOM.\n    function getTooltipContainer(newContent) {\n      var body;\n      if (chartContainer) body = d3v3.select(chartContainer);else body = d3v3.select(\"body\");\n      var container = body.select(\".nvtooltip\");\n      if (container.node() === null) {\n        //Create new tooltip div if it doesn't exist on DOM.\n        container = body.append(\"div\").attr(\"class\", \"nvtooltip \" + (classes ? classes : \"xy-tooltip\")).attr(\"id\", id);\n      }\n      container.node().innerHTML = newContent;\n      container.style(\"top\", 0).style(\"left\", 0).style(\"opacity\", 0);\n      container.selectAll(\"div, table, td, tr\").classed(nvPointerEventsClass, true);\n      container.classed(nvPointerEventsClass, true);\n      return container.node();\n    }\n\n    //Draw the tooltip onto the DOM.\n    function nvtooltip() {\n      if (!enabled) return;\n      if (!dataSeriesExists(data)) return;\n      convertViewBoxRatio();\n      var left = position.left;\n      var top = fixedTop != null ? fixedTop : position.top;\n      var container = getTooltipContainer(contentGenerator(data));\n      tooltipElem = container;\n      if (chartContainer) {\n        var svgComp = chartContainer.getElementsByTagName(\"svg\")[0];\n        var boundRect = svgComp ? svgComp.getBoundingClientRect() : chartContainer.getBoundingClientRect();\n        var svgOffset = {\n          left: 0,\n          top: 0\n        };\n        if (svgComp) {\n          var svgBound = svgComp.getBoundingClientRect();\n          var chartBound = chartContainer.getBoundingClientRect();\n          var svgBoundTop = svgBound.top;\n\n          //Defensive code. Sometimes, svgBoundTop can be a really negative\n          //  number, like -134254. That's a bug. \n          //  If such a number is found, use zero instead. FireFox bug only\n          if (svgBoundTop < 0) {\n            var containerBound = chartContainer.getBoundingClientRect();\n            svgBoundTop = Math.abs(svgBoundTop) > containerBound.height ? 0 : svgBoundTop;\n          }\n          svgOffset.top = Math.abs(svgBoundTop - chartBound.top);\n          svgOffset.left = Math.abs(svgBound.left - chartBound.left);\n        }\n        //If the parent container is an overflow <div> with scrollbars, subtract the scroll offsets.\n        //You need to also add any offset between the <svg> element and its containing <div>\n        //Finally, add any offset of the containing <div> on the whole page.\n        left += chartContainer.offsetLeft + svgOffset.left - 2 * chartContainer.scrollLeft;\n        top += chartContainer.offsetTop + svgOffset.top - 2 * chartContainer.scrollTop;\n      }\n      if (snapDistance && snapDistance > 0) {\n        top = Math.floor(top / snapDistance) * snapDistance;\n      }\n      nv.tooltip.calcTooltipPosition([left, top], gravity, distance, container);\n      return nvtooltip;\n    }\n    ;\n    nvtooltip.nvPointerEventsClass = nvPointerEventsClass;\n    nvtooltip.content = function (_) {\n      if (!arguments.length) return content;\n      content = _;\n      return nvtooltip;\n    };\n\n    //Returns tooltipElem...not able to set it.\n    nvtooltip.tooltipElem = function () {\n      return tooltipElem;\n    };\n    nvtooltip.contentGenerator = function (_) {\n      if (!arguments.length) return contentGenerator;\n      if (typeof _ === 'function') {\n        contentGenerator = _;\n      }\n      return nvtooltip;\n    };\n    nvtooltip.data = function (_) {\n      if (!arguments.length) return data;\n      data = _;\n      return nvtooltip;\n    };\n    nvtooltip.gravity = function (_) {\n      if (!arguments.length) return gravity;\n      gravity = _;\n      return nvtooltip;\n    };\n    nvtooltip.distance = function (_) {\n      if (!arguments.length) return distance;\n      distance = _;\n      return nvtooltip;\n    };\n    nvtooltip.snapDistance = function (_) {\n      if (!arguments.length) return snapDistance;\n      snapDistance = _;\n      return nvtooltip;\n    };\n    nvtooltip.classes = function (_) {\n      if (!arguments.length) return classes;\n      classes = _;\n      return nvtooltip;\n    };\n    nvtooltip.chartContainer = function (_) {\n      if (!arguments.length) return chartContainer;\n      chartContainer = _;\n      return nvtooltip;\n    };\n    nvtooltip.position = function (_) {\n      if (!arguments.length) return position;\n      position.left = typeof _.left !== 'undefined' ? _.left : position.left;\n      position.top = typeof _.top !== 'undefined' ? _.top : position.top;\n      return nvtooltip;\n    };\n    nvtooltip.fixedTop = function (_) {\n      if (!arguments.length) return fixedTop;\n      fixedTop = _;\n      return nvtooltip;\n    };\n    nvtooltip.enabled = function (_) {\n      if (!arguments.length) return enabled;\n      enabled = _;\n      return nvtooltip;\n    };\n    nvtooltip.valueFormatter = function (_) {\n      if (!arguments.length) return valueFormatter;\n      if (typeof _ === 'function') {\n        valueFormatter = _;\n      }\n      return nvtooltip;\n    };\n    nvtooltip.headerFormatter = function (_) {\n      if (!arguments.length) return headerFormatter;\n      if (typeof _ === 'function') {\n        headerFormatter = _;\n      }\n      return nvtooltip;\n    };\n\n    //id() is a read-only function. You can't use it to set the id.\n    nvtooltip.id = function () {\n      return id;\n    };\n    return nvtooltip;\n  };\n\n  //Original tooltip.show function. Kept for backward compatibility.\n  // pos = [left,top]\n  nv.tooltip.show = function (pos, content, gravity, dist, parentContainer, classes) {\n    //Create new tooltip div if it doesn't exist on DOM.\n    var container = document.createElement('div');\n    container.className = 'nvtooltip ' + (classes ? classes : 'xy-tooltip');\n    var body = parentContainer;\n    if (!parentContainer || parentContainer.tagName.match(/g|svg/i)) {\n      //If the parent element is an SVG element, place tooltip in the <body> element.\n      body = document.getElementsByTagName('body')[0];\n    }\n    container.style.left = 0;\n    container.style.top = 0;\n    container.style.opacity = 0;\n    container.innerHTML = content;\n    body.appendChild(container);\n\n    //If the parent container is an overflow <div> with scrollbars, subtract the scroll offsets.\n    if (parentContainer) {\n      pos[0] = pos[0] - parentContainer.scrollLeft;\n      pos[1] = pos[1] - parentContainer.scrollTop;\n    }\n    nv.tooltip.calcTooltipPosition(pos, gravity, dist, container);\n  };\n\n  //Looks up the ancestry of a DOM element, and returns the first NON-svg node.\n  nv.tooltip.findFirstNonSVGParent = function (Elem) {\n    while (Elem.tagName.match(/^g|svg$/i) !== null) {\n      Elem = Elem.parentNode;\n    }\n    return Elem;\n  };\n\n  //Finds the total offsetTop of a given DOM element.\n  //Looks up the entire ancestry of an element, up to the first relatively positioned element.\n  nv.tooltip.findTotalOffsetTop = function (Elem, initialTop) {\n    var offsetTop = initialTop;\n    do {\n      if (!isNaN(Elem.offsetTop)) {\n        offsetTop += Elem.offsetTop;\n      }\n    } while (Elem = Elem.offsetParent);\n    return offsetTop;\n  };\n\n  //Finds the total offsetLeft of a given DOM element.\n  //Looks up the entire ancestry of an element, up to the first relatively positioned element.\n  nv.tooltip.findTotalOffsetLeft = function (Elem, initialLeft) {\n    var offsetLeft = initialLeft;\n    do {\n      if (!isNaN(Elem.offsetLeft)) {\n        offsetLeft += Elem.offsetLeft;\n      }\n    } while (Elem = Elem.offsetParent);\n    return offsetLeft;\n  };\n\n  //Global utility function to render a tooltip on the DOM.\n  //pos = [left,top] coordinates of where to place the tooltip, relative to the SVG chart container.\n  //gravity = how to orient the tooltip\n  //dist = how far away from the mouse to place tooltip\n  //container = tooltip DIV\n  nv.tooltip.calcTooltipPosition = function (pos, gravity, dist, container) {\n    var height = parseInt(container.offsetHeight),\n      width = parseInt(container.offsetWidth),\n      windowWidth = nv.utils.windowSize().width,\n      windowHeight = nv.utils.windowSize().height,\n      scrollTop = window.pageYOffset,\n      scrollLeft = window.pageXOffset,\n      left,\n      top;\n    windowHeight = window.innerWidth >= document.body.scrollWidth ? windowHeight : windowHeight - 16;\n    windowWidth = window.innerHeight >= document.body.scrollHeight ? windowWidth : windowWidth - 16;\n    gravity = gravity || 's';\n    dist = dist || 20;\n    var tooltipTop = function tooltipTop(Elem) {\n      return nv.tooltip.findTotalOffsetTop(Elem, top);\n    };\n    var tooltipLeft = function tooltipLeft(Elem) {\n      return nv.tooltip.findTotalOffsetLeft(Elem, left);\n    };\n    switch (gravity) {\n      case 'e':\n        left = pos[0] - width - dist;\n        top = pos[1] - height / 2;\n        var tLeft = tooltipLeft(container);\n        var tTop = tooltipTop(container);\n        if (tLeft < scrollLeft) left = pos[0] + dist > scrollLeft ? pos[0] + dist : scrollLeft - tLeft + left;\n        if (tTop < scrollTop) top = scrollTop - tTop + top;\n        if (tTop + height > scrollTop + windowHeight) top = scrollTop + windowHeight - tTop + top - height;\n        break;\n      case 'w':\n        left = pos[0] + dist;\n        top = pos[1] - height / 2;\n        var tLeft = tooltipLeft(container);\n        var tTop = tooltipTop(container);\n        if (tLeft + width > windowWidth) left = pos[0] - width - dist;\n        if (tTop < scrollTop) top = scrollTop + 5;\n        if (tTop + height > scrollTop + windowHeight) top = scrollTop + windowHeight - tTop + top - height;\n        break;\n      case 'n':\n        left = pos[0] - width / 2 - 5;\n        top = pos[1] + dist;\n        var tLeft = tooltipLeft(container);\n        var tTop = tooltipTop(container);\n        if (tLeft < scrollLeft) left = scrollLeft + 5;\n        if (tLeft + width > windowWidth) left = left - width / 2 + 5;\n        if (tTop + height > scrollTop + windowHeight) top = scrollTop + windowHeight - tTop + top - height;\n        break;\n      case 's':\n        left = pos[0] - width / 2;\n        top = pos[1] - height - dist;\n        var tLeft = tooltipLeft(container);\n        var tTop = tooltipTop(container);\n        windowWidth = nv.tooltip.findTotalOffsetLeft(container.parentElement, 0) + container.parentElement.scrollWidth;\n        if (tLeft < scrollLeft) left = scrollLeft + 5;\n        if (tLeft + width > windowWidth) left = left - width / 2 + 5;\n        if (scrollTop > tTop) top = scrollTop;\n        break;\n      case 'none':\n        left = pos[0];\n        top = pos[1] - dist;\n        var tLeft = tooltipLeft(container);\n        var tTop = tooltipTop(container);\n        break;\n    }\n    container.style.left = left + 'px';\n    container.style.top = Math.max(top, 0) + 'px';\n    container.style.opacity = 1;\n    container.style.position = 'absolute';\n    return container;\n  };\n\n  //Global utility function to remove tooltips from the DOM.\n  nv.tooltip.cleanup = function () {\n    // Find the tooltips, mark them for removal by this class (so others cleanups won't find it)\n    var tooltips = document.getElementsByClassName('nvtooltip');\n    var purging = [];\n    while (tooltips.length) {\n      purging.push(tooltips[0]);\n      tooltips[0].style.transitionDelay = '0 !important';\n      tooltips[0].style.opacity = 0;\n      tooltips[0].className = 'nvtooltip-pending-removal';\n    }\n    setTimeout(function () {\n      while (purging.length) {\n        var removeMe = purging.pop();\n        removeMe.parentNode.removeChild(removeMe);\n      }\n    }, 500);\n  };\n})();\nnv.utils.windowSize = function () {\n  // Sane defaults\n  var size = {\n    width: 640,\n    height: 480\n  };\n\n  // Earlier IE uses Doc.body\n  if (document.body && document.body.offsetWidth) {\n    size.width = document.body.offsetWidth;\n    size.height = document.body.offsetHeight;\n  }\n\n  // IE can use depending on mode it is in\n  if (document.compatMode == 'CSS1Compat' && document.documentElement && document.documentElement.offsetWidth) {\n    size.width = document.documentElement.offsetWidth;\n    size.height = document.documentElement.offsetHeight;\n  }\n\n  // Most recent browsers use\n  if (window.innerWidth && window.innerHeight) {\n    size.width = window.innerWidth;\n    size.height = window.innerHeight;\n  }\n  return size;\n};\n\n// Easy way to bind multiple functions to window.onresize\n// TODO: give a way to remove a function after its bound, other than removing all of them\nnv.utils.windowResize = function (fun) {\n  if (fun === undefined) return;\n  var oldresize = window.onresize;\n  window.onresize = function (e) {\n    if (typeof oldresize == 'function') oldresize(e);\n    fun(e);\n  };\n};\n\n// Backwards compatible way to implement more d3-like coloring of graphs.\n// If passed an array, wrap it in a function which implements the old default\n// behavior\nnv.utils.getColor = function (color) {\n  if (!arguments.length) return nv.utils.defaultColor(); //if you pass in nothing, get default colors back\n\n  if (Object.prototype.toString.call(color) === '[object Array]') return function (d, i) {\n    return d.color || color[i % color.length];\n  };else return color;\n  //can't really help it if someone passes rubbish as color\n};\n\n// Default color chooser uses the index of an object as before.\nnv.utils.defaultColor = function () {\n  var colors = d3v3.scale.ordinal().range(HueColors.cuiD3Scale()).range();\n  return function (d, i) {\n    return d.color || colors[i % colors.length];\n  };\n};\n\n// Returns a color function that takes the result of 'getKey' for each series and\n// looks for a corresponding color from the dictionary,\nnv.utils.customTheme = function (dictionary, getKey, defaultColors) {\n  getKey = getKey || function (series) {\n    return series.key;\n  }; // use default series.key if getKey is undefined\n  defaultColors = defaultColors || d3v3.scale.category20().range(); //default color function\n\n  var defIndex = defaultColors.length; //current default color (going in reverse)\n\n  return function (series, index) {\n    var key = getKey(series);\n    if (!defIndex) defIndex = defaultColors.length; //used all the default colors, start over\n\n    if (typeof dictionary[key] !== \"undefined\") return typeof dictionary[key] === \"function\" ? dictionary[key]() : dictionary[key];else return defaultColors[--defIndex]; // no match in dictionary, use default color\n  };\n};\n\n// From the PJAX example on d3js.org, while this is not really directly needed\n// it's a very cool method for doing pjax, I may expand upon it a little bit,\n// open to suggestions on anything that may be useful\nnv.utils.pjax = function (links, content) {\n  d3v3.selectAll(links).on(\"click\", function () {\n    history.pushState(this.href, this.textContent, this.href);\n    load(this.href);\n    d3v3.event.preventDefault();\n  });\n  function load(href) {\n    d3v3.html(href, function (fragment) {\n      var target = d3v3.select(content).node();\n      target.parentNode.replaceChild(d3v3.select(fragment).select(content).node(), target);\n      nv.utils.pjax(links, content);\n    });\n  }\n  d3v3.select(window).on(\"popstate\", function () {\n    if (d3v3.event.state) load(d3v3.event.state);\n  });\n};\n\n/* For situations where we want to approximate the width in pixels for an SVG:text element.\nMost common instance is when the element is in a display:none; container.\nForumla is : text.length * font-size * constant_factor\n*/\nnv.utils.calcApproxTextWidth = function (svgTextElem) {\n  if (typeof svgTextElem.style === 'function' && typeof svgTextElem.text === 'function') {\n    var fontSize = parseInt(svgTextElem.style(\"font-size\").replace(\"px\", \"\"));\n    var textLength = svgTextElem.text().length;\n    return textLength * fontSize * 0.5;\n  }\n  return 0;\n};\n\n/* Numbers that are undefined, null or NaN, convert them to zeros.\n*/\nnv.utils.NaNtoZero = function (n) {\n  if (typeof n !== 'number' || isNaN(n) || n === null || n === Infinity) return 0;\n  return n;\n};\n\n/*\nSnippet of code you can insert into each nv.models.* to give you the ability to\ndo things like:\nchart.options({\n  showXAxis: true,\n  tooltips: true\n});\n\nTo enable in the chart:\nchart.options = nv.utils.optionsFunc.bind(chart);\n*/\nnv.utils.optionsFunc = function (args) {\n  if (args) {\n    d3v3.map(args).forEach(function (key, value) {\n      if (typeof this[key] === \"function\") {\n        this[key](value);\n      }\n    }.bind(this));\n  }\n  return this;\n};\nnv.models.axis = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var axis = d3v3.svg.axis();\n  var margin = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    },\n    width = 75 //only used for tickLabel currently\n    ,\n    height = 60 //only used for tickLabel currently\n    ,\n    scale = d3v3.scale.linear(),\n    axisLabelText = null,\n    showMaxMin = true //TODO: showMaxMin should be disabled on all ordinal scaled axes\n    ,\n    highlightZero = true,\n    rotateLabels = 0,\n    rotateYLabel = true,\n    staggerLabels = false,\n    isOrdinal = false,\n    ticks = null,\n    axisLabelDistance = 12 //The larger this number is, the closer the axis label is to the axis.\n  ;\n  axis.scale(scale).orient('bottom').tickFormat(function (d) {\n    return d;\n  });\n\n  //============================================================\n\n  //============================================================\n  // Private Variables\n  //------------------------------------------------------------\n\n  var scale0;\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var container = d3v3.select(this);\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = container.selectAll('g.nv-wrap.nv-axis').data([data]);\n      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-axis');\n      var gEnter = wrapEnter.append('g');\n      var g = wrap.select('g');\n\n      //------------------------------------------------------------\n\n      if (ticks !== null) axis.ticks(ticks);else if (axis.orient() == 'top' || axis.orient() == 'bottom') axis.ticks(Math.abs(scale.range()[1] - scale.range()[0]) / 100);\n\n      //TODO: consider calculating width/height based on whether or not label is added, for reference in charts using this component\n\n      g.transition().call(axis);\n      scale0 = scale0 || axis.scale();\n      var fmt = axis.tickFormat();\n      if (fmt == null) {\n        fmt = scale0.tickFormat();\n      }\n      var axisLabel = g.selectAll('text.nv-axislabel').data([axisLabelText || null]);\n      axisLabel.exit().remove();\n      switch (axis.orient()) {\n        case 'top':\n          axisLabel.enter().append('text').attr('class', 'nv-axislabel');\n          var w = scale.range().length == 2 ? scale.range()[1] : scale.range()[scale.range().length - 1] + (scale.range()[1] - scale.range()[0]);\n          axisLabel.attr('text-anchor', 'middle').attr('y', 0).attr('x', nv.utils.NaNtoZero(w) / 2);\n          if (showMaxMin) {\n            var axisMaxMin = wrap.selectAll('g.nv-axisMaxMin').data(scale.domain());\n            axisMaxMin.enter().append('g').attr('class', 'nv-axisMaxMin').append('text');\n            axisMaxMin.exit().remove();\n            axisMaxMin.attr('transform', function (d, i) {\n              return 'translate(' + scale(d) + ',0)';\n            }).select('text').attr('dy', '-0.5em').attr('y', -axis.tickPadding()).attr('text-anchor', 'middle').text(function (d, i) {\n              var v = fmt(d);\n              return ('' + v).match('NaN') ? '' : v;\n            });\n            axisMaxMin.transition().attr('transform', function (d, i) {\n              return 'translate(' + scale.range()[i] + ',0)';\n            });\n          }\n          break;\n        case 'bottom':\n          var xLabelMargin = 36;\n          var maxTextWidth = 30;\n          var xTicks = g.selectAll('g').select(\"text\");\n          if (rotateLabels % 360) {\n            //Calculate the longest xTick width\n            xTicks.each(function (d, i) {\n              var width = this.getBBox().width;\n              if (width > maxTextWidth) maxTextWidth = width;\n            });\n            //Convert to radians before calculating sin. Add 30 to margin for healthy padding.\n            var sin = Math.abs(Math.sin(rotateLabels * Math.PI / 180));\n            var xLabelMargin = (sin ? sin * maxTextWidth : maxTextWidth) + 30;\n            //Rotate all xTicks\n            xTicks.attr('transform', function (d, i, j) {\n              return 'rotate(' + rotateLabels + ' 0,0)';\n            }).style('text-anchor', rotateLabels % 360 > 0 ? 'start' : 'end');\n          }\n          axisLabel.enter().append('text').attr('class', 'nv-axislabel');\n          var w = scale.range().length == 2 ? scale.range()[1] : scale.range()[scale.range().length - 1] + (scale.range()[1] - scale.range()[0]);\n          axisLabel.attr('text-anchor', 'middle').attr('y', xLabelMargin).attr('x', nv.utils.NaNtoZero(w) / 2);\n          if (showMaxMin) {\n            //if (showMaxMin && !isOrdinal) {\n            var axisMaxMin = wrap.selectAll('g.nv-axisMaxMin')\n            //.data(scale.domain())\n            .data([scale.domain()[0], scale.domain()[scale.domain().length - 1]]);\n            axisMaxMin.enter().append('g').attr('class', 'nv-axisMaxMin').append('text');\n            axisMaxMin.exit().remove();\n            axisMaxMin.attr('transform', function (d, i) {\n              return 'translate(' + (scale(d) + (isOrdinal ? scale.rangeBand() / 2 : 0)) + ',0)';\n            }).select('text').attr('dy', '.71em').attr('y', axis.tickPadding()).attr('transform', function (d, i, j) {\n              return 'rotate(' + rotateLabels + ' 0,0)';\n            }).style('text-anchor', rotateLabels ? rotateLabels % 360 > 0 ? 'start' : 'end' : 'middle').text(function (d, i) {\n              var v = fmt(d);\n              return ('' + v).match('NaN') ? '' : v;\n            });\n            axisMaxMin.transition().attr('transform', function (d, i) {\n              //return 'translate(' + scale.range()[i] + ',0)'\n              //return 'translate(' + scale(d) + ',0)'\n              return 'translate(' + (scale(d) + (isOrdinal ? scale.rangeBand() / 2 : 0)) + ',0)';\n            });\n          }\n          if (staggerLabels) xTicks.attr('transform', function (d, i) {\n            return 'translate(0,' + (i % 2 == 0 ? '0' : '12') + ')';\n          });\n          break;\n        case 'right':\n          axisLabel.enter().append('text').attr('class', 'nv-axislabel');\n          axisLabel.style('text-anchor', rotateYLabel ? 'middle' : 'begin').attr('transform', rotateYLabel ? 'rotate(90)' : '').attr('y', rotateYLabel ? -Math.max(margin.right, width) + 12 : -10) //TODO: consider calculating this based on largest tick width... OR at least expose this on chart\n          .attr('x', rotateYLabel ? scale.range()[0] / 2 : axis.tickPadding());\n          if (showMaxMin) {\n            var axisMaxMin = wrap.selectAll('g.nv-axisMaxMin').data(scale.domain());\n            axisMaxMin.enter().append('g').attr('class', 'nv-axisMaxMin').append('text').style('opacity', 0);\n            axisMaxMin.exit().remove();\n            axisMaxMin.attr('transform', function (d, i) {\n              return 'translate(0,' + scale(d) + ')';\n            }).select('text').attr('dy', '.32em').attr('y', 0).attr('x', axis.tickPadding()).style('text-anchor', 'start').text(function (d, i) {\n              var v = fmt(d);\n              return ('' + v).match('NaN') ? '' : v;\n            });\n            axisMaxMin.transition().attr('transform', function (d, i) {\n              return 'translate(0,' + scale.range()[i] + ')';\n            }).select('text').style('opacity', 1);\n          }\n          break;\n        case 'left':\n          /*\n          //For dynamically placing the label. Can be used with dynamically-sized chart axis margins\n          var yTicks = g.selectAll('g').select(\"text\");\n          yTicks.each(function(d,i){\n            var labelPadding = this.getBBox().width + axis.tickPadding() + 16;\n            if(labelPadding > width) width = labelPadding;\n          });\n          */\n          axisLabel.enter().append('text').attr('class', 'nv-axislabel');\n          axisLabel.style('text-anchor', rotateYLabel ? 'middle' : 'end').attr('transform', rotateYLabel ? 'rotate(-90)' : '').attr('y', rotateYLabel ? -Math.max(margin.left, width) + axisLabelDistance : -10) //TODO: consider calculating this based on largest tick width... OR at least expose this on chart\n          .attr('x', rotateYLabel ? -scale.range()[0] / 2 : -axis.tickPadding());\n          if (showMaxMin) {\n            var axisMaxMin = wrap.selectAll('g.nv-axisMaxMin').data(scale.domain());\n            axisMaxMin.enter().append('g').attr('class', 'nv-axisMaxMin').append('text').style('opacity', 0);\n            axisMaxMin.exit().remove();\n            axisMaxMin.attr('transform', function (d, i) {\n              return 'translate(0,' + scale0(d) + ')';\n            }).select('text').attr('dy', '.32em').attr('y', 0).attr('x', -axis.tickPadding()).attr('text-anchor', 'end').text(function (d, i) {\n              var v = fmt(d);\n              return ('' + v).match('NaN') ? '' : v.toString().substr(0, 8);\n            });\n            axisMaxMin.transition().attr('transform', function (d, i) {\n              return 'translate(0,' + scale.range()[i] + ')';\n            }).select('text').style('opacity', 1);\n          }\n          break;\n      }\n      axisLabel.text(function (d) {\n        return d;\n      });\n      if (showMaxMin && (axis.orient() === 'left' || axis.orient() === 'right')) {\n        //check if max and min overlap other values, if so, hide the values that overlap\n        g.selectAll('g') // the g's wrapping each tick\n        .each(function (d, i) {\n          d3v3.select(this).select('text').attr('opacity', 1);\n          if (scale(d) < scale.range()[1] + 10 || scale(d) > scale.range()[0] - 10) {\n            // 10 is assuming text height is 16... if d is 0, leave it!\n            if (d > 1e-10 || d < -1e-10)\n              // accounts for minor floating point errors... though could be problematic if the scale is EXTREMELY SMALL\n              d3v3.select(this).attr('opacity', 0);\n            d3v3.select(this).select('text').attr('opacity', 0); // Don't remove the ZERO line!!\n          }\n        });\n\n        //if Max and Min = 0 only show min, Issue #281\n        if (scale.domain()[0] == scale.domain()[1] && scale.domain()[0] == 0) wrap.selectAll('g.nv-axisMaxMin').style('opacity', function (d, i) {\n          return !i ? 1 : 0;\n        });\n      }\n      if (showMaxMin && (axis.orient() === 'top' || axis.orient() === 'bottom')) {\n        var maxMinRange = [];\n        wrap.selectAll('g.nv-axisMaxMin').each(function (d, i) {\n          try {\n            if (i)\n              // i== 1, max position\n              maxMinRange.push(scale(d) - this.getBBox().width - 4); //assuming the max and min labels are as wide as the next tick (with an extra 4 pixels just in case)\n            else\n              // i==0, min position\n              maxMinRange.push(scale(d) + this.getBBox().width + 4);\n          } catch (err) {\n            if (i)\n              // i== 1, max position\n              maxMinRange.push(scale(d) - 4); //assuming the max and min labels are as wide as the next tick (with an extra 4 pixels just in case)\n            else\n              // i==0, min position\n              maxMinRange.push(scale(d) + 4);\n          }\n        });\n        g.selectAll('g') // the g's wrapping each tick\n        .each(function (d, i) {\n          if (scale(d) < maxMinRange[0] || scale(d) > maxMinRange[1]) {\n            if (d > 1e-10 || d < -1e-10)\n              // accounts for minor floating point errors... though could be problematic if the scale is EXTREMELY SMALL\n              d3v3.select(this).remove();else d3v3.select(this).select('text').remove(); // Don't remove the ZERO line!!\n          }\n        });\n      }\n\n      //highlight zero line ... Maybe should not be an option and should just be in CSS?\n      if (highlightZero) g.selectAll('.tick').filter(function (d) {\n        return !parseFloat(Math.round(d.__data__ * 100000) / 1000000) && d.__data__ !== undefined;\n      }) //this is because sometimes the 0 tick is a very small fraction, TODO: think of cleaner technique\n      .classed('zero', true);\n\n      //store old scales for use in transitions on update\n      scale0 = scale.copy();\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  // expose chart's sub-components\n  chart.axis = axis;\n  d3v3.rebind(chart, axis, 'orient', 'tickValues', 'tickSubdivide', 'tickSize', 'tickPadding', 'tickFormat');\n  d3v3.rebind(chart, scale, 'domain', 'range', 'rangeBand', 'rangeBands'); //these are also accessible by chart.scale(), but added common ones directly for ease of use\n\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.ticks = function (_) {\n    if (!arguments.length) return ticks;\n    ticks = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.axisLabel = function (_) {\n    if (!arguments.length) return axisLabelText;\n    axisLabelText = _;\n    return chart;\n  };\n  chart.showMaxMin = function (_) {\n    if (!arguments.length) return showMaxMin;\n    showMaxMin = _;\n    return chart;\n  };\n  chart.highlightZero = function (_) {\n    if (!arguments.length) return highlightZero;\n    highlightZero = _;\n    return chart;\n  };\n  chart.scale = function (_) {\n    if (!arguments.length) return scale;\n    scale = _;\n    axis.scale(scale);\n    isOrdinal = typeof scale.rangeBands === 'function';\n    d3v3.rebind(chart, scale, 'domain', 'range', 'rangeBand', 'rangeBands');\n    return chart;\n  };\n  chart.rotateYLabel = function (_) {\n    if (!arguments.length) return rotateYLabel;\n    rotateYLabel = _;\n    return chart;\n  };\n  chart.rotateLabels = function (_) {\n    if (!arguments.length) return rotateLabels;\n    rotateLabels = _;\n    return chart;\n  };\n  chart.staggerLabels = function (_) {\n    if (!arguments.length) return staggerLabels;\n    staggerLabels = _;\n    return chart;\n  };\n  chart.axisLabelDistance = function (_) {\n    if (!arguments.length) return axisLabelDistance;\n    axisLabelDistance = _;\n    return chart;\n  };\n\n  //============================================================\n\n  return chart;\n};\n//TODO: consider deprecating and using multibar with single series for this\nnv.models.historicalBar = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var margin = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    },\n    width = 960,\n    height = 500,\n    id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one\n    ,\n    x = d3v3.scale.linear(),\n    y = d3v3.scale.linear(),\n    getX = function getX(d) {\n      return d.x;\n    },\n    getY = function getY(d) {\n      return d.y;\n    },\n    forceX = [],\n    forceY = [0],\n    padData = false,\n    clipEdge = true,\n    color = nv.utils.defaultColor(),\n    xDomain,\n    yDomain,\n    xRange,\n    yRange,\n    dispatch = d3v3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout'),\n    interactive = true;\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var availableWidth = width - margin.left - margin.right,\n        availableHeight = height - margin.top - margin.bottom,\n        container = d3v3.select(this);\n\n      //------------------------------------------------------------\n      // Setup Scales\n\n      x.domain(xDomain || d3v3.extent(data[0].values.map(getX).concat(forceX)));\n      if (padData) x.range(xRange || [availableWidth * .5 / data[0].values.length, availableWidth * (data[0].values.length - .5) / data[0].values.length]);else x.range(xRange || [0, availableWidth]);\n      y.domain(yDomain || d3v3.extent(data[0].values.map(getY).concat(forceY))).range(yRange || [availableHeight, 0]);\n\n      // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point\n\n      if (x.domain()[0] === x.domain()[1]) x.domain()[0] ? x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01]) : x.domain([-1, 1]);\n      if (y.domain()[0] === y.domain()[1]) y.domain()[0] ? y.domain([y.domain()[0] + y.domain()[0] * 0.01, y.domain()[1] - y.domain()[1] * 0.01]) : y.domain([-1, 1]);\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = container.selectAll('g.nv-wrap.nv-historicalBar-' + id).data([data[0].values]);\n      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-historicalBar-' + id);\n      var defsEnter = wrapEnter.append('defs');\n      var gEnter = wrapEnter.append('g');\n      var g = wrap.select('g');\n      gEnter.append('g').attr('class', 'nv-bars');\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n      //------------------------------------------------------------\n\n      container.on('click', function (d, i) {\n        dispatch.chartClick({\n          data: d,\n          index: i,\n          pos: d3v3.event,\n          id: id\n        });\n      });\n      defsEnter.append('clipPath').attr('id', 'nv-chart-clip-path-' + id).append('rect');\n      wrap.select('#nv-chart-clip-path-' + id + ' rect').attr('width', availableWidth).attr('height', availableHeight);\n      g.attr('clip-path', clipEdge ? 'url(#nv-chart-clip-path-' + id + ')' : '');\n      var bars = wrap.select('.nv-bars').selectAll('.nv-bar').data(function (d) {\n        return d;\n      }, function (d, i) {\n        return getX(d, i);\n      });\n      bars.exit().remove();\n      var barsEnter = bars.enter().append('rect')\n      //.attr('class', function(d,i,j) { return (getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive') + ' nv-bar-' + j + '-' + i })\n      .attr('x', 0).attr('y', function (d, i) {\n        return nv.utils.NaNtoZero(y(Math.max(0, getY(d, i))));\n      }).attr('height', function (d, i) {\n        return nv.utils.NaNtoZero(Math.abs(y(getY(d, i)) - y(0)));\n      }).attr('transform', function (d, i) {\n        return 'translate(' + (x(getX(d, i)) - availableWidth / data[0].values.length * .45) + ',0)';\n      }).on('mouseover', function (d, i) {\n        if (!interactive) return;\n        d3v3.select(this).classed('hover', true);\n        dispatch.elementMouseover({\n          point: d,\n          series: data[0],\n          pos: [x(getX(d, i)), y(getY(d, i))],\n          // TODO: Figure out why the value appears to be shifted\n          pointIndex: i,\n          seriesIndex: 0,\n          e: d3v3.event\n        });\n      }).on('mouseout', function (d, i) {\n        if (!interactive) return;\n        d3v3.select(this).classed('hover', false);\n        dispatch.elementMouseout({\n          point: d,\n          series: data[0],\n          pointIndex: i,\n          seriesIndex: 0,\n          e: d3v3.event\n        });\n      }).on('click', function (d, i) {\n        if (!interactive) return;\n        dispatch.elementClick({\n          //label: d[label],\n          value: getY(d, i),\n          data: d,\n          index: i,\n          pos: [x(getX(d, i)), y(getY(d, i))],\n          e: d3v3.event,\n          id: id\n        });\n        d3v3.event.stopPropagation();\n      }).on('dblclick', function (d, i) {\n        if (!interactive) return;\n        dispatch.elementDblClick({\n          //label: d[label],\n          value: getY(d, i),\n          data: d,\n          index: i,\n          pos: [x(getX(d, i)), y(getY(d, i))],\n          e: d3v3.event,\n          id: id\n        });\n        d3v3.event.stopPropagation();\n      });\n      bars.attr('fill', function (d, i) {\n        return color(d, i);\n      }).attr('class', function (d, i, j) {\n        return (getY(d, i) < 0 ? 'nv-bar negative' : 'nv-bar positive') + ' nv-bar-' + j + '-' + i;\n      }).transition().attr('transform', function (d, i) {\n        return 'translate(' + (x(getX(d, i)) - availableWidth / data[0].values.length * .45) + ',0)';\n      })\n      //TODO: better width calculations that don't assume always uniform data spacing;w\n      .attr('width', availableWidth / data[0].values.length * .9);\n      bars.transition().attr('y', function (d, i) {\n        var rval = getY(d, i) < 0 ? y(0) : y(0) - y(getY(d, i)) < 1 ? y(0) - 1 : y(getY(d, i));\n        return nv.utils.NaNtoZero(rval);\n      }).attr('height', function (d, i) {\n        return nv.utils.NaNtoZero(Math.max(Math.abs(y(getY(d, i)) - y(0)), 1));\n      });\n    });\n    return chart;\n  }\n\n  //Create methods to allow outside functions to highlight a specific bar.\n  chart.highlightPoint = function (pointIndex, isHoverOver) {\n    d3v3.select(\".nv-historicalBar-\" + id).select(\".nv-bars .nv-bar-0-\" + pointIndex).classed(\"hover\", isHoverOver);\n  };\n  chart.clearHighlights = function () {\n    d3v3.select(\".nv-historicalBar-\" + id).select(\".nv-bars .nv-bar.hover\").classed(\"hover\", false);\n  };\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  chart.dispatch = dispatch;\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.x = function (_) {\n    if (!arguments.length) return getX;\n    getX = _;\n    return chart;\n  };\n  chart.y = function (_) {\n    if (!arguments.length) return getY;\n    getY = _;\n    return chart;\n  };\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.xScale = function (_) {\n    if (!arguments.length) return x;\n    x = _;\n    return chart;\n  };\n  chart.yScale = function (_) {\n    if (!arguments.length) return y;\n    y = _;\n    return chart;\n  };\n  chart.xDomain = function (_) {\n    if (!arguments.length) return xDomain;\n    xDomain = _;\n    return chart;\n  };\n  chart.yDomain = function (_) {\n    if (!arguments.length) return yDomain;\n    yDomain = _;\n    return chart;\n  };\n  chart.xRange = function (_) {\n    if (!arguments.length) return xRange;\n    xRange = _;\n    return chart;\n  };\n  chart.yRange = function (_) {\n    if (!arguments.length) return yRange;\n    yRange = _;\n    return chart;\n  };\n  chart.forceX = function (_) {\n    if (!arguments.length) return forceX;\n    forceX = _;\n    return chart;\n  };\n  chart.forceY = function (_) {\n    if (!arguments.length) return forceY;\n    forceY = _;\n    return chart;\n  };\n  chart.padData = function (_) {\n    if (!arguments.length) return padData;\n    padData = _;\n    return chart;\n  };\n  chart.clipEdge = function (_) {\n    if (!arguments.length) return clipEdge;\n    clipEdge = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    return chart;\n  };\n  chart.id = function (_) {\n    if (!arguments.length) return id;\n    id = _;\n    return chart;\n  };\n  chart.interactive = function (_) {\n    if (!arguments.length) return interactive;\n    interactive = false;\n    return chart;\n  };\n\n  //============================================================\n\n  return chart;\n};\n\n// Chart design based on the recommendations of Stephen Few. Implementation\n// based on the work of Clint Ivy, Jamie Love, and Jason Davies.\n// http://projects.instantcognition.com/protovis/bulletchart/\n\nnv.models.bullet = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var margin = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    },\n    orient = 'left' // TODO top & bottom\n    ,\n    reverse = false,\n    ranges = function ranges(d) {\n      return d.ranges;\n    },\n    markers = function markers(d) {\n      return d.markers;\n    },\n    measures = function measures(d) {\n      return d.measures;\n    },\n    rangeLabels = function rangeLabels(d) {\n      return d.rangeLabels ? d.rangeLabels : [];\n    },\n    markerLabels = function markerLabels(d) {\n      return d.markerLabels ? d.markerLabels : [];\n    },\n    measureLabels = function measureLabels(d) {\n      return d.measureLabels ? d.measureLabels : [];\n    },\n    forceX = [0] // List of numbers to Force into the X scale (ie. 0, or a max / min, etc.)\n    ,\n    width = 380,\n    height = 30,\n    tickFormat = null,\n    color = nv.utils.getColor(['#1f77b4']),\n    dispatch = d3v3.dispatch('elementMouseover', 'elementMouseout');\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (d, i) {\n      var availableWidth = width - margin.left - margin.right,\n        availableHeight = height - margin.top - margin.bottom,\n        container = d3v3.select(this);\n      var rangez = ranges.call(this, d, i).slice().sort(d3v3.descending),\n        markerz = markers.call(this, d, i).slice().sort(d3v3.descending),\n        measurez = measures.call(this, d, i).slice().sort(d3v3.descending),\n        rangeLabelz = rangeLabels.call(this, d, i).slice(),\n        markerLabelz = markerLabels.call(this, d, i).slice(),\n        measureLabelz = measureLabels.call(this, d, i).slice();\n\n      //------------------------------------------------------------\n      // Setup Scales\n\n      // Compute the new x-scale.\n      var x1 = d3v3.scale.linear().domain(d3v3.extent(d3v3.merge([forceX, rangez]))).range(reverse ? [availableWidth, 0] : [0, availableWidth]);\n\n      // Retrieve the old x-scale, if this is an update.\n      var x0 = this.__chart__ || d3v3.scale.linear().domain([0, Infinity]).range(x1.range());\n\n      // Stash the new scale.\n      this.__chart__ = x1;\n      var rangeMin = d3v3.min(rangez),\n        //rangez[2]\n        rangeMax = d3v3.max(rangez),\n        //rangez[0]\n        rangeAvg = rangez[1];\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = container.selectAll('g.nv-wrap.nv-bullet').data([d]);\n      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-bullet');\n      var gEnter = wrapEnter.append('g');\n      var g = wrap.select('g');\n      gEnter.append('rect').attr('class', 'nv-range nv-rangeMax');\n      gEnter.append('rect').attr('class', 'nv-range nv-rangeAvg');\n      gEnter.append('rect').attr('class', 'nv-range nv-rangeMin');\n      gEnter.append('rect').attr('class', 'nv-measure');\n      gEnter.append('path').attr('class', 'nv-markerTriangle');\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n      //------------------------------------------------------------\n\n      var w0 = function w0(d) {\n          return Math.abs(x0(d) - x0(0));\n        },\n        // TODO: could optimize by precalculating x0(0) and x1(0)\n        w1 = function w1(d) {\n          return Math.abs(x1(d) - x1(0));\n        };\n      var xp0 = function xp0(d) {\n          return d < 0 ? x0(d) : x0(0);\n        },\n        xp1 = function xp1(d) {\n          return d < 0 ? x1(d) : x1(0);\n        };\n      g.select('rect.nv-rangeMax').attr('height', availableHeight).attr('width', w1(rangeMax > 0 ? rangeMax : rangeMin)).attr('x', xp1(rangeMax > 0 ? rangeMax : rangeMin)).datum(rangeMax > 0 ? rangeMax : rangeMin);\n      /*\n      .attr('x', rangeMin < 0 ?\n                     rangeMax > 0 ?\n                         x1(rangeMin)\n                       : x1(rangeMax)\n                   : x1(0))\n                  */\n\n      g.select('rect.nv-rangeAvg').attr('height', availableHeight).attr('width', w1(rangeAvg)).attr('x', xp1(rangeAvg)).datum(rangeAvg);\n      /*\n      .attr('width', rangeMax <= 0 ?\n                         x1(rangeMax) - x1(rangeAvg)\n                       : x1(rangeAvg) - x1(rangeMin))\n      .attr('x', rangeMax <= 0 ?\n                     x1(rangeAvg)\n                   : x1(rangeMin))\n                  */\n\n      g.select('rect.nv-rangeMin').attr('height', availableHeight).attr('width', w1(rangeMax)).attr('x', xp1(rangeMax)).attr('width', w1(rangeMax > 0 ? rangeMin : rangeMax)).attr('x', xp1(rangeMax > 0 ? rangeMin : rangeMax)).datum(rangeMax > 0 ? rangeMin : rangeMax);\n      /*\n      .attr('width', rangeMax <= 0 ?\n                         x1(rangeAvg) - x1(rangeMin)\n                       : x1(rangeMax) - x1(rangeAvg))\n      .attr('x', rangeMax <= 0 ?\n                     x1(rangeMin)\n                   : x1(rangeAvg))\n                  */\n\n      g.select('rect.nv-measure').style('fill', color).attr('height', availableHeight / 3).attr('y', availableHeight / 3).attr('width', measurez < 0 ? x1(0) - x1(measurez[0]) : x1(measurez[0]) - x1(0)).attr('x', xp1(measurez)).on('mouseover', function () {\n        dispatch.elementMouseover({\n          value: measurez[0],\n          label: measureLabelz[0] || 'Current',\n          pos: [x1(measurez[0]), availableHeight / 2]\n        });\n      }).on('mouseout', function () {\n        dispatch.elementMouseout({\n          value: measurez[0],\n          label: measureLabelz[0] || 'Current'\n        });\n      });\n      var h3 = availableHeight / 6;\n      if (markerz[0]) {\n        g.selectAll('path.nv-markerTriangle').attr('transform', function (d) {\n          return 'translate(' + x1(markerz[0]) + ',' + availableHeight / 2 + ')';\n        }).attr('d', 'M0,' + h3 + 'L' + h3 + ',' + -h3 + ' ' + -h3 + ',' + -h3 + 'Z').on('mouseover', function () {\n          dispatch.elementMouseover({\n            value: markerz[0],\n            label: markerLabelz[0] || 'Previous',\n            pos: [x1(markerz[0]), availableHeight / 2]\n          });\n        }).on('mouseout', function () {\n          dispatch.elementMouseout({\n            value: markerz[0],\n            label: markerLabelz[0] || 'Previous'\n          });\n        });\n      } else {\n        g.selectAll('path.nv-markerTriangle').remove();\n      }\n      wrap.selectAll('.nv-range').on('mouseover', function (d, i) {\n        var label = rangeLabelz[i] || (!i ? \"Maximum\" : i == 1 ? \"Mean\" : \"Minimum\");\n        dispatch.elementMouseover({\n          value: d,\n          label: label,\n          pos: [x1(d), availableHeight / 2]\n        });\n      }).on('mouseout', function (d, i) {\n        var label = rangeLabelz[i] || (!i ? \"Maximum\" : i == 1 ? \"Mean\" : \"Minimum\");\n        dispatch.elementMouseout({\n          value: d,\n          label: label\n        });\n      });\n\n      /* // THIS IS THE PREVIOUS BULLET IMPLEMENTATION, WILL REMOVE SHORTLY\n            // Update the range rects.\n            var range = g.selectAll('rect.nv-range')\n                .data(rangez);\n      \n            range.enter().append('rect')\n                .attr('class', function(d, i) { return 'nv-range nv-s' + i; })\n                .attr('width', w0)\n                .attr('height', availableHeight)\n                .attr('x', reverse ? x0 : 0)\n                .on('mouseover', function(d,i) { \n                    dispatch.elementMouseover({\n                      value: d,\n                      label: (i <= 0) ? 'Maximum' : (i > 1) ? 'Minimum' : 'Mean', //TODO: make these labels a variable\n                      pos: [x1(d), availableHeight/2]\n                    })\n                })\n                .on('mouseout', function(d,i) { \n                    dispatch.elementMouseout({\n                      value: d,\n                      label: (i <= 0) ? 'Minimum' : (i >=1) ? 'Maximum' : 'Mean' //TODO: make these labels a variable\n                    })\n                })\n      \n            d3v3.transition(range)\n                .attr('x', reverse ? x1 : 0)\n                .attr('width', w1)\n                .attr('height', availableHeight);\n      \n      \n            // Update the measure rects.\n            var measure = g.selectAll('rect.nv-measure')\n                .data(measurez);\n      \n            measure.enter().append('rect')\n                .attr('class', function(d, i) { return 'nv-measure nv-s' + i; })\n                .style('fill', function(d,i) { return color(d,i ) })\n                .attr('width', w0)\n                .attr('height', availableHeight / 3)\n                .attr('x', reverse ? x0 : 0)\n                .attr('y', availableHeight / 3)\n                .on('mouseover', function(d) { \n                    dispatch.elementMouseover({\n                      value: d,\n                      label: 'Current', //TODO: make these labels a variable\n                      pos: [x1(d), availableHeight/2]\n                    })\n                })\n                .on('mouseout', function(d) { \n                    dispatch.elementMouseout({\n                      value: d,\n                      label: 'Current' //TODO: make these labels a variable\n                    })\n                })\n      \n            d3v3.transition(measure)\n                .attr('width', w1)\n                .attr('height', availableHeight / 3)\n                .attr('x', reverse ? x1 : 0)\n                .attr('y', availableHeight / 3);\n      \n      \n      \n            // Update the marker lines.\n            var marker = g.selectAll('path.nv-markerTriangle')\n                .data(markerz);\n      \n            var h3 =  availableHeight / 6;\n            marker.enter().append('path')\n                .attr('class', 'nv-markerTriangle')\n                .attr('transform', function(d) { return 'translate(' + x0(d) + ',' + (availableHeight / 2) + ')' })\n                .attr('d', 'M0,' + h3 + 'L' + h3 + ',' + (-h3) + ' ' + (-h3) + ',' + (-h3) + 'Z')\n                .on('mouseover', function(d,i) {\n                    dispatch.elementMouseover({\n                      value: d,\n                      label: 'Previous',\n                      pos: [x1(d), availableHeight/2]\n                    })\n                })\n                .on('mouseout', function(d,i) {\n                    dispatch.elementMouseout({\n                      value: d,\n                      label: 'Previous'\n                    })\n                });\n      \n            d3v3.transition(marker)\n                .attr('transform', function(d) { return 'translate(' + (x1(d) - x1(0)) + ',' + (availableHeight / 2) + ')' });\n      \n            marker.exit().remove();\n      */\n    });\n\n    // d3v3.timer.flush();  // Not needed?\n\n    return chart;\n  }\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  chart.dispatch = dispatch;\n  chart.options = nv.utils.optionsFunc.bind(chart);\n\n  // left, right, top, bottom\n  chart.orient = function (_) {\n    if (!arguments.length) return orient;\n    orient = _;\n    reverse = orient == 'right' || orient == 'bottom';\n    return chart;\n  };\n\n  // ranges (bad, satisfactory, good)\n  chart.ranges = function (_) {\n    if (!arguments.length) return ranges;\n    ranges = _;\n    return chart;\n  };\n\n  // markers (previous, goal)\n  chart.markers = function (_) {\n    if (!arguments.length) return markers;\n    markers = _;\n    return chart;\n  };\n\n  // measures (actual, forecast)\n  chart.measures = function (_) {\n    if (!arguments.length) return measures;\n    measures = _;\n    return chart;\n  };\n  chart.forceX = function (_) {\n    if (!arguments.length) return forceX;\n    forceX = _;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.tickFormat = function (_) {\n    if (!arguments.length) return tickFormat;\n    tickFormat = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    return chart;\n  };\n\n  //============================================================\n\n  return chart;\n};\n\n// Chart design based on the recommendations of Stephen Few. Implementation\n// based on the work of Clint Ivy, Jamie Love, and Jason Davies.\n// http://projects.instantcognition.com/protovis/bulletchart/\nnv.models.bulletChart = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var bullet = nv.models.bullet();\n  var orient = 'left' // TODO top & bottom\n    ,\n    reverse = false,\n    margin = {\n      top: 5,\n      right: 40,\n      bottom: 20,\n      left: 120\n    },\n    ranges = function ranges(d) {\n      return d.ranges;\n    },\n    markers = function markers(d) {\n      return d.markers;\n    },\n    measures = function measures(d) {\n      return d.measures;\n    },\n    width = null,\n    height = 55,\n    tickFormat = null,\n    tooltips = true,\n    tooltip = function tooltip(key, x, y, e, graph) {\n      return '<h3>' + x + '</h3>' + '<p>' + y + '</p>';\n    },\n    noData = 'No Data Available.',\n    dispatch = d3v3.dispatch('tooltipShow', 'tooltipHide');\n\n  //============================================================\n\n  //============================================================\n  // Private Variables\n  //------------------------------------------------------------\n\n  var showTooltip = function showTooltip(e, offsetElement) {\n    var left = e.pos[0] + (offsetElement.offsetLeft || 0) + margin.left,\n      top = e.pos[1] + (offsetElement.offsetTop || 0) + margin.top,\n      content = tooltip(e.key, e.label, e.value, e, chart);\n    nv.tooltip.show([left, top], content, e.value < 0 ? 'e' : 'w', null, offsetElement);\n  };\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (d, i) {\n      var container = d3v3.select(this);\n      var availableWidth = (width || parseInt(container.style('width')) || 960) - margin.left - margin.right,\n        availableHeight = height - margin.top - margin.bottom,\n        that = this;\n      chart.update = function () {\n        chart(selection);\n      };\n      chart.container = this;\n\n      //------------------------------------------------------------\n      // Display No Data message if there's nothing to show.\n\n      if (!d || !ranges.call(this, d, i)) {\n        var noDataText = container.selectAll('.nv-noData').data([noData]);\n        noDataText.enter().append('text').attr('class', 'nvd3 nv-noData').attr('dy', '-.7em').style('text-anchor', 'middle');\n        noDataText.attr('x', margin.left + availableWidth / 2).attr('y', 18 + margin.top + availableHeight / 2).text(function (d) {\n          return d;\n        });\n        return chart;\n      } else {\n        container.selectAll('.nv-noData').remove();\n      }\n\n      //------------------------------------------------------------\n\n      var rangez = ranges.call(this, d, i).slice().sort(d3v3.descending),\n        markerz = markers.call(this, d, i).slice().sort(d3v3.descending),\n        measurez = measures.call(this, d, i).slice().sort(d3v3.descending);\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = container.selectAll('g.nv-wrap.nv-bulletChart').data([d]);\n      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-bulletChart');\n      var gEnter = wrapEnter.append('g');\n      var g = wrap.select('g');\n      gEnter.append('g').attr('class', 'nv-bulletWrap');\n      gEnter.append('g').attr('class', 'nv-titles');\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n      //------------------------------------------------------------\n\n      // Compute the new x-scale.\n      var x1 = d3v3.scale.linear().domain([0, Math.max(rangez[0], markerz[0], measurez[0])]) // TODO: need to allow forceX and forceY, and xDomain, yDomain\n      .range(reverse ? [availableWidth, 0] : [0, availableWidth]);\n\n      // Retrieve the old x-scale, if this is an update.\n      var x0 = this.__chart__ || d3v3.scale.linear().domain([0, Infinity]).range(x1.range());\n\n      // Stash the new scale.\n      this.__chart__ = x1;\n\n      /*\n      // Derive width-scales from the x-scales.\n      var w0 = bulletWidth(x0),\n          w1 = bulletWidth(x1);\n       function bulletWidth(x) {\n        var x0 = x(0);\n        return function(d) {\n          return Math.abs(x(d) - x(0));\n        };\n      }\n       function bulletTranslate(x) {\n        return function(d) {\n          return 'translate(' + x(d) + ',0)';\n        };\n      }\n      */\n\n      var w0 = function w0(d) {\n          return Math.abs(x0(d) - x0(0));\n        },\n        // TODO: could optimize by precalculating x0(0) and x1(0)\n        w1 = function w1(d) {\n          return Math.abs(x1(d) - x1(0));\n        };\n      var title = gEnter.select('.nv-titles').append('g').attr('text-anchor', 'end').attr('transform', 'translate(-6,' + (height - margin.top - margin.bottom) / 2 + ')');\n      title.append('text').attr('class', 'nv-title').text(function (d) {\n        return d.title;\n      });\n      title.append('text').attr('class', 'nv-subtitle').attr('dy', '1em').text(function (d) {\n        return d.subtitle;\n      });\n      bullet.width(availableWidth).height(availableHeight);\n      var bulletWrap = g.select('.nv-bulletWrap');\n      d3v3.transition(bulletWrap).call(bullet);\n\n      // Compute the tick format.\n      var format = tickFormat || x1.tickFormat(availableWidth / 100);\n\n      // Update the tick groups.\n      var tick = g.selectAll('g.nv-tick').data(x1.ticks(availableWidth / 50), function (d) {\n        return this.textContent || format(d);\n      });\n\n      // Initialize the ticks with the old scale, x0.\n      var tickEnter = tick.enter().append('g').attr('class', 'nv-tick').attr('transform', function (d) {\n        return 'translate(' + x0(d) + ',0)';\n      }).style('opacity', 1e-6);\n      tickEnter.append('line').attr('y1', availableHeight).attr('y2', availableHeight * 7 / 6);\n      tickEnter.append('text').attr('text-anchor', 'middle').attr('dy', '1em').attr('y', availableHeight * 7 / 6).text(format);\n\n      // Transition the updating ticks to the new scale, x1.\n      var tickUpdate = d3v3.transition(tick).attr('transform', function (d) {\n        return 'translate(' + x1(d) + ',0)';\n      }).style('opacity', 1);\n      tickUpdate.select('line').attr('y1', availableHeight).attr('y2', availableHeight * 7 / 6);\n      tickUpdate.select('text').attr('y', availableHeight * 7 / 6);\n\n      // Transition the exiting ticks to the new scale, x1.\n      d3v3.transition(tick.exit()).attr('transform', function (d) {\n        return 'translate(' + x1(d) + ',0)';\n      }).style('opacity', 1e-6).remove();\n\n      //============================================================\n      // Event Handling/Dispatching (in chart's scope)\n      //------------------------------------------------------------\n\n      dispatch.on('tooltipShow', function (e) {\n        e.key = d.title;\n        if (tooltips) showTooltip(e, that.parentNode);\n      });\n\n      //============================================================\n    });\n    d3v3.timer.flush();\n    return chart;\n  }\n\n  //============================================================\n  // Event Handling/Dispatching (out of chart's scope)\n  //------------------------------------------------------------\n\n  bullet.dispatch.on('elementMouseover.tooltip', function (e) {\n    dispatch.tooltipShow(e);\n  });\n  bullet.dispatch.on('elementMouseout.tooltip', function (e) {\n    dispatch.tooltipHide(e);\n  });\n  dispatch.on('tooltipHide', function () {\n    if (tooltips) nv.tooltip.cleanup();\n  });\n\n  //============================================================\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  chart.dispatch = dispatch;\n  chart.bullet = bullet;\n  d3v3.rebind(chart, bullet, 'color');\n  chart.options = nv.utils.optionsFunc.bind(chart);\n\n  // left, right, top, bottom\n  chart.orient = function (x) {\n    if (!arguments.length) return orient;\n    orient = x;\n    reverse = orient == 'right' || orient == 'bottom';\n    return chart;\n  };\n\n  // ranges (bad, satisfactory, good)\n  chart.ranges = function (x) {\n    if (!arguments.length) return ranges;\n    ranges = x;\n    return chart;\n  };\n\n  // markers (previous, goal)\n  chart.markers = function (x) {\n    if (!arguments.length) return markers;\n    markers = x;\n    return chart;\n  };\n\n  // measures (actual, forecast)\n  chart.measures = function (x) {\n    if (!arguments.length) return measures;\n    measures = x;\n    return chart;\n  };\n  chart.width = function (x) {\n    if (!arguments.length) return width;\n    width = x;\n    return chart;\n  };\n  chart.height = function (x) {\n    if (!arguments.length) return height;\n    height = x;\n    return chart;\n  };\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.tickFormat = function (x) {\n    if (!arguments.length) return tickFormat;\n    tickFormat = x;\n    return chart;\n  };\n  chart.tooltips = function (_) {\n    if (!arguments.length) return tooltips;\n    tooltips = _;\n    return chart;\n  };\n  chart.tooltipContent = function (_) {\n    if (!arguments.length) return tooltip;\n    tooltip = _;\n    return chart;\n  };\n  chart.noData = function (_) {\n    if (!arguments.length) return noData;\n    noData = _;\n    return chart;\n  };\n\n  //============================================================\n\n  return chart;\n};\nnv.models.cumulativeLineChart = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var lines = nv.models.line(),\n    xAxis = nv.models.axis(),\n    yAxis = nv.models.axis(),\n    legend = nv.models.legend(),\n    controls = nv.models.legend(),\n    interactiveLayer = nv.interactiveGuideline();\n  var margin = {\n      top: 30,\n      right: 30,\n      bottom: 50,\n      left: 60\n    },\n    color = nv.utils.defaultColor(),\n    width = null,\n    height = null,\n    showLegend = true,\n    showXAxis = true,\n    showYAxis = true,\n    rightAlignYAxis = false,\n    tooltips = true,\n    showControls = true,\n    useInteractiveGuideline = false,\n    rescaleY = true,\n    tooltip = function tooltip(key, x, y, e, graph) {\n      return '<h3>' + key + '</h3>' + '<p>' + y + ' at ' + x + '</p>';\n    },\n    x //can be accessed via chart.xScale()\n    ,\n    y //can be accessed via chart.yScale()\n    ,\n    id = lines.id(),\n    state = {\n      index: 0,\n      rescaleY: rescaleY\n    },\n    defaultState = null,\n    noData = 'No Data Available.',\n    average = function average(d) {\n      return d.average;\n    },\n    dispatch = d3v3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState'),\n    transitionDuration = 250,\n    noErrorCheck = false //if set to TRUE, will bypass an error check in the indexify function.\n  ;\n  xAxis.orient('bottom').tickPadding(7);\n  yAxis.orient(rightAlignYAxis ? 'right' : 'left');\n\n  //============================================================\n  controls.updateState(false);\n\n  //============================================================\n  // Private Variables\n  //------------------------------------------------------------\n\n  var dx = d3v3.scale.linear(),\n    index = {\n      i: 0,\n      x: 0\n    };\n  var showTooltip = function showTooltip(e, offsetElement) {\n    var left = e.pos[0] + (offsetElement.offsetLeft || 0),\n      top = e.pos[1] + (offsetElement.offsetTop || 0),\n      x = xAxis.tickFormat()(lines.x()(e.point, e.pointIndex)),\n      y = yAxis.tickFormat()(lines.y()(e.point, e.pointIndex)),\n      content = tooltip(e.series.key, x, y, e, chart);\n    nv.tooltip.show([left, top], content, null, null, offsetElement);\n  };\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var container = d3v3.select(this).classed('nv-chart-' + id, true),\n        that = this;\n      var availableWidth = (width || parseInt(container.style('width')) || 960) - margin.left - margin.right,\n        availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n      chart.update = function () {\n        container.transition().duration(transitionDuration).call(chart);\n      };\n      chart.container = this;\n\n      //set state.disabled\n      state.disabled = data.map(function (d) {\n        return !!d.disabled;\n      });\n      if (!defaultState) {\n        var key;\n        defaultState = {};\n        for (key in state) {\n          if (state[key] instanceof Array) defaultState[key] = state[key].slice(0);else defaultState[key] = state[key];\n        }\n      }\n      var indexDrag = d3v3.behavior.drag().on('dragstart', dragStart).on('drag', dragMove).on('dragend', dragEnd);\n      function dragStart(d, i) {\n        d3v3.select(chart.container).style('cursor', 'ew-resize');\n      }\n      function dragMove(d, i) {\n        index.x = d3v3.event.x;\n        index.i = Math.round(dx.invert(index.x));\n        updateZero();\n      }\n      function dragEnd(d, i) {\n        d3v3.select(chart.container).style('cursor', 'auto');\n\n        // update state and send stateChange with new index\n        state.index = index.i;\n        dispatch.stateChange(state);\n      }\n\n      //------------------------------------------------------------\n      // Display No Data message if there's nothing to show.\n\n      if (!data || !data.length || !data.filter(function (d) {\n        return d.values.length;\n      }).length) {\n        var noDataText = container.selectAll('.nv-noData').data([noData]);\n        noDataText.enter().append('text').attr('class', 'nvd3 nv-noData').attr('dy', '-.7em').style('text-anchor', 'middle');\n        noDataText.attr('x', margin.left + availableWidth / 2).attr('y', margin.top + availableHeight / 2).text(function (d) {\n          return d;\n        });\n        return chart;\n      } else {\n        container.selectAll('.nv-noData').remove();\n      }\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Scales\n\n      x = lines.xScale();\n      y = lines.yScale();\n      if (!rescaleY) {\n        var seriesDomains = data.filter(function (series) {\n          return !series.disabled;\n        }).map(function (series, i) {\n          var initialDomain = d3v3.extent(series.values, lines.y());\n\n          //account for series being disabled when losing 95% or more\n          if (initialDomain[0] < -.95) initialDomain[0] = -.95;\n          return [(initialDomain[0] - initialDomain[1]) / (1 + initialDomain[1]), (initialDomain[1] - initialDomain[0]) / (1 + initialDomain[0])];\n        });\n        var completeDomain = [d3v3.min(seriesDomains, function (d) {\n          return d[0];\n        }), d3v3.max(seriesDomains, function (d) {\n          return d[1];\n        })];\n        lines.yDomain(completeDomain);\n      } else {\n        lines.yDomain(null);\n      }\n      dx.domain([0, data[0].values.length - 1]) //Assumes all series have same length\n      .range([0, availableWidth]).clamp(true);\n\n      //------------------------------------------------------------\n\n      var data = indexify(index.i, data);\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n      var interactivePointerEvents = useInteractiveGuideline ? \"none\" : \"all\";\n      var wrap = container.selectAll('g.nv-wrap.nv-cumulativeLine').data([data]);\n      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-cumulativeLine').append('g');\n      var g = wrap.select('g');\n      gEnter.append('g').attr('class', 'nv-interactive');\n      gEnter.append('g').attr('class', 'nv-x nv-axis').style(\"pointer-events\", \"none\");\n      gEnter.append('g').attr('class', 'nv-y nv-axis');\n      gEnter.append('g').attr('class', 'nv-background');\n      gEnter.append('g').attr('class', 'nv-linesWrap').style(\"pointer-events\", interactivePointerEvents);\n      gEnter.append('g').attr('class', 'nv-avgLinesWrap').style(\"pointer-events\", \"none\");\n      gEnter.append('g').attr('class', 'nv-legendWrap');\n      gEnter.append('g').attr('class', 'nv-controlsWrap');\n\n      //------------------------------------------------------------\n      // Legend\n\n      if (showLegend) {\n        legend.width(availableWidth);\n        g.select('.nv-legendWrap').datum(data).call(legend);\n        if (margin.top != legend.height()) {\n          margin.top = legend.height();\n          availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n        }\n        g.select('.nv-legendWrap').attr('transform', 'translate(0,' + -margin.top + ')');\n      }\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Controls\n\n      if (showControls) {\n        var controlsData = [{\n          key: 'Re-scale y-axis',\n          disabled: !rescaleY\n        }];\n        controls.width(140).color(['#444', '#444', '#444']).rightAlign(false).margin({\n          top: 5,\n          right: 0,\n          bottom: 5,\n          left: 20\n        });\n        g.select('.nv-controlsWrap').datum(controlsData).attr('transform', 'translate(0,' + -margin.top + ')').call(controls);\n      }\n\n      //------------------------------------------------------------\n\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n      if (rightAlignYAxis) {\n        g.select(\".nv-y.nv-axis\").attr(\"transform\", \"translate(\" + availableWidth + \",0)\");\n      }\n\n      // Show error if series goes below 100%\n      var tempDisabled = data.filter(function (d) {\n        return d.tempDisabled;\n      });\n      wrap.select('.tempDisabled').remove(); //clean-up and prevent duplicates\n      if (tempDisabled.length) {\n        wrap.append('text').attr('class', 'tempDisabled').attr('x', availableWidth / 2).attr('y', '-.71em').style('text-anchor', 'end').text(tempDisabled.map(function (d) {\n          return d.key;\n        }).join(', ') + ' values cannot be calculated for this time period.');\n      }\n\n      //------------------------------------------------------------\n      // Main Chart Component(s)\n\n      //------------------------------------------------------------\n      //Set up interactive layer\n      if (useInteractiveGuideline) {\n        interactiveLayer.width(availableWidth).height(availableHeight).margin({\n          left: margin.left,\n          top: margin.top\n        }).svgContainer(container).xScale(x);\n        wrap.select(\".nv-interactive\").call(interactiveLayer);\n      }\n      gEnter.select('.nv-background').append('rect');\n      g.select('.nv-background rect').attr('width', availableWidth).attr('height', availableHeight);\n      lines\n      //.x(function(d) { return d.x })\n      .y(function (d) {\n        return d.display.y;\n      }).width(availableWidth).height(availableHeight).color(data.map(function (d, i) {\n        return d.color || color(d, i);\n      }).filter(function (d, i) {\n        return !data[i].disabled && !data[i].tempDisabled;\n      }));\n      var linesWrap = g.select('.nv-linesWrap').datum(data.filter(function (d) {\n        return !d.disabled && !d.tempDisabled;\n      }));\n\n      //d3v3.transition(linesWrap).call(lines);\n      linesWrap.call(lines);\n\n      /*Handle average lines [AN-612] ----------------------------*/\n\n      //Store a series index number in the data array.\n      data.forEach(function (d, i) {\n        d.seriesIndex = i;\n      });\n      var avgLineData = data.filter(function (d) {\n        return !d.disabled && !!average(d);\n      });\n      var avgLines = g.select(\".nv-avgLinesWrap\").selectAll(\"line\").data(avgLineData, function (d) {\n        return d.key;\n      });\n      var getAvgLineY = function getAvgLineY(d) {\n        //If average lines go off the svg element, clamp them to the svg bounds.\n        var yVal = y(average(d));\n        if (yVal < 0) return 0;\n        if (yVal > availableHeight) return availableHeight;\n        return yVal;\n      };\n      avgLines.enter().append('line').style('stroke-width', 2).style('stroke-dasharray', '10,10').style('stroke', function (d, i) {\n        return lines.color()(d, d.seriesIndex);\n      }).attr('x1', 0).attr('x2', availableWidth).attr('y1', getAvgLineY).attr('y2', getAvgLineY);\n      avgLines.style('stroke-opacity', function (d) {\n        //If average lines go offscreen, make them transparent\n        var yVal = y(average(d));\n        if (yVal < 0 || yVal > availableHeight) return 0;\n        return 1;\n      }).attr('x1', 0).attr('x2', availableWidth).attr('y1', getAvgLineY).attr('y2', getAvgLineY);\n      avgLines.exit().remove();\n\n      //Create index line -----------------------------------------\n\n      var indexLine = linesWrap.selectAll('.nv-indexLine').data([index]);\n      indexLine.enter().append('rect').attr('class', 'nv-indexLine').attr('width', 3).attr('x', -2).attr('fill', 'red').attr('fill-opacity', .5).style(\"pointer-events\", \"all\").call(indexDrag);\n      indexLine.attr('transform', function (d) {\n        return 'translate(' + dx(d.i) + ',0)';\n      }).attr('height', availableHeight);\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Axes\n\n      if (showXAxis) {\n        xAxis.scale(x)\n        //Suggest how many ticks based on the chart width and D3 should listen (70 is the optimal number for MM/DD/YY dates)\n        .ticks(Math.min(data[0].values.length, availableWidth / 70)).tickSize(-availableHeight, 0);\n        g.select('.nv-x.nv-axis').attr('transform', 'translate(0,' + y.range()[0] + ')');\n        d3v3.transition(g.select('.nv-x.nv-axis')).call(xAxis);\n      }\n      if (showYAxis) {\n        yAxis.scale(y).ticks(availableHeight / 36).tickSize(-availableWidth, 0);\n        d3v3.transition(g.select('.nv-y.nv-axis')).call(yAxis);\n      }\n      //------------------------------------------------------------\n\n      //============================================================\n      // Event Handling/Dispatching (in chart's scope)\n      //------------------------------------------------------------\n\n      function updateZero() {\n        indexLine.data([index]);\n\n        //When dragging the index line, turn off line transitions.\n        // Then turn them back on when done dragging.\n        var oldDuration = chart.transitionDuration();\n        chart.transitionDuration(0);\n        chart.update();\n        chart.transitionDuration(oldDuration);\n      }\n      g.select('.nv-background rect').on('click', function () {\n        index.x = d3v3.mouse(this)[0];\n        index.i = Math.round(dx.invert(index.x));\n\n        // update state and send stateChange with new index\n        state.index = index.i;\n        dispatch.stateChange(state);\n        updateZero();\n      });\n      lines.dispatch.on('elementClick', function (e) {\n        index.i = e.pointIndex;\n        index.x = dx(index.i);\n\n        // update state and send stateChange with new index\n        state.index = index.i;\n        dispatch.stateChange(state);\n        updateZero();\n      });\n      controls.dispatch.on('legendClick', function (d, i) {\n        d.disabled = !d.disabled;\n        rescaleY = !d.disabled;\n        state.rescaleY = rescaleY;\n        dispatch.stateChange(state);\n        chart.update();\n      });\n      legend.dispatch.on('stateChange', function (newState) {\n        state.disabled = newState.disabled;\n        dispatch.stateChange(state);\n        chart.update();\n      });\n      interactiveLayer.dispatch.on('elementMousemove', function (e) {\n        lines.clearHighlights();\n        var singlePoint,\n          pointIndex,\n          pointXLocation,\n          allData = [];\n        data.filter(function (series, i) {\n          series.seriesIndex = i;\n          return !series.disabled;\n        }).forEach(function (series, i) {\n          pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());\n          lines.highlightPoint(i, pointIndex, true);\n          var point = series.values[pointIndex];\n          if (typeof point === 'undefined') return;\n          if (typeof singlePoint === 'undefined') singlePoint = point;\n          if (typeof pointXLocation === 'undefined') pointXLocation = chart.xScale()(chart.x()(point, pointIndex));\n          allData.push({\n            key: series.key,\n            value: chart.y()(point, pointIndex),\n            color: color(series, series.seriesIndex)\n          });\n        });\n\n        //Highlight the tooltip entry based on which point the mouse is closest to.\n        if (allData.length > 2) {\n          var yValue = chart.yScale().invert(e.mouseY);\n          var domainExtent = Math.abs(chart.yScale().domain()[0] - chart.yScale().domain()[1]);\n          var threshold = 0.03 * domainExtent;\n          var indexToHighlight = nv.nearestValueIndex(allData.map(function (d) {\n            return d.value;\n          }), yValue, threshold);\n          if (indexToHighlight !== null) allData[indexToHighlight].highlight = true;\n        }\n        var xValue = xAxis.tickFormat()(chart.x()(singlePoint, pointIndex), pointIndex);\n        interactiveLayer.tooltip.position({\n          left: pointXLocation + margin.left,\n          top: e.mouseY + margin.top\n        }).chartContainer(that.parentNode).enabled(tooltips).valueFormatter(function (d, i) {\n          return yAxis.tickFormat()(d);\n        }).data({\n          value: xValue,\n          series: allData\n        })();\n        interactiveLayer.renderGuideLine(pointXLocation);\n      });\n      interactiveLayer.dispatch.on(\"elementMouseout\", function (e) {\n        dispatch.tooltipHide();\n        lines.clearHighlights();\n      });\n      dispatch.on('tooltipShow', function (e) {\n        if (tooltips) showTooltip(e, that.parentNode);\n      });\n\n      // Update chart from a state object passed to event handler\n      dispatch.on('changeState', function (e) {\n        if (typeof e.disabled !== 'undefined') {\n          data.forEach(function (series, i) {\n            series.disabled = e.disabled[i];\n          });\n          state.disabled = e.disabled;\n        }\n        if (typeof e.index !== 'undefined') {\n          index.i = e.index;\n          index.x = dx(index.i);\n          state.index = e.index;\n          indexLine.data([index]);\n        }\n        if (typeof e.rescaleY !== 'undefined') {\n          rescaleY = e.rescaleY;\n        }\n        chart.update();\n      });\n\n      //============================================================\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Event Handling/Dispatching (out of chart's scope)\n  //------------------------------------------------------------\n\n  lines.dispatch.on('elementMouseover.tooltip', function (e) {\n    e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];\n    dispatch.tooltipShow(e);\n  });\n  lines.dispatch.on('elementMouseout.tooltip', function (e) {\n    dispatch.tooltipHide(e);\n  });\n  dispatch.on('tooltipHide', function () {\n    if (tooltips) nv.tooltip.cleanup();\n  });\n\n  //============================================================\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  // expose chart's sub-components\n  chart.dispatch = dispatch;\n  chart.lines = lines;\n  chart.legend = legend;\n  chart.xAxis = xAxis;\n  chart.yAxis = yAxis;\n  chart.interactiveLayer = interactiveLayer;\n  d3v3.rebind(chart, lines, 'defined', 'isArea', 'x', 'y', 'xScale', 'yScale', 'size', 'xDomain', 'yDomain', 'xRange', 'yRange', 'forceX', 'forceY', 'interactive', 'clipEdge', 'clipVoronoi', 'useVoronoi', 'id');\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    legend.color(color);\n    return chart;\n  };\n  chart.rescaleY = function (_) {\n    if (!arguments.length) return rescaleY;\n    rescaleY = _;\n    return chart;\n  };\n  chart.showControls = function (_) {\n    if (!arguments.length) return showControls;\n    showControls = _;\n    return chart;\n  };\n  chart.useInteractiveGuideline = function (_) {\n    if (!arguments.length) return useInteractiveGuideline;\n    useInteractiveGuideline = _;\n    if (_ === true) {\n      chart.interactive(false);\n      chart.useVoronoi(false);\n    }\n    return chart;\n  };\n  chart.showLegend = function (_) {\n    if (!arguments.length) return showLegend;\n    showLegend = _;\n    return chart;\n  };\n  chart.showXAxis = function (_) {\n    if (!arguments.length) return showXAxis;\n    showXAxis = _;\n    return chart;\n  };\n  chart.showYAxis = function (_) {\n    if (!arguments.length) return showYAxis;\n    showYAxis = _;\n    return chart;\n  };\n  chart.rightAlignYAxis = function (_) {\n    if (!arguments.length) return rightAlignYAxis;\n    rightAlignYAxis = _;\n    yAxis.orient(_ ? 'right' : 'left');\n    return chart;\n  };\n  chart.tooltips = function (_) {\n    if (!arguments.length) return tooltips;\n    tooltips = _;\n    return chart;\n  };\n  chart.tooltipContent = function (_) {\n    if (!arguments.length) return tooltip;\n    tooltip = _;\n    return chart;\n  };\n  chart.state = function (_) {\n    if (!arguments.length) return state;\n    state = _;\n    return chart;\n  };\n  chart.defaultState = function (_) {\n    if (!arguments.length) return defaultState;\n    defaultState = _;\n    return chart;\n  };\n  chart.noData = function (_) {\n    if (!arguments.length) return noData;\n    noData = _;\n    return chart;\n  };\n  chart.average = function (_) {\n    if (!arguments.length) return average;\n    average = _;\n    return chart;\n  };\n  chart.transitionDuration = function (_) {\n    if (!arguments.length) return transitionDuration;\n    transitionDuration = _;\n    return chart;\n  };\n  chart.noErrorCheck = function (_) {\n    if (!arguments.length) return noErrorCheck;\n    noErrorCheck = _;\n    return chart;\n  };\n\n  //============================================================\n\n  //============================================================\n  // Functions\n  //------------------------------------------------------------\n\n  /* Normalize the data according to an index point. */\n  function indexify(idx, data) {\n    return data.map(function (line, i) {\n      if (!line.values) {\n        return line;\n      }\n      var indexValue = line.values[idx];\n      if (indexValue == null) {\n        return line;\n      }\n      var v = lines.y()(indexValue, idx);\n\n      //TODO: implement check below, and disable series if series loses 100% or more cause divide by 0 issue\n      if (v < -.95 && !noErrorCheck) {\n        //if a series loses more than 100%, calculations fail.. anything close can cause major distortion (but is mathematically correct till it hits 100)\n\n        line.tempDisabled = true;\n        return line;\n      }\n      line.tempDisabled = false;\n      line.values = line.values.map(function (point, pointIndex) {\n        point.display = {\n          'y': (lines.y()(point, pointIndex) - v) / (1 + v)\n        };\n        return point;\n      });\n      return line;\n    });\n  }\n\n  //============================================================\n\n  return chart;\n};\n//TODO: consider deprecating by adding necessary features to multiBar model\nnv.models.discreteBar = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var margin = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    },\n    width = 960,\n    height = 500,\n    id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one\n    ,\n    x = d3v3.scale.ordinal(),\n    y = d3v3.scale.linear(),\n    getX = function getX(d) {\n      return d.x;\n    },\n    getY = function getY(d) {\n      return d.y;\n    },\n    forceY = [0] // 0 is forced by default.. this makes sense for the majority of bar graphs... user can always do chart.forceY([]) to remove\n    ,\n    color = nv.utils.defaultColor(),\n    showValues = false,\n    valueFormat = d3v3.format(',.2f'),\n    xDomain,\n    yDomain,\n    xRange,\n    yRange,\n    dispatch = d3v3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout'),\n    rectClass = 'discreteBar';\n\n  //============================================================\n\n  //============================================================\n  // Private Variables\n  //------------------------------------------------------------\n\n  var x0, y0;\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var availableWidth = width - margin.left - margin.right,\n        availableHeight = height - margin.top - margin.bottom,\n        container = d3v3.select(this);\n\n      //add series index to each data point for reference\n      data.forEach(function (series, i) {\n        series.values.forEach(function (point) {\n          point.series = i;\n        });\n      });\n\n      //------------------------------------------------------------\n      // Setup Scales\n\n      // remap and flatten the data for use in calculating the scales' domains\n      var seriesData = xDomain && yDomain ? [] :\n      // if we know xDomain and yDomain, no need to calculate\n      data.map(function (d) {\n        return d.values.map(function (d, i) {\n          return {\n            x: getX(d, i),\n            y: getY(d, i),\n            y0: d.y0\n          };\n        });\n      });\n      x.domain(xDomain || d3v3.merge(seriesData).map(function (d) {\n        return d.x;\n      })).rangeBands(xRange || [0, availableWidth], .1);\n      y.domain(yDomain || d3v3.extent(d3v3.merge(seriesData).map(function (d) {\n        return d.y;\n      }).concat(forceY)));\n\n      // If showValues, pad the Y axis range to account for label height\n      if (showValues) y.range(yRange || [availableHeight - (y.domain()[0] < 0 ? 12 : 0), y.domain()[1] > 0 ? 12 : 0]);else y.range(yRange || [availableHeight, 0]);\n\n      //store old scales if they exist\n      x0 = x0 || x;\n      y0 = y0 || y.copy().range([y(0), y(0)]);\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = container.selectAll('g.nv-wrap.nv-discretebar').data([data]);\n      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-discretebar');\n      var gEnter = wrapEnter.append('g');\n      var g = wrap.select('g');\n      gEnter.append('g').attr('class', 'nv-groups');\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n      //------------------------------------------------------------\n\n      //TODO: by definition, the discrete bar should not have multiple groups, will modify/remove later\n      var groups = wrap.select('.nv-groups').selectAll('.nv-group').data(function (d) {\n        return d;\n      }, function (d) {\n        return d.key;\n      });\n      groups.enter().append('g').style('stroke-opacity', 1e-6).style('fill-opacity', 1e-6);\n      groups.exit().transition().style('stroke-opacity', 1e-6).style('fill-opacity', 1e-6).remove();\n      groups.attr('class', function (d, i) {\n        return 'nv-group nv-series-' + i;\n      }).classed('hover', function (d) {\n        return d.hover;\n      });\n      groups.transition().style('stroke-opacity', 1).style('fill-opacity', .75);\n      var bars = groups.selectAll('g.nv-bar').data(function (d) {\n        return d.values;\n      });\n      bars.exit().remove();\n      var barsEnter = bars.enter().append('g').attr('transform', function (d, i, j) {\n        return 'translate(' + (x(getX(d, i)) + x.rangeBand() * .05) + ', ' + y(0) + ')';\n      }).on('mouseover', function (d, i) {\n        //TODO: figure out why j works above, but not here\n        d3v3.select(this).classed('hover', true);\n        dispatch.elementMouseover({\n          value: getY(d, i),\n          point: d,\n          series: data[d.series],\n          pos: [x(getX(d, i)) + x.rangeBand() * (d.series + .5) / data.length, y(getY(d, i))],\n          // TODO: Figure out why the value appears to be shifted\n          pointIndex: i,\n          seriesIndex: d.series,\n          e: d3v3.event\n        });\n      }).on('mouseout', function (d, i) {\n        d3v3.select(this).classed('hover', false);\n        dispatch.elementMouseout({\n          value: getY(d, i),\n          point: d,\n          series: data[d.series],\n          pointIndex: i,\n          seriesIndex: d.series,\n          e: d3v3.event\n        });\n      }).on('click', function (d, i) {\n        dispatch.elementClick({\n          value: getY(d, i),\n          point: d,\n          series: data[d.series],\n          pos: [x(getX(d, i)) + x.rangeBand() * (d.series + .5) / data.length, y(getY(d, i))],\n          // TODO: Figure out why the value appears to be shifted\n          pointIndex: i,\n          seriesIndex: d.series,\n          e: d3v3.event\n        });\n        d3v3.event.stopPropagation();\n      }).on('dblclick', function (d, i) {\n        dispatch.elementDblClick({\n          value: getY(d, i),\n          point: d,\n          series: data[d.series],\n          pos: [x(getX(d, i)) + x.rangeBand() * (d.series + .5) / data.length, y(getY(d, i))],\n          // TODO: Figure out why the value appears to be shifted\n          pointIndex: i,\n          seriesIndex: d.series,\n          e: d3v3.event\n        });\n        d3v3.event.stopPropagation();\n      });\n      barsEnter.append('rect').attr('height', 0).attr('width', x.rangeBand() * .9 / data.length);\n      if (showValues) {\n        barsEnter.append('text').attr('text-anchor', 'middle');\n        bars.select('text').text(function (d, i) {\n          return valueFormat(getY(d, i));\n        }).transition().attr('x', x.rangeBand() * .9 / 2).attr('y', function (d, i) {\n          return getY(d, i) < 0 ? y(getY(d, i)) - y(0) + 12 : -4;\n        });\n      } else {\n        bars.selectAll('text').remove();\n      }\n      bars.attr('class', function (d, i) {\n        return getY(d, i) < 0 ? 'nv-bar negative' : 'nv-bar positive';\n      }).style('fill', function (d, i) {\n        return d.color || color(d, i);\n      }).style('stroke', function (d, i) {\n        return d.color || color(d, i);\n      }).select('rect').attr('class', rectClass).transition().attr('width', x.rangeBand() * .9 / data.length);\n      bars.transition()\n      //.delay(function(d,i) { return i * 1200 / data[0].values.length })\n      .attr('transform', function (d, i) {\n        var left = x(getX(d, i)) + x.rangeBand() * .05,\n          top = getY(d, i) < 0 ? y(0) : y(0) - y(getY(d, i)) < 1 ? y(0) - 1 :\n          //make 1 px positive bars show up above y=0\n          y(getY(d, i));\n        return 'translate(' + left + ', ' + top + ')';\n      }).select('rect').attr('height', function (d, i) {\n        return Math.max(Math.abs(y(getY(d, i)) - y(yDomain && yDomain[0] || 0)) || 1);\n      });\n\n      //store old scales for use in transitions on update\n      x0 = x.copy();\n      y0 = y.copy();\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  chart.dispatch = dispatch;\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.x = function (_) {\n    if (!arguments.length) return getX;\n    getX = _;\n    return chart;\n  };\n  chart.y = function (_) {\n    if (!arguments.length) return getY;\n    getY = _;\n    return chart;\n  };\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.xScale = function (_) {\n    if (!arguments.length) return x;\n    x = _;\n    return chart;\n  };\n  chart.yScale = function (_) {\n    if (!arguments.length) return y;\n    y = _;\n    return chart;\n  };\n  chart.xDomain = function (_) {\n    if (!arguments.length) return xDomain;\n    xDomain = _;\n    return chart;\n  };\n  chart.yDomain = function (_) {\n    if (!arguments.length) return yDomain;\n    yDomain = _;\n    return chart;\n  };\n  chart.xRange = function (_) {\n    if (!arguments.length) return xRange;\n    xRange = _;\n    return chart;\n  };\n  chart.yRange = function (_) {\n    if (!arguments.length) return yRange;\n    yRange = _;\n    return chart;\n  };\n  chart.forceY = function (_) {\n    if (!arguments.length) return forceY;\n    forceY = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    return chart;\n  };\n  chart.id = function (_) {\n    if (!arguments.length) return id;\n    id = _;\n    return chart;\n  };\n  chart.showValues = function (_) {\n    if (!arguments.length) return showValues;\n    showValues = _;\n    return chart;\n  };\n  chart.valueFormat = function (_) {\n    if (!arguments.length) return valueFormat;\n    valueFormat = _;\n    return chart;\n  };\n  chart.rectClass = function (_) {\n    if (!arguments.length) return rectClass;\n    rectClass = _;\n    return chart;\n  };\n  //============================================================\n\n  return chart;\n};\nnv.models.discreteBarChart = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var discretebar = nv.models.discreteBar(),\n    xAxis = nv.models.axis(),\n    yAxis = nv.models.axis();\n  var margin = {\n      top: 15,\n      right: 10,\n      bottom: 50,\n      left: 60\n    },\n    width = null,\n    height = null,\n    color = nv.utils.getColor(),\n    showXAxis = true,\n    showYAxis = true,\n    rightAlignYAxis = false,\n    staggerLabels = false,\n    tooltips = true,\n    tooltip = function tooltip(key, x, y, e, graph) {\n      return '<h3>' + x + '</h3>' + '<p>' + y + '</p>';\n    },\n    x,\n    y,\n    noData = \"No Data Available.\",\n    dispatch = d3v3.dispatch('tooltipShow', 'tooltipHide', 'beforeUpdate'),\n    transitionDuration = 250;\n  xAxis.orient('bottom').highlightZero(false).showMaxMin(false).tickFormat(function (d) {\n    return d;\n  });\n  yAxis.orient(rightAlignYAxis ? 'right' : 'left').tickFormat(d3v3.format(',.1f'));\n\n  //============================================================\n\n  //============================================================\n  // Private Variables\n  //------------------------------------------------------------\n\n  var showTooltip = function showTooltip(e, offsetElement) {\n    var left = e.pos[0] + (offsetElement.offsetLeft || 0),\n      top = e.pos[1] + (offsetElement.offsetTop || 0),\n      x = xAxis.tickFormat()(discretebar.x()(e.point, e.pointIndex)),\n      y = yAxis.tickFormat()(discretebar.y()(e.point, e.pointIndex)),\n      content = tooltip(e.series.key, x, y, e, chart);\n    nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);\n  };\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var container = d3v3.select(this),\n        that = this;\n      var availableWidth = (width || parseInt(container.style('width')) || 960) - margin.left - margin.right,\n        availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n      chart.update = function () {\n        dispatch.beforeUpdate();\n        container.transition().duration(transitionDuration).call(chart);\n      };\n      chart.container = this;\n\n      //------------------------------------------------------------\n      // Display No Data message if there's nothing to show.\n\n      if (!data || !data.length || !data.filter(function (d) {\n        return d.values.length;\n      }).length) {\n        var noDataText = container.selectAll('.nv-noData').data([noData]);\n        noDataText.enter().append('text').attr('class', 'nvd3 nv-noData').attr('dy', '-.7em').style('text-anchor', 'middle');\n        noDataText.attr('x', margin.left + availableWidth / 2).attr('y', margin.top + availableHeight / 2).text(function (d) {\n          return d;\n        });\n        return chart;\n      } else {\n        container.selectAll('.nv-noData').remove();\n      }\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Scales\n\n      x = discretebar.xScale();\n      y = discretebar.yScale().clamp(true);\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = container.selectAll('g.nv-wrap.nv-discreteBarWithAxes').data([data]);\n      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-discreteBarWithAxes').append('g');\n      var defsEnter = gEnter.append('defs');\n      var g = wrap.select('g');\n      gEnter.append('g').attr('class', 'nv-x nv-axis');\n      gEnter.append('g').attr('class', 'nv-y nv-axis').append('g').attr('class', 'nv-zeroLine').append('line');\n      gEnter.append('g').attr('class', 'nv-barsWrap');\n      g.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n      if (rightAlignYAxis) {\n        g.select(\".nv-y.nv-axis\").attr(\"transform\", \"translate(\" + availableWidth + \",0)\");\n      }\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Main Chart Component(s)\n\n      discretebar.width(availableWidth).height(availableHeight);\n      var barsWrap = g.select('.nv-barsWrap').datum(data.filter(function (d) {\n        return !d.disabled;\n      }));\n      barsWrap.transition().call(discretebar);\n\n      //------------------------------------------------------------\n\n      defsEnter.append('clipPath').attr('id', 'nv-x-label-clip-' + discretebar.id()).append('rect');\n      g.select('#nv-x-label-clip-' + discretebar.id() + ' rect').attr('width', x.rangeBand() * (staggerLabels ? 2 : 1)).attr('height', 16).attr('x', -x.rangeBand() / (staggerLabels ? 1 : 2));\n\n      //------------------------------------------------------------\n      // Setup Axes\n\n      if (showXAxis) {\n        xAxis.scale(x).ticks(availableWidth / 100).tickSize(-availableHeight, 0);\n        g.select('.nv-x.nv-axis').attr('transform', 'translate(0,' + (y.range()[0] + (discretebar.showValues() && y.domain()[0] < 0 ? 16 : 0)) + ')');\n        //d3v3.transition(g.select('.nv-x.nv-axis'))\n        g.select('.nv-x.nv-axis').transition().call(xAxis);\n        var xTicks = g.select('.nv-x.nv-axis').selectAll('g');\n        if (staggerLabels) {\n          xTicks.selectAll('text').attr('transform', function (d, i, j) {\n            return 'translate(0,' + (j % 2 == 0 ? '5' : '17') + ')';\n          });\n        }\n      }\n      if (showYAxis) {\n        yAxis.scale(y).ticks(availableHeight / 36).tickSize(-availableWidth, 0);\n        g.select('.nv-y.nv-axis').transition().call(yAxis);\n      }\n\n      // Zero line\n      g.select(\".nv-zeroLine line\").attr(\"x1\", 0).attr(\"x2\", availableWidth).attr(\"y1\", y(0)).attr(\"y2\", y(0));\n\n      //------------------------------------------------------------\n\n      //============================================================\n      // Event Handling/Dispatching (in chart's scope)\n      //------------------------------------------------------------\n\n      dispatch.on('tooltipShow', function (e) {\n        if (tooltips) showTooltip(e, that.parentNode);\n      });\n\n      //============================================================\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Event Handling/Dispatching (out of chart's scope)\n  //------------------------------------------------------------\n\n  discretebar.dispatch.on('elementMouseover.tooltip', function (e) {\n    e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];\n    dispatch.tooltipShow(e);\n  });\n  discretebar.dispatch.on('elementMouseout.tooltip', function (e) {\n    dispatch.tooltipHide(e);\n  });\n  dispatch.on('tooltipHide', function () {\n    if (tooltips) nv.tooltip.cleanup();\n  });\n\n  //============================================================\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  // expose chart's sub-components\n  chart.dispatch = dispatch;\n  chart.discretebar = discretebar;\n  chart.xAxis = xAxis;\n  chart.yAxis = yAxis;\n  d3v3.rebind(chart, discretebar, 'x', 'y', 'xDomain', 'yDomain', 'xRange', 'yRange', 'forceX', 'forceY', 'id', 'showValues', 'valueFormat');\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    discretebar.color(color);\n    return chart;\n  };\n  chart.showXAxis = function (_) {\n    if (!arguments.length) return showXAxis;\n    showXAxis = _;\n    return chart;\n  };\n  chart.showYAxis = function (_) {\n    if (!arguments.length) return showYAxis;\n    showYAxis = _;\n    return chart;\n  };\n  chart.rightAlignYAxis = function (_) {\n    if (!arguments.length) return rightAlignYAxis;\n    rightAlignYAxis = _;\n    yAxis.orient(_ ? 'right' : 'left');\n    return chart;\n  };\n  chart.staggerLabels = function (_) {\n    if (!arguments.length) return staggerLabels;\n    staggerLabels = _;\n    return chart;\n  };\n  chart.tooltips = function (_) {\n    if (!arguments.length) return tooltips;\n    tooltips = _;\n    return chart;\n  };\n  chart.tooltipContent = function (_) {\n    if (!arguments.length) return tooltip;\n    tooltip = _;\n    return chart;\n  };\n  chart.noData = function (_) {\n    if (!arguments.length) return noData;\n    noData = _;\n    return chart;\n  };\n  chart.transitionDuration = function (_) {\n    if (!arguments.length) return transitionDuration;\n    transitionDuration = _;\n    return chart;\n  };\n\n  //============================================================\n\n  return chart;\n};\nnv.models.distribution = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var margin = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    },\n    width = 400 //technically width or height depending on x or y....\n    ,\n    size = 8,\n    axis = 'x' // 'x' or 'y'... horizontal or vertical\n    ,\n    getData = function getData(d) {\n      return d[axis];\n    } // defaults d.x or d.y\n    ,\n    color = nv.utils.defaultColor(),\n    scale = d3v3.scale.linear(),\n    domain;\n\n  //============================================================\n\n  //============================================================\n  // Private Variables\n  //------------------------------------------------------------\n\n  var scale0;\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var availableLength = width - (axis === 'x' ? margin.left + margin.right : margin.top + margin.bottom),\n        naxis = axis == 'x' ? 'y' : 'x',\n        container = d3v3.select(this);\n\n      //------------------------------------------------------------\n      // Setup Scales\n\n      scale0 = scale0 || scale;\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = container.selectAll('g.nv-distribution').data([data]);\n      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-distribution');\n      var gEnter = wrapEnter.append('g');\n      var g = wrap.select('g');\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n      //------------------------------------------------------------\n\n      var distWrap = g.selectAll('g.nv-dist').data(function (d) {\n        return d;\n      }, function (d) {\n        return d.key;\n      });\n      distWrap.enter().append('g');\n      distWrap.attr('class', function (d, i) {\n        return 'nv-dist nv-series-' + i;\n      }).style('stroke', function (d, i) {\n        return color(d, i);\n      });\n      var dist = distWrap.selectAll('line.nv-dist' + axis).data(function (d) {\n        return d.values;\n      });\n      dist.enter().append('line').attr(axis + '1', function (d, i) {\n        return scale0(getData(d, i));\n      }).attr(axis + '2', function (d, i) {\n        return scale0(getData(d, i));\n      });\n      distWrap.exit().selectAll('line.nv-dist' + axis).transition().attr(axis + '1', function (d, i) {\n        return scale(getData(d, i));\n      }).attr(axis + '2', function (d, i) {\n        return scale(getData(d, i));\n      }).style('stroke-opacity', 0).remove();\n      dist.attr('class', function (d, i) {\n        return 'nv-dist' + axis + ' nv-dist' + axis + '-' + i;\n      }).attr(naxis + '1', 0).attr(naxis + '2', size);\n      dist.transition().attr(axis + '1', function (d, i) {\n        return scale(getData(d, i));\n      }).attr(axis + '2', function (d, i) {\n        return scale(getData(d, i));\n      });\n      scale0 = scale.copy();\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.axis = function (_) {\n    if (!arguments.length) return axis;\n    axis = _;\n    return chart;\n  };\n  chart.size = function (_) {\n    if (!arguments.length) return size;\n    size = _;\n    return chart;\n  };\n  chart.getData = function (_) {\n    if (!arguments.length) return getData;\n    getData = d3v3.functor(_);\n    return chart;\n  };\n  chart.scale = function (_) {\n    if (!arguments.length) return scale;\n    scale = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    return chart;\n  };\n  //============================================================\n\n  return chart;\n};\nnv.models.historicalBarChart = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var bars = nv.models.historicalBar(),\n    xAxis = nv.models.axis(),\n    yAxis = nv.models.axis(),\n    legend = nv.models.legend();\n  var margin = {\n      top: 30,\n      right: 90,\n      bottom: 50,\n      left: 90\n    },\n    color = nv.utils.defaultColor(),\n    width = null,\n    height = null,\n    showLegend = false,\n    showXAxis = true,\n    showYAxis = true,\n    rightAlignYAxis = false,\n    tooltips = true,\n    tooltip = function tooltip(key, x, y, e, graph) {\n      return '<h3>' + key + '</h3>' + '<p>' + y + ' at ' + x + '</p>';\n    },\n    x,\n    y,\n    state = {},\n    defaultState = null,\n    noData = 'No Data Available.',\n    dispatch = d3v3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState'),\n    transitionDuration = 250;\n  xAxis.orient('bottom').tickPadding(7);\n  yAxis.orient(rightAlignYAxis ? 'right' : 'left');\n\n  //============================================================\n\n  //============================================================\n  // Private Variables\n  //------------------------------------------------------------\n\n  var showTooltip = function showTooltip(e, offsetElement) {\n    // New addition to calculate position if SVG is scaled with viewBox, may move TODO: consider implementing everywhere else\n    if (offsetElement) {\n      var svg = d3v3.select(offsetElement).select('svg');\n      var viewBox = svg.node() ? svg.attr('viewBox') : null;\n      if (viewBox) {\n        viewBox = viewBox.split(' ');\n        var ratio = parseInt(svg.style('width')) / viewBox[2];\n        e.pos[0] = e.pos[0] * ratio;\n        e.pos[1] = e.pos[1] * ratio;\n      }\n    }\n    var left = e.pos[0] + (offsetElement.offsetLeft || 0),\n      top = e.pos[1] + (offsetElement.offsetTop || 0),\n      x = xAxis.tickFormat()(bars.x()(e.point, e.pointIndex)),\n      y = yAxis.tickFormat()(bars.y()(e.point, e.pointIndex)),\n      content = tooltip(e.series.key, x, y, e, chart);\n    nv.tooltip.show([left, top], content, null, null, offsetElement);\n  };\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var container = d3v3.select(this),\n        that = this;\n      var availableWidth = (width || parseInt(container.style('width')) || 960) - margin.left - margin.right,\n        availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n      chart.update = function () {\n        container.transition().duration(transitionDuration).call(chart);\n      };\n      chart.container = this;\n\n      //set state.disabled\n      state.disabled = data.map(function (d) {\n        return !!d.disabled;\n      });\n      if (!defaultState) {\n        var key;\n        defaultState = {};\n        for (key in state) {\n          if (state[key] instanceof Array) defaultState[key] = state[key].slice(0);else defaultState[key] = state[key];\n        }\n      }\n\n      //------------------------------------------------------------\n      // Display noData message if there's nothing to show.\n\n      if (!data || !data.length || !data.filter(function (d) {\n        return d.values.length;\n      }).length) {\n        var noDataText = container.selectAll('.nv-noData').data([noData]);\n        noDataText.enter().append('text').attr('class', 'nvd3 nv-noData').attr('dy', '-.7em').style('text-anchor', 'middle');\n        noDataText.attr('x', margin.left + availableWidth / 2).attr('y', margin.top + availableHeight / 2).text(function (d) {\n          return d;\n        });\n        return chart;\n      } else {\n        container.selectAll('.nv-noData').remove();\n      }\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Scales\n\n      x = bars.xScale();\n      y = bars.yScale();\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = container.selectAll('g.nv-wrap.nv-historicalBarChart').data([data]);\n      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-historicalBarChart').append('g');\n      var g = wrap.select('g');\n      gEnter.append('g').attr('class', 'nv-x nv-axis');\n      gEnter.append('g').attr('class', 'nv-y nv-axis');\n      gEnter.append('g').attr('class', 'nv-barsWrap');\n      gEnter.append('g').attr('class', 'nv-legendWrap');\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Legend\n\n      if (showLegend) {\n        legend.width(availableWidth);\n        g.select('.nv-legendWrap').datum(data).call(legend);\n        if (margin.top != legend.height()) {\n          margin.top = legend.height();\n          availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n        }\n        wrap.select('.nv-legendWrap').attr('transform', 'translate(0,' + -margin.top + ')');\n      }\n\n      //------------------------------------------------------------\n\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n      if (rightAlignYAxis) {\n        g.select(\".nv-y.nv-axis\").attr(\"transform\", \"translate(\" + availableWidth + \",0)\");\n      }\n\n      //------------------------------------------------------------\n      // Main Chart Component(s)\n\n      bars.width(availableWidth).height(availableHeight).color(data.map(function (d, i) {\n        return d.color || color(d, i);\n      }).filter(function (d, i) {\n        return !data[i].disabled;\n      }));\n      var barsWrap = g.select('.nv-barsWrap').datum(data.filter(function (d) {\n        return !d.disabled;\n      }));\n      barsWrap.transition().call(bars);\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Axes\n\n      if (showXAxis) {\n        xAxis.scale(x).tickSize(-availableHeight, 0);\n        g.select('.nv-x.nv-axis').attr('transform', 'translate(0,' + y.range()[0] + ')');\n        g.select('.nv-x.nv-axis').transition().call(xAxis);\n      }\n      if (showYAxis) {\n        yAxis.scale(y).ticks(availableHeight / 36).tickSize(-availableWidth, 0);\n        g.select('.nv-y.nv-axis').transition().call(yAxis);\n      }\n      //------------------------------------------------------------\n\n      //============================================================\n      // Event Handling/Dispatching (in chart's scope)\n      //------------------------------------------------------------\n\n      legend.dispatch.on('legendClick', function (d, i) {\n        d.disabled = !d.disabled;\n        if (!data.filter(function (d) {\n          return !d.disabled;\n        }).length) {\n          data.map(function (d) {\n            d.disabled = false;\n            wrap.selectAll('.nv-series').classed('disabled', false);\n            return d;\n          });\n        }\n        state.disabled = data.map(function (d) {\n          return !!d.disabled;\n        });\n        dispatch.stateChange(state);\n        selection.transition().call(chart);\n      });\n      legend.dispatch.on('legendDblclick', function (d) {\n        //Double clicking should always enable current series, and disabled all others.\n        data.forEach(function (d) {\n          d.disabled = true;\n        });\n        d.disabled = false;\n        state.disabled = data.map(function (d) {\n          return !!d.disabled;\n        });\n        dispatch.stateChange(state);\n        chart.update();\n      });\n      dispatch.on('tooltipShow', function (e) {\n        if (tooltips) showTooltip(e, that.parentNode);\n      });\n      dispatch.on('changeState', function (e) {\n        if (typeof e.disabled !== 'undefined') {\n          data.forEach(function (series, i) {\n            series.disabled = e.disabled[i];\n          });\n          state.disabled = e.disabled;\n        }\n        chart.update();\n      });\n\n      //============================================================\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Event Handling/Dispatching (out of chart's scope)\n  //------------------------------------------------------------\n\n  bars.dispatch.on('elementMouseover.tooltip', function (e) {\n    e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];\n    dispatch.tooltipShow(e);\n  });\n  bars.dispatch.on('elementMouseout.tooltip', function (e) {\n    dispatch.tooltipHide(e);\n  });\n  dispatch.on('tooltipHide', function () {\n    if (tooltips) nv.tooltip.cleanup();\n  });\n\n  //============================================================\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  // expose chart's sub-components\n  chart.dispatch = dispatch;\n  chart.bars = bars;\n  chart.legend = legend;\n  chart.xAxis = xAxis;\n  chart.yAxis = yAxis;\n  d3v3.rebind(chart, bars, 'defined', 'isArea', 'x', 'y', 'size', 'xScale', 'yScale', 'xDomain', 'yDomain', 'xRange', 'yRange', 'forceX', 'forceY', 'interactive', 'clipEdge', 'clipVoronoi', 'id', 'interpolate', 'highlightPoint', 'clearHighlights', 'interactive');\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    legend.color(color);\n    return chart;\n  };\n  chart.showLegend = function (_) {\n    if (!arguments.length) return showLegend;\n    showLegend = _;\n    return chart;\n  };\n  chart.showXAxis = function (_) {\n    if (!arguments.length) return showXAxis;\n    showXAxis = _;\n    return chart;\n  };\n  chart.showYAxis = function (_) {\n    if (!arguments.length) return showYAxis;\n    showYAxis = _;\n    return chart;\n  };\n  chart.rightAlignYAxis = function (_) {\n    if (!arguments.length) return rightAlignYAxis;\n    rightAlignYAxis = _;\n    yAxis.orient(_ ? 'right' : 'left');\n    return chart;\n  };\n  chart.tooltips = function (_) {\n    if (!arguments.length) return tooltips;\n    tooltips = _;\n    return chart;\n  };\n  chart.tooltipContent = function (_) {\n    if (!arguments.length) return tooltip;\n    tooltip = _;\n    return chart;\n  };\n  chart.state = function (_) {\n    if (!arguments.length) return state;\n    state = _;\n    return chart;\n  };\n  chart.defaultState = function (_) {\n    if (!arguments.length) return defaultState;\n    defaultState = _;\n    return chart;\n  };\n  chart.noData = function (_) {\n    if (!arguments.length) return noData;\n    noData = _;\n    return chart;\n  };\n  chart.transitionDuration = function (_) {\n    if (!arguments.length) return transitionDuration;\n    transitionDuration = _;\n    return chart;\n  };\n\n  //============================================================\n\n  return chart;\n};\nnv.models.indentedTree = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var margin = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    } //TODO: implement, maybe as margin on the containing div\n    ,\n    width = 960,\n    height = 500,\n    color = nv.utils.defaultColor(),\n    id = Math.floor(Math.random() * 10000),\n    header = true,\n    filterZero = false,\n    noData = \"No Data Available.\",\n    childIndent = 20,\n    columns = [{\n      key: 'key',\n      label: 'Name',\n      type: 'text'\n    }] //TODO: consider functions like chart.addColumn, chart.removeColumn, instead of a block like this\n    ,\n    tableClass = null,\n    iconOpen = 'images/grey-plus.png' //TODO: consider removing this and replacing with a '+' or '-' unless user defines images\n    ,\n    iconClose = 'images/grey-minus.png',\n    dispatch = d3v3.dispatch('elementClick', 'elementDblclick', 'elementMouseover', 'elementMouseout'),\n    getUrl = function getUrl(d) {\n      return d.url;\n    };\n\n  //============================================================\n\n  var idx = 0;\n  function chart(selection) {\n    selection.each(function (data) {\n      var depth = 1,\n        container = d3v3.select(this);\n      var tree = d3v3.layout.tree().children(function (d) {\n        return d.values;\n      }).size([height, childIndent]); //Not sure if this is needed now that the result is HTML\n\n      chart.update = function () {\n        container.transition().duration(600).call(chart);\n      };\n\n      //------------------------------------------------------------\n      // Display No Data message if there's nothing to show.\n      if (!data[0]) data[0] = {\n        key: noData\n      };\n\n      //------------------------------------------------------------\n\n      var nodes = tree.nodes(data[0]);\n\n      // nodes.map(function(d) {\n      //   d.id = i++;\n      // })\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = d3v3.select(this).selectAll('div').data([[nodes]]);\n      var wrapEnter = wrap.enter().append('div').attr('class', 'nvd3 nv-wrap nv-indentedtree');\n      var tableEnter = wrapEnter.append('table');\n      var table = wrap.select('table').attr('width', '100%').attr('class', tableClass);\n\n      //------------------------------------------------------------\n\n      if (header) {\n        var thead = tableEnter.append('thead');\n        var theadRow1 = thead.append('tr');\n        columns.forEach(function (column) {\n          theadRow1.append('th').attr('width', column.width ? column.width : '10%').style('text-align', column.type == 'numeric' ? 'right' : 'left').append('span').text(column.label);\n        });\n      }\n      var tbody = table.selectAll('tbody').data(function (d) {\n        return d;\n      });\n      tbody.enter().append('tbody');\n\n      //compute max generations\n      depth = d3v3.max(nodes, function (node) {\n        return node.depth;\n      });\n      tree.size([height, depth * childIndent]); //TODO: see if this is necessary at all\n\n      // Update the nodes\n      var node = tbody.selectAll('tr')\n      // .data(function(d) { return d; }, function(d) { return d.id || (d.id == ++i)});\n      .data(function (d) {\n        return d.filter(function (d) {\n          return filterZero && !d.children ? filterZero(d) : true;\n        });\n      }, function (d, i) {\n        return d.id || d.id || ++idx;\n      });\n      //.style('display', 'table-row'); //TODO: see if this does anything\n\n      node.exit().remove();\n      node.select('img.nv-treeicon').attr('src', icon).classed('folded', folded);\n      var nodeEnter = node.enter().append('tr');\n      columns.forEach(function (column, index) {\n        var nodeName = nodeEnter.append('td').style('padding-left', function (d) {\n          return (index ? 0 : d.depth * childIndent + 12 + (icon(d) ? 0 : 16)) + 'px';\n        }, 'important') //TODO: check why I did the ternary here\n        .style('text-align', column.type == 'numeric' ? 'right' : 'left');\n        if (index == 0) {\n          nodeName.append('img').classed('nv-treeicon', true).classed('nv-folded', folded).attr('src', icon).style('width', '14px').style('height', '14px').style('padding', '0 1px').style('display', function (d) {\n            return icon(d) ? 'inline-block' : 'none';\n          }).on('click', click);\n        }\n        nodeName.each(function (d) {\n          if (!index && getUrl(d)) d3v3.select(this).append('a').attr('href', getUrl).attr('class', d3v3.functor(column.classes)).append('span');else d3v3.select(this).append('span');\n          d3v3.select(this).select('span').attr('class', d3v3.functor(column.classes)).text(function (d) {\n            return column.format ? d[column.key] ? column.format(d[column.key]) : '-' : d[column.key] || '-';\n          });\n        });\n        if (column.showCount) {\n          nodeName.append('span').attr('class', 'nv-childrenCount');\n          node.selectAll('span.nv-childrenCount').text(function (d) {\n            return d.values && d.values.length || d._values && d._values.length ?\n            //If this is a parent\n            '(' + (d.values && d.values.filter(function (d) {\n              return filterZero ? filterZero(d) : true;\n            }).length //If children are in values check its children and filter\n            || d._values && d._values.filter(function (d) {\n              return filterZero ? filterZero(d) : true;\n            }).length //Otherwise, do the same, but with the other name, _values...\n            || 0) + ')' //This is the catch-all in case there are no children after a filter\n            : ''; //If this is not a parent, just give an empty string\n          });\n        }\n\n        // if (column.click)\n        //   nodeName.select('span').on('click', column.click);\n      });\n      node.order().on('click', function (d) {\n        dispatch.elementClick({\n          row: this,\n          //TODO: decide whether or not this should be consistent with scatter/line events or should be an html link (a href)\n          data: d,\n          pos: [d.x, d.y]\n        });\n      }).on('dblclick', function (d) {\n        dispatch.elementDblclick({\n          row: this,\n          data: d,\n          pos: [d.x, d.y]\n        });\n      }).on('mouseover', function (d) {\n        dispatch.elementMouseover({\n          row: this,\n          data: d,\n          pos: [d.x, d.y]\n        });\n      }).on('mouseout', function (d) {\n        dispatch.elementMouseout({\n          row: this,\n          data: d,\n          pos: [d.x, d.y]\n        });\n      });\n\n      // Toggle children on click.\n      function click(d, _, unshift) {\n        d3v3.event.stopPropagation();\n        if (d3v3.event.shiftKey && !unshift) {\n          //If you shift-click, it'll toggle fold all the children, instead of itself\n          d3v3.event.shiftKey = false;\n          d.values && d.values.forEach(function (node) {\n            if (node.values || node._values) {\n              click(node, 0, true);\n            }\n          });\n          return true;\n        }\n        if (!hasChildren(d)) {\n          //download file\n          //window.location.href = d.url;\n          return true;\n        }\n        if (d.values) {\n          d._values = d.values;\n          d.values = null;\n        } else {\n          d.values = d._values;\n          d._values = null;\n        }\n        chart.update();\n      }\n      function icon(d) {\n        return d._values && d._values.length ? iconOpen : d.values && d.values.length ? iconClose : '';\n      }\n      function folded(d) {\n        return d._values && d._values.length;\n      }\n      function hasChildren(d) {\n        var values = d.values || d._values;\n        return values && values.length;\n      }\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    scatter.color(color);\n    return chart;\n  };\n  chart.id = function (_) {\n    if (!arguments.length) return id;\n    id = _;\n    return chart;\n  };\n  chart.header = function (_) {\n    if (!arguments.length) return header;\n    header = _;\n    return chart;\n  };\n  chart.noData = function (_) {\n    if (!arguments.length) return noData;\n    noData = _;\n    return chart;\n  };\n  chart.filterZero = function (_) {\n    if (!arguments.length) return filterZero;\n    filterZero = _;\n    return chart;\n  };\n  chart.columns = function (_) {\n    if (!arguments.length) return columns;\n    columns = _;\n    return chart;\n  };\n  chart.tableClass = function (_) {\n    if (!arguments.length) return tableClass;\n    tableClass = _;\n    return chart;\n  };\n  chart.iconOpen = function (_) {\n    if (!arguments.length) return iconOpen;\n    iconOpen = _;\n    return chart;\n  };\n  chart.iconClose = function (_) {\n    if (!arguments.length) return iconClose;\n    iconClose = _;\n    return chart;\n  };\n  chart.getUrl = function (_) {\n    if (!arguments.length) return getUrl;\n    getUrl = _;\n    return chart;\n  };\n\n  //============================================================\n\n  return chart;\n};\nnv.models.legend = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var margin = {\n      top: 5,\n      right: 0,\n      bottom: 5,\n      left: 0\n    },\n    width = 400,\n    height = 20,\n    getKey = function getKey(d) {\n      return d.key;\n    },\n    color = nv.utils.defaultColor(),\n    align = true,\n    rightAlign = true,\n    updateState = true //If true, legend will update data.disabled and trigger a 'stateChange' dispatch.\n    ,\n    radioButtonMode = false //If true, clicking legend items will cause it to behave like a radio button. (only one can be selected at a time)\n    ,\n    dispatch = d3v3.dispatch('legendClick', 'legendDblclick', 'legendMouseover', 'legendMouseout', 'stateChange');\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var availableWidth = width - margin.left - margin.right,\n        container = d3v3.select(this);\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = container.selectAll('g.nv-legend').data([data]);\n      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-legend').append('g');\n      var g = wrap.select('g');\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n      //------------------------------------------------------------\n\n      var series = g.selectAll('.nv-series').data(function (d) {\n        return d;\n      });\n      var seriesEnter = series.enter().append('g').attr('class', 'nv-series').on('mouseover', function (d, i) {\n        dispatch.legendMouseover(d, i); //TODO: Make consistent with other event objects\n      }).on('mouseout', function (d, i) {\n        dispatch.legendMouseout(d, i);\n      }).on('click', function (d, i) {\n        dispatch.legendClick(d, i);\n        if (updateState) {\n          if (radioButtonMode) {\n            //Radio button mode: set every series to disabled,\n            //  and enable the clicked series.\n            data.forEach(function (series) {\n              series.disabled = true;\n            });\n            d.disabled = false;\n          } else {\n            d.disabled = !d.disabled;\n            if (data.every(function (series) {\n              return series.disabled;\n            })) {\n              //the default behavior of NVD3 legends is, if every single series\n              // is disabled, turn all series' back on.\n              data.forEach(function (series) {\n                series.disabled = false;\n              });\n            }\n          }\n          dispatch.stateChange({\n            disabled: data.map(function (d) {\n              return !!d.disabled;\n            })\n          });\n        }\n      }).on('dblclick', function (d, i) {\n        dispatch.legendDblclick(d, i);\n        if (updateState) {\n          //the default behavior of NVD3 legends, when double clicking one,\n          // is to set all other series' to false, and make the double clicked series enabled.\n          data.forEach(function (series) {\n            series.disabled = true;\n          });\n          d.disabled = false;\n          dispatch.stateChange({\n            disabled: data.map(function (d) {\n              return !!d.disabled;\n            })\n          });\n        }\n      });\n      seriesEnter.append('circle').style('stroke-width', 2).attr('class', 'nv-legend-symbol').attr('r', 5);\n      seriesEnter.append('text').attr('text-anchor', 'start').attr('class', 'nv-legend-text').attr('dy', '.32em').attr('dx', '8');\n      series.classed('disabled', function (d) {\n        return d.disabled;\n      });\n      series.exit().remove();\n      series.select('circle').style('fill', function (d, i) {\n        return d.color || color(d, i);\n      }).style('stroke', function (d, i) {\n        return d.color || color(d, i);\n      });\n      series.select('text').text(getKey);\n\n      //TODO: implement fixed-width and max-width options (max-width is especially useful with the align option)\n\n      // NEW ALIGNING CODE, TODO: clean up\n      if (align) {\n        var seriesWidths = [];\n        series.each(function (d, i) {\n          var legendText = d3v3.select(this).select('text');\n          var nodeTextLength;\n          try {\n            nodeTextLength = legendText.getComputedTextLength();\n            // If the legendText is display:none'd (nodeTextLength == 0), simulate an error so we approximate, instead\n            if (nodeTextLength <= 0) throw Error();\n          } catch (e) {\n            nodeTextLength = nv.utils.calcApproxTextWidth(legendText);\n          }\n          seriesWidths.push(nodeTextLength + 28); // 28 is ~ the width of the circle plus some padding\n        });\n        var seriesPerRow = 0;\n        var legendWidth = 0;\n        var columnWidths = [];\n        while (legendWidth < availableWidth && seriesPerRow < seriesWidths.length) {\n          columnWidths[seriesPerRow] = seriesWidths[seriesPerRow];\n          legendWidth += seriesWidths[seriesPerRow++];\n        }\n        if (seriesPerRow === 0) seriesPerRow = 1; //minimum of one series per row\n\n        while (legendWidth > availableWidth && seriesPerRow > 1) {\n          columnWidths = [];\n          seriesPerRow--;\n          for (var k = 0; k < seriesWidths.length; k++) {\n            if (seriesWidths[k] > (columnWidths[k % seriesPerRow] || 0)) columnWidths[k % seriesPerRow] = seriesWidths[k];\n          }\n          legendWidth = columnWidths.reduce(function (prev, cur, index, array) {\n            return prev + cur;\n          });\n        }\n        var xPositions = [];\n        for (var i = 0, curX = 0; i < seriesPerRow; i++) {\n          xPositions[i] = curX;\n          curX += columnWidths[i];\n        }\n        series.attr('transform', function (d, i) {\n          return 'translate(' + xPositions[i % seriesPerRow] + ',' + (5 + Math.floor(i / seriesPerRow) * 20) + ')';\n        });\n\n        //position legend as far right as possible within the total width\n        if (rightAlign) {\n          g.attr('transform', 'translate(' + (width - margin.right - legendWidth) + ',' + margin.top + ')');\n        } else {\n          g.attr('transform', 'translate(0' + ',' + margin.top + ')');\n        }\n        height = margin.top + margin.bottom + Math.ceil(seriesWidths.length / seriesPerRow) * 20;\n      } else {\n        var ypos = 5,\n          newxpos = 5,\n          maxwidth = 0,\n          xpos;\n        series.attr('transform', function (d, i) {\n          var length = d3v3.select(this).select('text').node().getComputedTextLength() + 28;\n          xpos = newxpos;\n          if (width < margin.left + margin.right + xpos + length) {\n            newxpos = xpos = 5;\n            ypos += 20;\n          }\n          newxpos += length;\n          if (newxpos > maxwidth) maxwidth = newxpos;\n          return 'translate(' + xpos + ',' + ypos + ')';\n        });\n\n        //position legend as far right as possible within the total width\n        g.attr('transform', 'translate(' + (width - margin.right - maxwidth) + ',' + margin.top + ')');\n        height = margin.top + margin.bottom + ypos + 15;\n      }\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  chart.dispatch = dispatch;\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.key = function (_) {\n    if (!arguments.length) return getKey;\n    getKey = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    return chart;\n  };\n  chart.align = function (_) {\n    if (!arguments.length) return align;\n    align = _;\n    return chart;\n  };\n  chart.rightAlign = function (_) {\n    if (!arguments.length) return rightAlign;\n    rightAlign = _;\n    return chart;\n  };\n  chart.updateState = function (_) {\n    if (!arguments.length) return updateState;\n    updateState = _;\n    return chart;\n  };\n  chart.radioButtonMode = function (_) {\n    if (!arguments.length) return radioButtonMode;\n    radioButtonMode = _;\n    return chart;\n  };\n\n  //============================================================\n\n  return chart;\n};\nnv.models.line = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var scatter = nv.models.scatter();\n  var margin = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    },\n    width = 960,\n    height = 500,\n    color = nv.utils.defaultColor() // a function that returns a color\n    ,\n    getX = function getX(d) {\n      return d.x;\n    } // accessor to get the x value from a data point\n    ,\n    getY = function getY(d) {\n      return d.y;\n    } // accessor to get the y value from a data point\n    ,\n    defined = function defined(d, i) {\n      return !isNaN(getY(d, i)) && getY(d, i) !== null;\n    } // allows a line to be not continuous when it is not defined\n    ,\n    isArea = function isArea(d) {\n      return d.area;\n    } // decides if a line is an area or just a line\n    ,\n    clipEdge = false // if true, masks lines within x and y scale\n    ,\n    x //can be accessed via chart.xScale()\n    ,\n    y //can be accessed via chart.yScale()\n    ,\n    interpolate = \"linear\" // controls the line interpolation\n  ;\n  scatter.size(16) // default size\n  .sizeDomain([16, 256]) //set to speed up calculation, needs to be unset if there is a custom size accessor\n  ;\n\n  //============================================================\n\n  //============================================================\n  // Private Variables\n  //------------------------------------------------------------\n\n  var x0, y0 //used to store previous scales\n  ;\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var availableWidth = width - margin.left - margin.right,\n        availableHeight = height - margin.top - margin.bottom,\n        container = d3v3.select(this);\n\n      //------------------------------------------------------------\n      // Setup Scales\n\n      x = scatter.xScale();\n      y = scatter.yScale();\n      x0 = x0 || x;\n      y0 = y0 || y;\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = container.selectAll('g.nv-wrap.nv-line').data([data]);\n      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-line');\n      var defsEnter = wrapEnter.append('defs');\n      var gEnter = wrapEnter.append('g');\n      var g = wrap.select('g');\n      gEnter.append('g').attr('class', 'nv-groups');\n      gEnter.append('g').attr('class', 'nv-scatterWrap');\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n      //------------------------------------------------------------\n\n      scatter.width(availableWidth).height(availableHeight);\n      var scatterWrap = wrap.select('.nv-scatterWrap');\n      //.datum(data); // Data automatically trickles down from the wrap\n\n      scatterWrap.transition().call(scatter);\n      defsEnter.append('clipPath').attr('id', 'nv-edge-clip-' + scatter.id()).append('rect');\n      wrap.select('#nv-edge-clip-' + scatter.id() + ' rect').attr('width', availableWidth).attr('height', availableHeight > 0 ? availableHeight : 0);\n      g.attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + scatter.id() + ')' : '');\n      scatterWrap.attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + scatter.id() + ')' : '');\n      var groups = wrap.select('.nv-groups').selectAll('.nv-group').data(function (d) {\n        return d;\n      }, function (d) {\n        return d.key;\n      });\n      groups.enter().append('g').style('stroke-opacity', 1e-6).style('fill-opacity', 1e-6);\n      groups.exit().remove();\n      groups.attr('class', function (d, i) {\n        return 'nv-group nv-series-' + i;\n      }).classed('hover', function (d) {\n        return d.hover;\n      }).style('fill', function (d, i) {\n        return color(d, i);\n      }).style('stroke', function (d, i) {\n        return color(d, i);\n      });\n      groups.transition().style('stroke-opacity', 1).style('fill-opacity', .5);\n      var areaPaths = groups.selectAll('path.nv-area').data(function (d) {\n        return isArea(d) ? [d] : [];\n      }); // this is done differently than lines because I need to check if series is an area\n      areaPaths.enter().append('path').attr('class', 'nv-area').attr('d', function (d) {\n        return d3v3.svg.area().interpolate(interpolate).defined(defined).x(function (d, i) {\n          return nv.utils.NaNtoZero(x0(getX(d, i)));\n        }).y0(function (d, i) {\n          return nv.utils.NaNtoZero(y0(getY(d, i)));\n        }).y1(function (d, i) {\n          return y0(y.domain()[0] <= 0 ? y.domain()[1] >= 0 ? 0 : y.domain()[1] : y.domain()[0]);\n        })\n        //.y1(function(d,i) { return y0(0) }) //assuming 0 is within y domain.. may need to tweak this\n        .apply(this, [d.values]);\n      });\n      groups.exit().selectAll('path.nv-area').remove();\n      areaPaths.transition().attr('d', function (d) {\n        return d3v3.svg.area().interpolate(interpolate).defined(defined).x(function (d, i) {\n          return nv.utils.NaNtoZero(x(getX(d, i)));\n        }).y0(function (d, i) {\n          return nv.utils.NaNtoZero(y(getY(d, i)));\n        }).y1(function (d, i) {\n          return y(y.domain()[0] <= 0 ? y.domain()[1] >= 0 ? 0 : y.domain()[1] : y.domain()[0]);\n        })\n        //.y1(function(d,i) { return y0(0) }) //assuming 0 is within y domain.. may need to tweak this\n        .apply(this, [d.values]);\n      });\n      var linePaths = groups.selectAll('path.nv-line').data(function (d) {\n        return [d.values];\n      });\n      linePaths.enter().append('path').attr('class', 'nv-line').attr('d', d3v3.svg.line().interpolate(interpolate).defined(defined).x(function (d, i) {\n        return nv.utils.NaNtoZero(x0(getX(d, i)));\n      }).y(function (d, i) {\n        return nv.utils.NaNtoZero(y0(getY(d, i)));\n      }));\n      linePaths.transition().attr('d', d3v3.svg.line().interpolate(interpolate).defined(defined).x(function (d, i) {\n        return nv.utils.NaNtoZero(x(getX(d, i)));\n      }).y(function (d, i) {\n        return nv.utils.NaNtoZero(y(getY(d, i)));\n      }));\n\n      //store old scales for use in transitions on update\n      x0 = x.copy();\n      y0 = y.copy();\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  chart.dispatch = scatter.dispatch;\n  chart.scatter = scatter;\n  d3v3.rebind(chart, scatter, 'id', 'interactive', 'size', 'xScale', 'yScale', 'zScale', 'xDomain', 'yDomain', 'xRange', 'yRange', 'sizeDomain', 'forceX', 'forceY', 'forceSize', 'clipVoronoi', 'useVoronoi', 'clipRadius', 'padData', 'highlightPoint', 'clearHighlights');\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.x = function (_) {\n    if (!arguments.length) return getX;\n    getX = _;\n    scatter.x(_);\n    return chart;\n  };\n  chart.y = function (_) {\n    if (!arguments.length) return getY;\n    getY = _;\n    scatter.y(_);\n    return chart;\n  };\n  chart.clipEdge = function (_) {\n    if (!arguments.length) return clipEdge;\n    clipEdge = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    scatter.color(color);\n    return chart;\n  };\n  chart.interpolate = function (_) {\n    if (!arguments.length) return interpolate;\n    interpolate = _;\n    return chart;\n  };\n  chart.defined = function (_) {\n    if (!arguments.length) return defined;\n    defined = _;\n    return chart;\n  };\n  chart.isArea = function (_) {\n    if (!arguments.length) return isArea;\n    isArea = d3v3.functor(_);\n    return chart;\n  };\n\n  //============================================================\n\n  return chart;\n};\nnv.models.lineChart = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var lines = nv.models.line(),\n    xAxis = nv.models.axis(),\n    yAxis = nv.models.axis(),\n    legend = nv.models.legend(),\n    interactiveLayer = nv.interactiveGuideline();\n  var margin = {\n      top: 30,\n      right: 20,\n      bottom: 50,\n      left: 60\n    },\n    color = nv.utils.defaultColor(),\n    width = null,\n    height = null,\n    showLegend = true,\n    showXAxis = true,\n    showYAxis = true,\n    rightAlignYAxis = false,\n    useInteractiveGuideline = false,\n    tooltips = true,\n    tooltip = function tooltip(key, x, y, e, graph) {\n      return '<h3>' + key + '</h3>' + '<p>' + y + ' at ' + x + '</p>';\n    },\n    x,\n    y,\n    state = {},\n    defaultState = null,\n    noData = 'No Data Available.',\n    dispatch = d3v3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState'),\n    transitionDuration = 250;\n  xAxis.orient('bottom').tickPadding(7);\n  yAxis.orient(rightAlignYAxis ? 'right' : 'left');\n\n  //============================================================\n\n  //============================================================\n  // Private Variables\n  //------------------------------------------------------------\n\n  var showTooltip = function showTooltip(e, offsetElement) {\n    var left = e.pos[0] + (offsetElement.offsetLeft || 0),\n      top = e.pos[1] + (offsetElement.offsetTop || 0),\n      x = xAxis.tickFormat()(lines.x()(e.point, e.pointIndex)),\n      y = yAxis.tickFormat()(lines.y()(e.point, e.pointIndex)),\n      content = tooltip(e.series.key, x, y, e, chart);\n    nv.tooltip.show([left, top], content, null, null, offsetElement);\n  };\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var container = d3v3.select(this),\n        that = this;\n      var availableWidth = (width || parseInt(container.style('width')) || 960) - margin.left - margin.right,\n        availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n      chart.update = function () {\n        container.transition().duration(transitionDuration).call(chart);\n      };\n      chart.container = this;\n\n      //set state.disabled\n      state.disabled = data.map(function (d) {\n        return !!d.disabled;\n      });\n      if (!defaultState) {\n        var key;\n        defaultState = {};\n        for (key in state) {\n          if (state[key] instanceof Array) defaultState[key] = state[key].slice(0);else defaultState[key] = state[key];\n        }\n      }\n\n      //------------------------------------------------------------\n      // Display noData message if there's nothing to show.\n\n      if (!data || !data.length || !data.filter(function (d) {\n        return d.values.length;\n      }).length) {\n        var noDataText = container.selectAll('.nv-noData').data([noData]);\n        noDataText.enter().append('text').attr('class', 'nvd3 nv-noData').attr('dy', '-.7em').style('text-anchor', 'middle');\n        noDataText.attr('x', margin.left + availableWidth / 2).attr('y', margin.top + availableHeight / 2).text(function (d) {\n          return d;\n        });\n        return chart;\n      } else {\n        container.selectAll('.nv-noData').remove();\n      }\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Scales\n\n      x = lines.xScale();\n      y = lines.yScale();\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = container.selectAll('g.nv-wrap.nv-lineChart').data([data]);\n      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-lineChart').append('g');\n      var g = wrap.select('g');\n      gEnter.append(\"rect\").style(\"opacity\", 0);\n      gEnter.append('g').attr('class', 'nv-x nv-axis');\n      gEnter.append('g').attr('class', 'nv-y nv-axis');\n      gEnter.append('g').attr('class', 'nv-linesWrap');\n      gEnter.append('g').attr('class', 'nv-legendWrap');\n      gEnter.append('g').attr('class', 'nv-interactive');\n      g.select(\"rect\").attr(\"width\", availableWidth).attr(\"height\", availableHeight > 0 ? availableHeight : 0);\n      //------------------------------------------------------------\n      // Legend\n\n      if (showLegend) {\n        legend.width(availableWidth);\n        g.select('.nv-legendWrap').datum(data).call(legend);\n        if (margin.top != legend.height()) {\n          margin.top = legend.height();\n          availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n        }\n        wrap.select('.nv-legendWrap').attr('transform', 'translate(0,' + -margin.top + ')');\n      }\n\n      //------------------------------------------------------------\n\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n      if (rightAlignYAxis) {\n        g.select(\".nv-y.nv-axis\").attr(\"transform\", \"translate(\" + availableWidth + \",0)\");\n      }\n\n      //------------------------------------------------------------\n      // Main Chart Component(s)\n\n      //------------------------------------------------------------\n      //Set up interactive layer\n      if (useInteractiveGuideline) {\n        interactiveLayer.width(availableWidth).height(availableHeight).margin({\n          left: margin.left,\n          top: margin.top\n        }).svgContainer(container).xScale(x);\n        wrap.select(\".nv-interactive\").call(interactiveLayer);\n      }\n      lines.width(availableWidth).height(availableHeight).color(data.map(function (d, i) {\n        return d.color || color(d, i);\n      }).filter(function (d, i) {\n        return !data[i].disabled;\n      }));\n      var linesWrap = g.select('.nv-linesWrap').datum(data.filter(function (d) {\n        return !d.disabled;\n      }));\n      linesWrap.transition().call(lines);\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Axes\n\n      if (showXAxis) {\n        xAxis.scale(x).ticks(availableWidth / 100).tickSize(-availableHeight, 0);\n        g.select('.nv-x.nv-axis').attr('transform', 'translate(0,' + y.range()[0] + ')');\n        g.select('.nv-x.nv-axis').transition().call(xAxis);\n      }\n      if (showYAxis) {\n        yAxis.scale(y).ticks(availableHeight / 36).tickSize(-availableWidth, 0);\n        g.select('.nv-y.nv-axis').transition().call(yAxis);\n      }\n      //------------------------------------------------------------\n\n      //============================================================\n      // Event Handling/Dispatching (in chart's scope)\n      //------------------------------------------------------------\n\n      legend.dispatch.on('stateChange', function (newState) {\n        state = newState;\n        dispatch.stateChange(state);\n        chart.update();\n      });\n      interactiveLayer.dispatch.on('elementMousemove', function (e) {\n        lines.clearHighlights();\n        var singlePoint,\n          pointIndex,\n          pointXLocation,\n          allData = [];\n        data.filter(function (series, i) {\n          series.seriesIndex = i;\n          return !series.disabled;\n        }).forEach(function (series, i) {\n          pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());\n          lines.highlightPoint(i, pointIndex, true);\n          var point = series.values[pointIndex];\n          if (typeof point === 'undefined') return;\n          if (typeof singlePoint === 'undefined') singlePoint = point;\n          if (typeof pointXLocation === 'undefined') pointXLocation = chart.xScale()(chart.x()(point, pointIndex));\n          allData.push({\n            key: series.key,\n            value: chart.y()(point, pointIndex),\n            color: color(series, series.seriesIndex)\n          });\n        });\n        //Highlight the tooltip entry based on which point the mouse is closest to.\n        if (allData.length > 2) {\n          var yValue = chart.yScale().invert(e.mouseY);\n          var domainExtent = Math.abs(chart.yScale().domain()[0] - chart.yScale().domain()[1]);\n          var threshold = 0.03 * domainExtent;\n          var indexToHighlight = nv.nearestValueIndex(allData.map(function (d) {\n            return d.value;\n          }), yValue, threshold);\n          if (indexToHighlight !== null) allData[indexToHighlight].highlight = true;\n        }\n        var xValue = xAxis.tickFormat()(chart.x()(singlePoint, pointIndex));\n        interactiveLayer.tooltip.position({\n          left: pointXLocation + margin.left,\n          top: e.mouseY + margin.top\n        }).chartContainer(that.parentNode).enabled(tooltips).valueFormatter(function (d, i) {\n          return yAxis.tickFormat()(d);\n        }).data({\n          value: xValue,\n          series: allData\n        })();\n        interactiveLayer.renderGuideLine(pointXLocation);\n      });\n      interactiveLayer.dispatch.on(\"elementMouseout\", function (e) {\n        dispatch.tooltipHide();\n        lines.clearHighlights();\n      });\n      dispatch.on('tooltipShow', function (e) {\n        if (tooltips) showTooltip(e, that.parentNode);\n      });\n      dispatch.on('changeState', function (e) {\n        if (typeof e.disabled !== 'undefined' && data.length === e.disabled.length) {\n          data.forEach(function (series, i) {\n            series.disabled = e.disabled[i];\n          });\n          state.disabled = e.disabled;\n        }\n        chart.update();\n      });\n\n      //============================================================\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Event Handling/Dispatching (out of chart's scope)\n  //------------------------------------------------------------\n\n  lines.dispatch.on('elementMouseover.tooltip', function (e) {\n    e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];\n    dispatch.tooltipShow(e);\n  });\n  lines.dispatch.on('elementMouseout.tooltip', function (e) {\n    dispatch.tooltipHide(e);\n  });\n  dispatch.on('tooltipHide', function () {\n    if (tooltips) nv.tooltip.cleanup();\n  });\n\n  //============================================================\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  // expose chart's sub-components\n  chart.dispatch = dispatch;\n  chart.lines = lines;\n  chart.legend = legend;\n  chart.xAxis = xAxis;\n  chart.yAxis = yAxis;\n  chart.interactiveLayer = interactiveLayer;\n  d3v3.rebind(chart, lines, 'defined', 'isArea', 'x', 'y', 'size', 'xScale', 'yScale', 'xDomain', 'yDomain', 'xRange', 'yRange', 'forceX', 'forceY', 'interactive', 'clipEdge', 'clipVoronoi', 'useVoronoi', 'id', 'interpolate');\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    legend.color(color);\n    return chart;\n  };\n  chart.showLegend = function (_) {\n    if (!arguments.length) return showLegend;\n    showLegend = _;\n    return chart;\n  };\n  chart.showXAxis = function (_) {\n    if (!arguments.length) return showXAxis;\n    showXAxis = _;\n    return chart;\n  };\n  chart.showYAxis = function (_) {\n    if (!arguments.length) return showYAxis;\n    showYAxis = _;\n    return chart;\n  };\n  chart.rightAlignYAxis = function (_) {\n    if (!arguments.length) return rightAlignYAxis;\n    rightAlignYAxis = _;\n    yAxis.orient(_ ? 'right' : 'left');\n    return chart;\n  };\n  chart.useInteractiveGuideline = function (_) {\n    if (!arguments.length) return useInteractiveGuideline;\n    useInteractiveGuideline = _;\n    if (_ === true) {\n      chart.interactive(false);\n      chart.useVoronoi(false);\n    }\n    return chart;\n  };\n  chart.tooltips = function (_) {\n    if (!arguments.length) return tooltips;\n    tooltips = _;\n    return chart;\n  };\n  chart.tooltipContent = function (_) {\n    if (!arguments.length) return tooltip;\n    tooltip = _;\n    return chart;\n  };\n  chart.state = function (_) {\n    if (!arguments.length) return state;\n    state = _;\n    return chart;\n  };\n  chart.defaultState = function (_) {\n    if (!arguments.length) return defaultState;\n    defaultState = _;\n    return chart;\n  };\n  chart.noData = function (_) {\n    if (!arguments.length) return noData;\n    noData = _;\n    return chart;\n  };\n  chart.transitionDuration = function (_) {\n    if (!arguments.length) return transitionDuration;\n    transitionDuration = _;\n    return chart;\n  };\n\n  //============================================================\n\n  return chart;\n};\nnv.models.linePlusBarChart = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var lines = nv.models.line(),\n    bars = nv.models.historicalBar(),\n    xAxis = nv.models.axis(),\n    y1Axis = nv.models.axis(),\n    y2Axis = nv.models.axis(),\n    legend = nv.models.legend();\n  var margin = {\n      top: 30,\n      right: 60,\n      bottom: 50,\n      left: 60\n    },\n    width = null,\n    height = null,\n    getX = function getX(d) {\n      return d.x;\n    },\n    getY = function getY(d) {\n      return d.y;\n    },\n    color = nv.utils.defaultColor(),\n    showLegend = true,\n    tooltips = true,\n    tooltip = function tooltip(key, x, y, e, graph) {\n      return '<h3>' + key + '</h3>' + '<p>' + y + ' at ' + x + '</p>';\n    },\n    x,\n    y1,\n    y2,\n    state = {},\n    defaultState = null,\n    noData = \"No Data Available.\",\n    dispatch = d3v3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState');\n  bars.padData(true);\n  lines.clipEdge(false).padData(true);\n  xAxis.orient('bottom').tickPadding(7).highlightZero(false);\n  y1Axis.orient('left');\n  y2Axis.orient('right');\n\n  //============================================================\n\n  //============================================================\n  // Private Variables\n  //------------------------------------------------------------\n\n  var showTooltip = function showTooltip(e, offsetElement) {\n    var left = e.pos[0] + (offsetElement.offsetLeft || 0),\n      top = e.pos[1] + (offsetElement.offsetTop || 0),\n      x = xAxis.tickFormat()(lines.x()(e.point, e.pointIndex)),\n      y = (e.series.bar ? y1Axis : y2Axis).tickFormat()(lines.y()(e.point, e.pointIndex)),\n      content = tooltip(e.series.key, x, y, e, chart);\n    nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);\n  };\n\n  //------------------------------------------------------------\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var container = d3v3.select(this),\n        that = this;\n      var availableWidth = (width || parseInt(container.style('width')) || 960) - margin.left - margin.right,\n        availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n      chart.update = function () {\n        container.transition().call(chart);\n      };\n      // chart.container = this;\n\n      //set state.disabled\n      state.disabled = data.map(function (d) {\n        return !!d.disabled;\n      });\n      if (!defaultState) {\n        var key;\n        defaultState = {};\n        for (key in state) {\n          if (state[key] instanceof Array) defaultState[key] = state[key].slice(0);else defaultState[key] = state[key];\n        }\n      }\n\n      //------------------------------------------------------------\n      // Display No Data message if there's nothing to show.\n\n      if (!data || !data.length || !data.filter(function (d) {\n        return d.values.length;\n      }).length) {\n        var noDataText = container.selectAll('.nv-noData').data([noData]);\n        noDataText.enter().append('text').attr('class', 'nvd3 nv-noData').attr('dy', '-.7em').style('text-anchor', 'middle');\n        noDataText.attr('x', margin.left + availableWidth / 2).attr('y', margin.top + availableHeight / 2).text(function (d) {\n          return d;\n        });\n        return chart;\n      } else {\n        container.selectAll('.nv-noData').remove();\n      }\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Scales\n\n      var dataBars = data.filter(function (d) {\n        return !d.disabled && d.bar;\n      });\n      var dataLines = data.filter(function (d) {\n        return !d.bar;\n      }); // removed the !d.disabled clause here to fix Issue #240\n\n      //x = xAxis.scale();\n      x = dataLines.filter(function (d) {\n        return !d.disabled;\n      }).length && dataLines.filter(function (d) {\n        return !d.disabled;\n      })[0].values.length ? lines.xScale() : bars.xScale();\n      //x = dataLines.filter(function(d) { return !d.disabled; }).length ? lines.xScale() : bars.xScale(); //old code before change above\n      y1 = bars.yScale();\n      y2 = lines.yScale();\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = d3v3.select(this).selectAll('g.nv-wrap.nv-linePlusBar').data([data]);\n      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-linePlusBar').append('g');\n      var g = wrap.select('g');\n      gEnter.append('g').attr('class', 'nv-x nv-axis');\n      gEnter.append('g').attr('class', 'nv-y1 nv-axis');\n      gEnter.append('g').attr('class', 'nv-y2 nv-axis');\n      gEnter.append('g').attr('class', 'nv-barsWrap');\n      gEnter.append('g').attr('class', 'nv-linesWrap');\n      gEnter.append('g').attr('class', 'nv-legendWrap');\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Legend\n\n      if (showLegend) {\n        legend.width(availableWidth / 2);\n        g.select('.nv-legendWrap').datum(data.map(function (series) {\n          series.originalKey = series.originalKey === undefined ? series.key : series.originalKey;\n          series.key = series.originalKey + (series.bar ? ' (left axis)' : ' (right axis)');\n          return series;\n        })).call(legend);\n        if (margin.top != legend.height()) {\n          margin.top = legend.height();\n          availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n        }\n        g.select('.nv-legendWrap').attr('transform', 'translate(' + availableWidth / 2 + ',' + -margin.top + ')');\n      }\n\n      //------------------------------------------------------------\n\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n      //------------------------------------------------------------\n      // Main Chart Component(s)\n\n      lines.width(availableWidth).height(availableHeight).color(data.map(function (d, i) {\n        return d.color || color(d, i);\n      }).filter(function (d, i) {\n        return !data[i].disabled && !data[i].bar;\n      }));\n      bars.width(availableWidth).height(availableHeight).color(data.map(function (d, i) {\n        return d.color || color(d, i);\n      }).filter(function (d, i) {\n        return !data[i].disabled && data[i].bar;\n      }));\n      var barsWrap = g.select('.nv-barsWrap').datum(dataBars.length ? dataBars : [{\n        values: []\n      }]);\n      var linesWrap = g.select('.nv-linesWrap').datum(dataLines[0] && !dataLines[0].disabled ? dataLines : [{\n        values: []\n      }]);\n      //.datum(!dataLines[0].disabled ? dataLines : [{values:dataLines[0].values.map(function(d) { return [d[0], null] }) }] );\n\n      d3v3.transition(barsWrap).call(bars);\n      d3v3.transition(linesWrap).call(lines);\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Axes\n\n      xAxis.scale(x).ticks(availableWidth / 100).tickSize(-availableHeight, 0);\n      g.select('.nv-x.nv-axis').attr('transform', 'translate(0,' + y1.range()[0] + ')');\n      d3v3.transition(g.select('.nv-x.nv-axis')).call(xAxis);\n      y1Axis.scale(y1).ticks(availableHeight / 36).tickSize(-availableWidth, 0);\n      d3v3.transition(g.select('.nv-y1.nv-axis')).style('opacity', dataBars.length ? 1 : 0).call(y1Axis);\n      y2Axis.scale(y2).ticks(availableHeight / 36).tickSize(dataBars.length ? 0 : -availableWidth, 0); // Show the y2 rules only if y1 has none\n\n      g.select('.nv-y2.nv-axis').style('opacity', dataLines.length ? 1 : 0).attr('transform', 'translate(' + availableWidth + ',0)');\n      //.attr('transform', 'translate(' + x.range()[1] + ',0)');\n\n      d3v3.transition(g.select('.nv-y2.nv-axis')).call(y2Axis);\n\n      //------------------------------------------------------------\n\n      //============================================================\n      // Event Handling/Dispatching (in chart's scope)\n      //------------------------------------------------------------\n\n      legend.dispatch.on('stateChange', function (newState) {\n        state = newState;\n        dispatch.stateChange(state);\n        chart.update();\n      });\n      dispatch.on('tooltipShow', function (e) {\n        if (tooltips) showTooltip(e, that.parentNode);\n      });\n\n      // Update chart from a state object passed to event handler\n      dispatch.on('changeState', function (e) {\n        if (typeof e.disabled !== 'undefined') {\n          data.forEach(function (series, i) {\n            series.disabled = e.disabled[i];\n          });\n          state.disabled = e.disabled;\n        }\n        chart.update();\n      });\n\n      //============================================================\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Event Handling/Dispatching (out of chart's scope)\n  //------------------------------------------------------------\n\n  lines.dispatch.on('elementMouseover.tooltip', function (e) {\n    e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];\n    dispatch.tooltipShow(e);\n  });\n  lines.dispatch.on('elementMouseout.tooltip', function (e) {\n    dispatch.tooltipHide(e);\n  });\n  bars.dispatch.on('elementMouseover.tooltip', function (e) {\n    e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];\n    dispatch.tooltipShow(e);\n  });\n  bars.dispatch.on('elementMouseout.tooltip', function (e) {\n    dispatch.tooltipHide(e);\n  });\n  dispatch.on('tooltipHide', function () {\n    if (tooltips) nv.tooltip.cleanup();\n  });\n\n  //============================================================\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  // expose chart's sub-components\n  chart.dispatch = dispatch;\n  chart.legend = legend;\n  chart.lines = lines;\n  chart.bars = bars;\n  chart.xAxis = xAxis;\n  chart.y1Axis = y1Axis;\n  chart.y2Axis = y2Axis;\n  d3v3.rebind(chart, lines, 'defined', 'size', 'clipVoronoi', 'interpolate');\n  //TODO: consider rebinding x, y and some other stuff, and simply do soemthign lile bars.x(lines.x()), etc.\n  //d3v3.rebind(chart, lines, 'x', 'y', 'size', 'xDomain', 'yDomain', 'xRange', 'yRange', 'forceX', 'forceY', 'interactive', 'clipEdge', 'clipVoronoi', 'id');\n\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.x = function (_) {\n    if (!arguments.length) return getX;\n    getX = _;\n    lines.x(_);\n    bars.x(_);\n    return chart;\n  };\n  chart.y = function (_) {\n    if (!arguments.length) return getY;\n    getY = _;\n    lines.y(_);\n    bars.y(_);\n    return chart;\n  };\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    legend.color(color);\n    return chart;\n  };\n  chart.showLegend = function (_) {\n    if (!arguments.length) return showLegend;\n    showLegend = _;\n    return chart;\n  };\n  chart.tooltips = function (_) {\n    if (!arguments.length) return tooltips;\n    tooltips = _;\n    return chart;\n  };\n  chart.tooltipContent = function (_) {\n    if (!arguments.length) return tooltip;\n    tooltip = _;\n    return chart;\n  };\n  chart.state = function (_) {\n    if (!arguments.length) return state;\n    state = _;\n    return chart;\n  };\n  chart.defaultState = function (_) {\n    if (!arguments.length) return defaultState;\n    defaultState = _;\n    return chart;\n  };\n  chart.noData = function (_) {\n    if (!arguments.length) return noData;\n    noData = _;\n    return chart;\n  };\n\n  //============================================================\n\n  return chart;\n};\nnv.models.lineWithFocusChart = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var lines = nv.models.line(),\n    lines2 = nv.models.line(),\n    xAxis = nv.models.axis(),\n    yAxis = nv.models.axis(),\n    x2Axis = nv.models.axis(),\n    y2Axis = nv.models.axis(),\n    legend = nv.models.legend(),\n    brush = d3v3.svg.brush();\n  var margin = {\n      top: 30,\n      right: 30,\n      bottom: 30,\n      left: 60\n    },\n    margin2 = {\n      top: 0,\n      right: 30,\n      bottom: 20,\n      left: 60\n    },\n    color = nv.utils.defaultColor(),\n    width = null,\n    height = null,\n    height2 = 100,\n    x,\n    y,\n    x2,\n    y2,\n    showLegend = true,\n    brushExtent = null,\n    tooltips = true,\n    tooltip = function tooltip(key, x, y, e, graph) {\n      return '<h3>' + key + '</h3>' + '<p>' + y + ' at ' + x + '</p>';\n    },\n    noData = \"No Data Available.\",\n    dispatch = d3v3.dispatch('tooltipShow', 'tooltipHide', 'brush'),\n    transitionDuration = 250;\n  lines.clipEdge(true);\n  lines2.interactive(false);\n  xAxis.orient('bottom').tickPadding(5);\n  yAxis.orient('left');\n  x2Axis.orient('bottom').tickPadding(5);\n  y2Axis.orient('left');\n  //============================================================\n\n  //============================================================\n  // Private Variables\n  //------------------------------------------------------------\n\n  var showTooltip = function showTooltip(e, offsetElement) {\n    var left = e.pos[0] + (offsetElement.offsetLeft || 0),\n      top = e.pos[1] + (offsetElement.offsetTop || 0),\n      x = xAxis.tickFormat()(lines.x()(e.point, e.pointIndex)),\n      y = yAxis.tickFormat()(lines.y()(e.point, e.pointIndex)),\n      content = tooltip(e.series.key, x, y, e, chart);\n    nv.tooltip.show([left, top], content, null, null, offsetElement);\n  };\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var container = d3v3.select(this),\n        that = this;\n      var availableWidth = (width || parseInt(container.style('width')) || 960) - margin.left - margin.right,\n        availableHeight1 = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom - height2,\n        availableHeight2 = height2 - margin2.top - margin2.bottom;\n      chart.update = function () {\n        container.transition().duration(transitionDuration).call(chart);\n      };\n      chart.container = this;\n\n      //------------------------------------------------------------\n      // Display No Data message if there's nothing to show.\n\n      if (!data || !data.length || !data.filter(function (d) {\n        return d.values.length;\n      }).length) {\n        var noDataText = container.selectAll('.nv-noData').data([noData]);\n        noDataText.enter().append('text').attr('class', 'nvd3 nv-noData').attr('dy', '-.7em').style('text-anchor', 'middle');\n        noDataText.attr('x', margin.left + availableWidth / 2).attr('y', margin.top + availableHeight1 / 2).text(function (d) {\n          return d;\n        });\n        return chart;\n      } else {\n        container.selectAll('.nv-noData').remove();\n      }\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Scales\n\n      x = lines.xScale();\n      y = lines.yScale();\n      x2 = lines2.xScale();\n      y2 = lines2.yScale();\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = container.selectAll('g.nv-wrap.nv-lineWithFocusChart').data([data]);\n      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-lineWithFocusChart').append('g');\n      var g = wrap.select('g');\n      gEnter.append('g').attr('class', 'nv-legendWrap');\n      var focusEnter = gEnter.append('g').attr('class', 'nv-focus');\n      focusEnter.append('g').attr('class', 'nv-x nv-axis');\n      focusEnter.append('g').attr('class', 'nv-y nv-axis');\n      focusEnter.append('g').attr('class', 'nv-linesWrap');\n      var contextEnter = gEnter.append('g').attr('class', 'nv-context');\n      contextEnter.append('g').attr('class', 'nv-x nv-axis');\n      contextEnter.append('g').attr('class', 'nv-y nv-axis');\n      contextEnter.append('g').attr('class', 'nv-linesWrap');\n      contextEnter.append('g').attr('class', 'nv-brushBackground');\n      contextEnter.append('g').attr('class', 'nv-x nv-brush');\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Legend\n\n      if (showLegend) {\n        legend.width(availableWidth);\n        g.select('.nv-legendWrap').datum(data).call(legend);\n        if (margin.top != legend.height()) {\n          margin.top = legend.height();\n          availableHeight1 = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom - height2;\n        }\n        g.select('.nv-legendWrap').attr('transform', 'translate(0,' + -margin.top + ')');\n      }\n\n      //------------------------------------------------------------\n\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n      //------------------------------------------------------------\n      // Main Chart Component(s)\n\n      lines.width(availableWidth).height(availableHeight1).color(data.map(function (d, i) {\n        return d.color || color(d, i);\n      }).filter(function (d, i) {\n        return !data[i].disabled;\n      }));\n      lines2.defined(lines.defined()).width(availableWidth).height(availableHeight2).color(data.map(function (d, i) {\n        return d.color || color(d, i);\n      }).filter(function (d, i) {\n        return !data[i].disabled;\n      }));\n      g.select('.nv-context').attr('transform', 'translate(0,' + (availableHeight1 + margin.bottom + margin2.top) + ')');\n      var contextLinesWrap = g.select('.nv-context .nv-linesWrap').datum(data.filter(function (d) {\n        return !d.disabled;\n      }));\n      d3v3.transition(contextLinesWrap).call(lines2);\n\n      //------------------------------------------------------------\n\n      /*\n      var focusLinesWrap = g.select('.nv-focus .nv-linesWrap')\n          .datum(data.filter(function(d) { return !d.disabled }))\n       d3v3.transition(focusLinesWrap).call(lines);\n      */\n\n      //------------------------------------------------------------\n      // Setup Main (Focus) Axes\n\n      xAxis.scale(x).ticks(availableWidth / 100).tickSize(-availableHeight1, 0);\n      yAxis.scale(y).ticks(availableHeight1 / 36).tickSize(-availableWidth, 0);\n      g.select('.nv-focus .nv-x.nv-axis').attr('transform', 'translate(0,' + availableHeight1 + ')');\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Brush\n\n      brush.x(x2).on('brush', function () {\n        //When brushing, turn off transitions because chart needs to change immediately.\n        var oldTransition = chart.transitionDuration();\n        chart.transitionDuration(0);\n        onBrush();\n        chart.transitionDuration(oldTransition);\n      });\n      if (brushExtent) brush.extent(brushExtent);\n      var brushBG = g.select('.nv-brushBackground').selectAll('g').data([brushExtent || brush.extent()]);\n      var brushBGenter = brushBG.enter().append('g');\n      brushBGenter.append('rect').attr('class', 'left').attr('x', 0).attr('y', 0).attr('height', availableHeight2);\n      brushBGenter.append('rect').attr('class', 'right').attr('x', 0).attr('y', 0).attr('height', availableHeight2);\n      var gBrush = g.select('.nv-x.nv-brush').call(brush);\n      gBrush.selectAll('rect')\n      //.attr('y', -5)\n      .attr('height', availableHeight2);\n      gBrush.selectAll('.resize').append('path').attr('d', resizePath);\n      onBrush();\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Secondary (Context) Axes\n\n      x2Axis.scale(x2).ticks(availableWidth / 100).tickSize(-availableHeight2, 0);\n      g.select('.nv-context .nv-x.nv-axis').attr('transform', 'translate(0,' + y2.range()[0] + ')');\n      d3v3.transition(g.select('.nv-context .nv-x.nv-axis')).call(x2Axis);\n      y2Axis.scale(y2).ticks(availableHeight2 / 36).tickSize(-availableWidth, 0);\n      d3v3.transition(g.select('.nv-context .nv-y.nv-axis')).call(y2Axis);\n      g.select('.nv-context .nv-x.nv-axis').attr('transform', 'translate(0,' + y2.range()[0] + ')');\n\n      //------------------------------------------------------------\n\n      //============================================================\n      // Event Handling/Dispatching (in chart's scope)\n      //------------------------------------------------------------\n\n      legend.dispatch.on('stateChange', function (newState) {\n        chart.update();\n      });\n      dispatch.on('tooltipShow', function (e) {\n        if (tooltips) showTooltip(e, that.parentNode);\n      });\n\n      //============================================================\n\n      //============================================================\n      // Functions\n      //------------------------------------------------------------\n\n      // Taken from crossfilter (http://square.github.com/crossfilter/)\n      function resizePath(d) {\n        var e = +(d == 'e'),\n          x = e ? 1 : -1,\n          y = availableHeight2 / 3;\n        return 'M' + .5 * x + ',' + y + 'A6,6 0 0 ' + e + ' ' + 6.5 * x + ',' + (y + 6) + 'V' + (2 * y - 6) + 'A6,6 0 0 ' + e + ' ' + .5 * x + ',' + 2 * y + 'Z' + 'M' + 2.5 * x + ',' + (y + 8) + 'V' + (2 * y - 8) + 'M' + 4.5 * x + ',' + (y + 8) + 'V' + (2 * y - 8);\n      }\n      function updateBrushBG() {\n        if (!brush.empty()) brush.extent(brushExtent);\n        brushBG.data([brush.empty() ? x2.domain() : brushExtent]).each(function (d, i) {\n          var leftWidth = x2(d[0]) - x.range()[0],\n            rightWidth = x.range()[1] - x2(d[1]);\n          d3v3.select(this).select('.left').attr('width', leftWidth < 0 ? 0 : leftWidth);\n          d3v3.select(this).select('.right').attr('x', x2(d[1])).attr('width', rightWidth < 0 ? 0 : rightWidth);\n        });\n      }\n      function onBrush() {\n        brushExtent = brush.empty() ? null : brush.extent();\n        var extent = brush.empty() ? x2.domain() : brush.extent();\n\n        //The brush extent cannot be less than one.  If it is, don't update the line chart.\n        if (Math.abs(extent[0] - extent[1]) <= 1) {\n          return;\n        }\n        dispatch.brush({\n          extent: extent,\n          brush: brush\n        });\n        updateBrushBG();\n\n        // Update Main (Focus)\n        var focusLinesWrap = g.select('.nv-focus .nv-linesWrap').datum(data.filter(function (d) {\n          return !d.disabled;\n        }).map(function (d, i) {\n          return {\n            key: d.key,\n            values: d.values.filter(function (d, i) {\n              return lines.x()(d, i) >= extent[0] && lines.x()(d, i) <= extent[1];\n            })\n          };\n        }));\n        focusLinesWrap.transition().duration(transitionDuration).call(lines);\n\n        // Update Main (Focus) Axes\n        g.select('.nv-focus .nv-x.nv-axis').transition().duration(transitionDuration).call(xAxis);\n        g.select('.nv-focus .nv-y.nv-axis').transition().duration(transitionDuration).call(yAxis);\n      }\n\n      //============================================================\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Event Handling/Dispatching (out of chart's scope)\n  //------------------------------------------------------------\n\n  lines.dispatch.on('elementMouseover.tooltip', function (e) {\n    e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];\n    dispatch.tooltipShow(e);\n  });\n  lines.dispatch.on('elementMouseout.tooltip', function (e) {\n    dispatch.tooltipHide(e);\n  });\n  dispatch.on('tooltipHide', function () {\n    if (tooltips) nv.tooltip.cleanup();\n  });\n\n  //============================================================\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  // expose chart's sub-components\n  chart.dispatch = dispatch;\n  chart.legend = legend;\n  chart.lines = lines;\n  chart.lines2 = lines2;\n  chart.xAxis = xAxis;\n  chart.yAxis = yAxis;\n  chart.x2Axis = x2Axis;\n  chart.y2Axis = y2Axis;\n  d3v3.rebind(chart, lines, 'defined', 'isArea', 'size', 'xDomain', 'yDomain', 'xRange', 'yRange', 'forceX', 'forceY', 'interactive', 'clipEdge', 'clipVoronoi', 'id');\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.x = function (_) {\n    if (!arguments.length) return lines.x;\n    lines.x(_);\n    lines2.x(_);\n    return chart;\n  };\n  chart.y = function (_) {\n    if (!arguments.length) return lines.y;\n    lines.y(_);\n    lines2.y(_);\n    return chart;\n  };\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.margin2 = function (_) {\n    if (!arguments.length) return margin2;\n    margin2 = _;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.height2 = function (_) {\n    if (!arguments.length) return height2;\n    height2 = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    legend.color(color);\n    return chart;\n  };\n  chart.showLegend = function (_) {\n    if (!arguments.length) return showLegend;\n    showLegend = _;\n    return chart;\n  };\n  chart.tooltips = function (_) {\n    if (!arguments.length) return tooltips;\n    tooltips = _;\n    return chart;\n  };\n  chart.tooltipContent = function (_) {\n    if (!arguments.length) return tooltip;\n    tooltip = _;\n    return chart;\n  };\n  chart.interpolate = function (_) {\n    if (!arguments.length) return lines.interpolate();\n    lines.interpolate(_);\n    lines2.interpolate(_);\n    return chart;\n  };\n  chart.noData = function (_) {\n    if (!arguments.length) return noData;\n    noData = _;\n    return chart;\n  };\n\n  // Chart has multiple similar Axes, to prevent code duplication, probably need to link all axis functions manually like below\n  chart.xTickFormat = function (_) {\n    if (!arguments.length) return xAxis.tickFormat();\n    xAxis.tickFormat(_);\n    x2Axis.tickFormat(_);\n    return chart;\n  };\n  chart.yTickFormat = function (_) {\n    if (!arguments.length) return yAxis.tickFormat();\n    yAxis.tickFormat(_);\n    y2Axis.tickFormat(_);\n    return chart;\n  };\n  chart.brushExtent = function (_) {\n    if (!arguments.length) return brushExtent;\n    brushExtent = _;\n    return chart;\n  };\n  chart.transitionDuration = function (_) {\n    if (!arguments.length) return transitionDuration;\n    transitionDuration = _;\n    return chart;\n  };\n\n  //============================================================\n\n  return chart;\n};\nnv.models.linePlusBarWithFocusChart = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var lines = nv.models.line(),\n    lines2 = nv.models.line(),\n    bars = nv.models.historicalBar(),\n    bars2 = nv.models.historicalBar(),\n    xAxis = nv.models.axis(),\n    x2Axis = nv.models.axis(),\n    y1Axis = nv.models.axis(),\n    y2Axis = nv.models.axis(),\n    y3Axis = nv.models.axis(),\n    y4Axis = nv.models.axis(),\n    legend = nv.models.legend(),\n    brush = d3v3.svg.brush();\n  var margin = {\n      top: 30,\n      right: 30,\n      bottom: 30,\n      left: 60\n    },\n    margin2 = {\n      top: 0,\n      right: 30,\n      bottom: 20,\n      left: 60\n    },\n    width = null,\n    height = null,\n    height2 = 100,\n    getX = function getX(d) {\n      return d.x;\n    },\n    getY = function getY(d) {\n      return d.y;\n    },\n    color = nv.utils.defaultColor(),\n    showLegend = true,\n    extent,\n    brushExtent = null,\n    tooltips = true,\n    tooltip = function tooltip(key, x, y, e, graph) {\n      return '<h3>' + key + '</h3>' + '<p>' + y + ' at ' + x + '</p>';\n    },\n    x,\n    x2,\n    y1,\n    y2,\n    y3,\n    y4,\n    noData = \"No Data Available.\",\n    dispatch = d3v3.dispatch('tooltipShow', 'tooltipHide', 'brush'),\n    transitionDuration = 0;\n  lines.clipEdge(true);\n  lines2.interactive(false);\n  xAxis.orient('bottom').tickPadding(5);\n  y1Axis.orient('left');\n  y2Axis.orient('right');\n  x2Axis.orient('bottom').tickPadding(5);\n  y3Axis.orient('left');\n  y4Axis.orient('right');\n\n  //============================================================\n\n  //============================================================\n  // Private Variables\n  //------------------------------------------------------------\n\n  var showTooltip = function showTooltip(e, offsetElement) {\n    if (extent) {\n      e.pointIndex += Math.ceil(extent[0]);\n    }\n    var left = e.pos[0] + (offsetElement.offsetLeft || 0),\n      top = e.pos[1] + (offsetElement.offsetTop || 0),\n      x = xAxis.tickFormat()(lines.x()(e.point, e.pointIndex)),\n      y = (e.series.bar ? y1Axis : y2Axis).tickFormat()(lines.y()(e.point, e.pointIndex)),\n      content = tooltip(e.series.key, x, y, e, chart);\n    nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);\n  };\n\n  //------------------------------------------------------------\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var container = d3v3.select(this),\n        that = this;\n      var availableWidth = (width || parseInt(container.style('width')) || 960) - margin.left - margin.right,\n        availableHeight1 = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom - height2,\n        availableHeight2 = height2 - margin2.top - margin2.bottom;\n      chart.update = function () {\n        container.transition().duration(transitionDuration).call(chart);\n      };\n      chart.container = this;\n\n      //------------------------------------------------------------\n      // Display No Data message if there's nothing to show.\n\n      if (!data || !data.length || !data.filter(function (d) {\n        return d.values.length;\n      }).length) {\n        var noDataText = container.selectAll('.nv-noData').data([noData]);\n        noDataText.enter().append('text').attr('class', 'nvd3 nv-noData').attr('dy', '-.7em').style('text-anchor', 'middle');\n        noDataText.attr('x', margin.left + availableWidth / 2).attr('y', margin.top + availableHeight1 / 2).text(function (d) {\n          return d;\n        });\n        return chart;\n      } else {\n        container.selectAll('.nv-noData').remove();\n      }\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Scales\n\n      var dataBars = data.filter(function (d) {\n        return !d.disabled && d.bar;\n      });\n      var dataLines = data.filter(function (d) {\n        return !d.bar;\n      }); // removed the !d.disabled clause here to fix Issue #240\n\n      x = bars.xScale();\n      x2 = x2Axis.scale();\n      y1 = bars.yScale();\n      y2 = lines.yScale();\n      y3 = bars2.yScale();\n      y4 = lines2.yScale();\n      var series1 = data.filter(function (d) {\n        return !d.disabled && d.bar;\n      }).map(function (d) {\n        return d.values.map(function (d, i) {\n          return {\n            x: getX(d, i),\n            y: getY(d, i)\n          };\n        });\n      });\n      var series2 = data.filter(function (d) {\n        return !d.disabled && !d.bar;\n      }).map(function (d) {\n        return d.values.map(function (d, i) {\n          return {\n            x: getX(d, i),\n            y: getY(d, i)\n          };\n        });\n      });\n      x.range([0, availableWidth]);\n      x2.domain(d3v3.extent(d3v3.merge(series1.concat(series2)), function (d) {\n        return d.x;\n      })).range([0, availableWidth]);\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = container.selectAll('g.nv-wrap.nv-linePlusBar').data([data]);\n      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-linePlusBar').append('g');\n      var g = wrap.select('g');\n      gEnter.append('g').attr('class', 'nv-legendWrap');\n      var focusEnter = gEnter.append('g').attr('class', 'nv-focus');\n      focusEnter.append('g').attr('class', 'nv-x nv-axis');\n      focusEnter.append('g').attr('class', 'nv-y1 nv-axis');\n      focusEnter.append('g').attr('class', 'nv-y2 nv-axis');\n      focusEnter.append('g').attr('class', 'nv-barsWrap');\n      focusEnter.append('g').attr('class', 'nv-linesWrap');\n      var contextEnter = gEnter.append('g').attr('class', 'nv-context');\n      contextEnter.append('g').attr('class', 'nv-x nv-axis');\n      contextEnter.append('g').attr('class', 'nv-y1 nv-axis');\n      contextEnter.append('g').attr('class', 'nv-y2 nv-axis');\n      contextEnter.append('g').attr('class', 'nv-barsWrap');\n      contextEnter.append('g').attr('class', 'nv-linesWrap');\n      contextEnter.append('g').attr('class', 'nv-brushBackground');\n      contextEnter.append('g').attr('class', 'nv-x nv-brush');\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Legend\n\n      if (showLegend) {\n        legend.width(availableWidth / 2);\n        g.select('.nv-legendWrap').datum(data.map(function (series) {\n          series.originalKey = series.originalKey === undefined ? series.key : series.originalKey;\n          series.key = series.originalKey + (series.bar ? ' (left axis)' : ' (right axis)');\n          return series;\n        })).call(legend);\n        if (margin.top != legend.height()) {\n          margin.top = legend.height();\n          availableHeight1 = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom - height2;\n        }\n        g.select('.nv-legendWrap').attr('transform', 'translate(' + availableWidth / 2 + ',' + -margin.top + ')');\n      }\n\n      //------------------------------------------------------------\n\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n      //------------------------------------------------------------\n      // Context Components\n\n      bars2.width(availableWidth).height(availableHeight2).color(data.map(function (d, i) {\n        return d.color || color(d, i);\n      }).filter(function (d, i) {\n        return !data[i].disabled && data[i].bar;\n      }));\n      lines2.width(availableWidth).height(availableHeight2).color(data.map(function (d, i) {\n        return d.color || color(d, i);\n      }).filter(function (d, i) {\n        return !data[i].disabled && !data[i].bar;\n      }));\n      var bars2Wrap = g.select('.nv-context .nv-barsWrap').datum(dataBars.length ? dataBars : [{\n        values: []\n      }]);\n      var lines2Wrap = g.select('.nv-context .nv-linesWrap').datum(!dataLines[0].disabled ? dataLines : [{\n        values: []\n      }]);\n      g.select('.nv-context').attr('transform', 'translate(0,' + (availableHeight1 + margin.bottom + margin2.top) + ')');\n      bars2Wrap.transition().call(bars2);\n      lines2Wrap.transition().call(lines2);\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Brush\n\n      brush.x(x2).on('brush', onBrush);\n      if (brushExtent) brush.extent(brushExtent);\n      var brushBG = g.select('.nv-brushBackground').selectAll('g').data([brushExtent || brush.extent()]);\n      var brushBGenter = brushBG.enter().append('g');\n      brushBGenter.append('rect').attr('class', 'left').attr('x', 0).attr('y', 0).attr('height', availableHeight2);\n      brushBGenter.append('rect').attr('class', 'right').attr('x', 0).attr('y', 0).attr('height', availableHeight2);\n      var gBrush = g.select('.nv-x.nv-brush').call(brush);\n      gBrush.selectAll('rect')\n      //.attr('y', -5)\n      .attr('height', availableHeight2);\n      gBrush.selectAll('.resize').append('path').attr('d', resizePath);\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Secondary (Context) Axes\n\n      x2Axis.ticks(availableWidth / 100).tickSize(-availableHeight2, 0);\n      g.select('.nv-context .nv-x.nv-axis').attr('transform', 'translate(0,' + y3.range()[0] + ')');\n      g.select('.nv-context .nv-x.nv-axis').transition().call(x2Axis);\n      y3Axis.scale(y3).ticks(availableHeight2 / 36).tickSize(-availableWidth, 0);\n      g.select('.nv-context .nv-y1.nv-axis').style('opacity', dataBars.length ? 1 : 0).attr('transform', 'translate(0,' + x2.range()[0] + ')');\n      g.select('.nv-context .nv-y1.nv-axis').transition().call(y3Axis);\n      y4Axis.scale(y4).ticks(availableHeight2 / 36).tickSize(dataBars.length ? 0 : -availableWidth, 0); // Show the y2 rules only if y1 has none\n\n      g.select('.nv-context .nv-y2.nv-axis').style('opacity', dataLines.length ? 1 : 0).attr('transform', 'translate(' + x2.range()[1] + ',0)');\n      g.select('.nv-context .nv-y2.nv-axis').transition().call(y4Axis);\n\n      //------------------------------------------------------------\n\n      //============================================================\n      // Event Handling/Dispatching (in chart's scope)\n      //------------------------------------------------------------\n\n      legend.dispatch.on('stateChange', function (newState) {\n        chart.update();\n      });\n      dispatch.on('tooltipShow', function (e) {\n        if (tooltips) showTooltip(e, that.parentNode);\n      });\n\n      //============================================================\n\n      //============================================================\n      // Functions\n      //------------------------------------------------------------\n\n      // Taken from crossfilter (http://square.github.com/crossfilter/)\n      function resizePath(d) {\n        var e = +(d == 'e'),\n          x = e ? 1 : -1,\n          y = availableHeight2 / 3;\n        return 'M' + .5 * x + ',' + y + 'A6,6 0 0 ' + e + ' ' + 6.5 * x + ',' + (y + 6) + 'V' + (2 * y - 6) + 'A6,6 0 0 ' + e + ' ' + .5 * x + ',' + 2 * y + 'Z' + 'M' + 2.5 * x + ',' + (y + 8) + 'V' + (2 * y - 8) + 'M' + 4.5 * x + ',' + (y + 8) + 'V' + (2 * y - 8);\n      }\n      function updateBrushBG() {\n        if (!brush.empty()) brush.extent(brushExtent);\n        brushBG.data([brush.empty() ? x2.domain() : brushExtent]).each(function (d, i) {\n          var leftWidth = x2(d[0]) - x2.range()[0],\n            rightWidth = x2.range()[1] - x2(d[1]);\n          d3v3.select(this).select('.left').attr('width', leftWidth < 0 ? 0 : leftWidth);\n          d3v3.select(this).select('.right').attr('x', x2(d[1])).attr('width', rightWidth < 0 ? 0 : rightWidth);\n        });\n      }\n      function onBrush() {\n        brushExtent = brush.empty() ? null : brush.extent();\n        extent = brush.empty() ? x2.domain() : brush.extent();\n        dispatch.brush({\n          extent: extent,\n          brush: brush\n        });\n        updateBrushBG();\n\n        //------------------------------------------------------------\n        // Prepare Main (Focus) Bars and Lines\n\n        bars.width(availableWidth).height(availableHeight1).color(data.map(function (d, i) {\n          return d.color || color(d, i);\n        }).filter(function (d, i) {\n          return !data[i].disabled && data[i].bar;\n        }));\n        lines.width(availableWidth).height(availableHeight1).color(data.map(function (d, i) {\n          return d.color || color(d, i);\n        }).filter(function (d, i) {\n          return !data[i].disabled && !data[i].bar;\n        }));\n        var focusBarsWrap = g.select('.nv-focus .nv-barsWrap').datum(!dataBars.length ? [{\n          values: []\n        }] : dataBars.map(function (d, i) {\n          return {\n            key: d.key,\n            values: d.values.filter(function (d, i) {\n              return bars.x()(d, i) >= extent[0] && bars.x()(d, i) <= extent[1];\n            })\n          };\n        }));\n        var focusLinesWrap = g.select('.nv-focus .nv-linesWrap').datum(dataLines[0].disabled ? [{\n          values: []\n        }] : dataLines.map(function (d, i) {\n          return {\n            key: d.key,\n            values: d.values.filter(function (d, i) {\n              return lines.x()(d, i) >= extent[0] && lines.x()(d, i) <= extent[1];\n            })\n          };\n        }));\n\n        //------------------------------------------------------------\n\n        //------------------------------------------------------------\n        // Update Main (Focus) X Axis\n\n        if (dataBars.length) {\n          x = bars.xScale();\n        } else {\n          x = lines.xScale();\n        }\n        xAxis.scale(x).ticks(availableWidth / 100).tickSize(-availableHeight1, 0);\n        xAxis.domain([Math.ceil(extent[0]), Math.floor(extent[1])]);\n        g.select('.nv-x.nv-axis').transition().duration(transitionDuration).call(xAxis);\n        //------------------------------------------------------------\n\n        //------------------------------------------------------------\n        // Update Main (Focus) Bars and Lines\n\n        focusBarsWrap.transition().duration(transitionDuration).call(bars);\n        focusLinesWrap.transition().duration(transitionDuration).call(lines);\n\n        //------------------------------------------------------------\n\n        //------------------------------------------------------------\n        // Setup and Update Main (Focus) Y Axes\n\n        g.select('.nv-focus .nv-x.nv-axis').attr('transform', 'translate(0,' + y1.range()[0] + ')');\n        y1Axis.scale(y1).ticks(availableHeight1 / 36).tickSize(-availableWidth, 0);\n        g.select('.nv-focus .nv-y1.nv-axis').style('opacity', dataBars.length ? 1 : 0);\n        y2Axis.scale(y2).ticks(availableHeight1 / 36).tickSize(dataBars.length ? 0 : -availableWidth, 0); // Show the y2 rules only if y1 has none\n\n        g.select('.nv-focus .nv-y2.nv-axis').style('opacity', dataLines.length ? 1 : 0).attr('transform', 'translate(' + x.range()[1] + ',0)');\n        g.select('.nv-focus .nv-y1.nv-axis').transition().duration(transitionDuration).call(y1Axis);\n        g.select('.nv-focus .nv-y2.nv-axis').transition().duration(transitionDuration).call(y2Axis);\n      }\n\n      //============================================================\n\n      onBrush();\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Event Handling/Dispatching (out of chart's scope)\n  //------------------------------------------------------------\n\n  lines.dispatch.on('elementMouseover.tooltip', function (e) {\n    e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];\n    dispatch.tooltipShow(e);\n  });\n  lines.dispatch.on('elementMouseout.tooltip', function (e) {\n    dispatch.tooltipHide(e);\n  });\n  bars.dispatch.on('elementMouseover.tooltip', function (e) {\n    e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];\n    dispatch.tooltipShow(e);\n  });\n  bars.dispatch.on('elementMouseout.tooltip', function (e) {\n    dispatch.tooltipHide(e);\n  });\n  dispatch.on('tooltipHide', function () {\n    if (tooltips) nv.tooltip.cleanup();\n  });\n\n  //============================================================\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  // expose chart's sub-components\n  chart.dispatch = dispatch;\n  chart.legend = legend;\n  chart.lines = lines;\n  chart.lines2 = lines2;\n  chart.bars = bars;\n  chart.bars2 = bars2;\n  chart.xAxis = xAxis;\n  chart.x2Axis = x2Axis;\n  chart.y1Axis = y1Axis;\n  chart.y2Axis = y2Axis;\n  chart.y3Axis = y3Axis;\n  chart.y4Axis = y4Axis;\n  d3v3.rebind(chart, lines, 'defined', 'size', 'clipVoronoi', 'interpolate');\n  //TODO: consider rebinding x, y and some other stuff, and simply do soemthign lile bars.x(lines.x()), etc.\n  //d3v3.rebind(chart, lines, 'x', 'y', 'size', 'xDomain', 'yDomain', 'xRange', 'yRange', 'forceX', 'forceY', 'interactive', 'clipEdge', 'clipVoronoi', 'id');\n\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.x = function (_) {\n    if (!arguments.length) return getX;\n    getX = _;\n    lines.x(_);\n    bars.x(_);\n    return chart;\n  };\n  chart.y = function (_) {\n    if (!arguments.length) return getY;\n    getY = _;\n    lines.y(_);\n    bars.y(_);\n    return chart;\n  };\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    legend.color(color);\n    return chart;\n  };\n  chart.showLegend = function (_) {\n    if (!arguments.length) return showLegend;\n    showLegend = _;\n    return chart;\n  };\n  chart.tooltips = function (_) {\n    if (!arguments.length) return tooltips;\n    tooltips = _;\n    return chart;\n  };\n  chart.tooltipContent = function (_) {\n    if (!arguments.length) return tooltip;\n    tooltip = _;\n    return chart;\n  };\n  chart.noData = function (_) {\n    if (!arguments.length) return noData;\n    noData = _;\n    return chart;\n  };\n  chart.brushExtent = function (_) {\n    if (!arguments.length) return brushExtent;\n    brushExtent = _;\n    return chart;\n  };\n\n  //============================================================\n\n  return chart;\n};\nnv.models.multiBar = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var margin = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    },\n    width = 960,\n    height = 500,\n    x = d3v3.scale.ordinal(),\n    y = d3v3.scale.linear(),\n    id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one\n    ,\n    getX = function getX(d) {\n      return d.x;\n    },\n    getY = function getY(d) {\n      return d.y;\n    },\n    forceY = [0] // 0 is forced by default.. this makes sense for the majority of bar graphs... user can always do chart.forceY([]) to remove\n    ,\n    clipEdge = true,\n    stacked = false,\n    stackOffset = 'zero' // options include 'silhouette', 'wiggle', 'expand', 'zero', or a custom function\n    ,\n    color = nv.utils.defaultColor(),\n    hideable = false,\n    barColor = null // adding the ability to set the color for each rather than the whole group\n    ,\n    disabled // used in conjunction with barColor to communicate from multiBarHorizontalChart what series are disabled\n    ,\n    delay = 1200,\n    xDomain,\n    yDomain,\n    xRange,\n    yRange,\n    groupSpacing = 0.1,\n    dispatch = d3v3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout');\n\n  //============================================================\n\n  //============================================================\n  // Private Variables\n  //------------------------------------------------------------\n\n  var x0, y0 //used to store previous scales\n  ;\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var availableWidth = width - margin.left - margin.right,\n        availableHeight = height - margin.top - margin.bottom,\n        container = d3v3.select(this);\n      if (hideable && data.length) hideable = [{\n        values: data[0].values.map(function (d) {\n          return {\n            x: d.x,\n            y: 0,\n            series: d.series,\n            size: 0.01\n          };\n        })\n      }];\n      if (stacked) data = d3v3.layout.stack().offset(stackOffset).values(function (d) {\n        return d.values;\n      }).y(getY)(!data.length && hideable ? hideable : data);\n\n      //add series index to each data point for reference\n      data.forEach(function (series, i) {\n        series.values.forEach(function (point) {\n          point.series = i;\n        });\n      });\n\n      //------------------------------------------------------------\n      // HACK for negative value stacking\n      if (stacked) data[0].values.map(function (d, i) {\n        var posBase = 0,\n          negBase = 0;\n        data.map(function (d) {\n          var f = d.values[i];\n          f.size = Math.abs(f.y);\n          if (f.y < 0) {\n            f.y1 = negBase;\n            negBase = negBase - f.size;\n          } else {\n            f.y1 = f.size + posBase;\n            posBase = posBase + f.size;\n          }\n        });\n      });\n\n      //------------------------------------------------------------\n      // Setup Scales\n\n      // remap and flatten the data for use in calculating the scales' domains\n      var seriesData = xDomain && yDomain ? [] :\n      // if we know xDomain and yDomain, no need to calculate\n      data.map(function (d) {\n        return d.values.map(function (d, i) {\n          return {\n            x: getX(d, i),\n            y: getY(d, i),\n            y0: d.y0,\n            y1: d.y1\n          };\n        });\n      });\n      x.domain(xDomain || d3v3.merge(seriesData).map(function (d) {\n        return d.x;\n      })).rangeBands(xRange || [0, availableWidth], groupSpacing);\n\n      //y   .domain(yDomain || d3v3.extent(d3v3.merge(seriesData).map(function(d) { return d.y + (stacked ? d.y1 : 0) }).concat(forceY)))\n      y.domain(yDomain || d3v3.extent(d3v3.merge(seriesData).map(function (d) {\n        return stacked ? d.y > 0 ? d.y1 : d.y1 + d.y : d.y;\n      }).concat(forceY))).range(yRange || [availableHeight, 0]);\n\n      // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point\n      if (x.domain()[0] === x.domain()[1]) x.domain()[0] ? x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01]) : x.domain([-1, 1]);\n      if (y.domain()[0] === y.domain()[1]) y.domain()[0] ? y.domain([y.domain()[0] + y.domain()[0] * 0.01, y.domain()[1] - y.domain()[1] * 0.01]) : y.domain([-1, 1]);\n      x0 = x0 || x;\n      y0 = y0 || y;\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = container.selectAll('g.nv-wrap.nv-multibar').data([data]);\n      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multibar');\n      var defsEnter = wrapEnter.append('defs');\n      var gEnter = wrapEnter.append('g');\n      var g = wrap.select('g');\n      gEnter.append('g').attr('class', 'nv-groups');\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n      //------------------------------------------------------------\n\n      defsEnter.append('clipPath').attr('id', 'nv-edge-clip-' + id).append('rect');\n      wrap.select('#nv-edge-clip-' + id + ' rect').attr('width', availableWidth).attr('height', availableHeight);\n      g.attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + id + ')' : '');\n      var groups = wrap.select('.nv-groups').selectAll('.nv-group').data(function (d) {\n        return d;\n      }, function (d, i) {\n        return i;\n      });\n      groups.enter().append('g').style('stroke-opacity', 1e-6).style('fill-opacity', 1e-6);\n      groups.exit().transition().selectAll('rect.nv-bar').delay(function (d, i) {\n        return i * delay / data[0].values.length;\n      }).attr('y', function (d) {\n        return stacked ? y0(d.y0) : y0(0);\n      }).attr('height', 0).remove();\n      groups.attr('class', function (d, i) {\n        return 'nv-group nv-series-' + i;\n      }).classed('hover', function (d) {\n        return d.hover;\n      }).style('fill', function (d, i) {\n        return color(d, i);\n      }).style('stroke', function (d, i) {\n        return color(d, i);\n      });\n      groups.transition().style('stroke-opacity', 1).style('fill-opacity', .75);\n      var bars = groups.selectAll('rect.nv-bar').data(function (d) {\n        return hideable && !data.length ? hideable.values : d.values;\n      });\n      bars.exit().remove();\n      var barsEnter = bars.enter().append('rect').attr('class', function (d, i) {\n        return getY(d, i) < 0 ? 'nv-bar negative' : 'nv-bar positive';\n      }).attr('x', function (d, i, j) {\n        return stacked ? 0 : j * x.rangeBand() / data.length;\n      }).attr('y', function (d) {\n        return y0(stacked ? d.y0 : 0);\n      }).attr('height', 0).attr('width', x.rangeBand() / (stacked ? 1 : data.length)).attr('transform', function (d, i) {\n        return 'translate(' + x(getX(d, i)) + ',0)';\n      });\n      bars.style('fill', function (d, i, j) {\n        return color(d, j, i);\n      }).style('stroke', function (d, i, j) {\n        return color(d, j, i);\n      }).on('mouseover', function (d, i) {\n        //TODO: figure out why j works above, but not here\n        d3v3.select(this).classed('hover', true);\n        dispatch.elementMouseover({\n          value: getY(d, i),\n          point: d,\n          series: data[d.series],\n          pos: [x(getX(d, i)) + x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length, y(getY(d, i) + (stacked ? d.y0 : 0))],\n          // TODO: Figure out why the value appears to be shifted\n          pointIndex: i,\n          seriesIndex: d.series,\n          e: d3v3.event\n        });\n      }).on('mouseout', function (d, i) {\n        d3v3.select(this).classed('hover', false);\n        dispatch.elementMouseout({\n          value: getY(d, i),\n          point: d,\n          series: data[d.series],\n          pointIndex: i,\n          seriesIndex: d.series,\n          e: d3v3.event\n        });\n      }).on('click', function (d, i) {\n        dispatch.elementClick({\n          value: getY(d, i),\n          point: d,\n          series: data[d.series],\n          pos: [x(getX(d, i)) + x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length, y(getY(d, i) + (stacked ? d.y0 : 0))],\n          // TODO: Figure out why the value appears to be shifted\n          pointIndex: i,\n          seriesIndex: d.series,\n          e: d3v3.event\n        });\n        d3v3.event.stopPropagation();\n      }).on('dblclick', function (d, i) {\n        dispatch.elementDblClick({\n          value: getY(d, i),\n          point: d,\n          series: data[d.series],\n          pos: [x(getX(d, i)) + x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length, y(getY(d, i) + (stacked ? d.y0 : 0))],\n          // TODO: Figure out why the value appears to be shifted\n          pointIndex: i,\n          seriesIndex: d.series,\n          e: d3v3.event\n        });\n        d3v3.event.stopPropagation();\n      });\n      bars.attr('class', function (d, i) {\n        return getY(d, i) < 0 ? 'nv-bar negative' : 'nv-bar positive';\n      }).transition().attr('transform', function (d, i) {\n        return 'translate(' + x(getX(d, i)) + ',0)';\n      });\n      if (barColor) {\n        if (!disabled) disabled = data.map(function () {\n          return true;\n        });\n        bars.style('fill', function (d, i, j) {\n          return d3v3.rgb(barColor(d, i)).darker(disabled.map(function (d, i) {\n            return i;\n          }).filter(function (d, i) {\n            return !disabled[i];\n          })[j]).toString();\n        }).style('stroke', function (d, i, j) {\n          return d3v3.rgb(barColor(d, i)).darker(disabled.map(function (d, i) {\n            return i;\n          }).filter(function (d, i) {\n            return !disabled[i];\n          })[j]).toString();\n        });\n      }\n      if (stacked) bars.transition().delay(function (d, i) {\n        return i * delay / data[0].values.length;\n      }).attr('y', function (d, i) {\n        return y(stacked ? d.y1 : 0);\n      }).attr('height', function (d, i) {\n        return Math.max(Math.abs(y(d.y + (stacked ? d.y0 : 0)) - y(stacked ? d.y0 : 0)), 1);\n      }).attr('x', function (d, i) {\n        return stacked ? 0 : d.series * x.rangeBand() / data.length;\n      }).attr('width', x.rangeBand() / (stacked ? 1 : data.length));else bars.transition().delay(function (d, i) {\n        return i * delay / data[0].values.length;\n      }).attr('x', function (d, i) {\n        return d.series * x.rangeBand() / data.length;\n      }).attr('width', x.rangeBand() / data.length).attr('y', function (d, i) {\n        return getY(d, i) < 0 ? y(0) : y(0) - y(getY(d, i)) < 1 ? y(0) - 1 : y(getY(d, i)) || 0;\n      }).attr('height', function (d, i) {\n        return Math.max(Math.abs(y(getY(d, i)) - y(0)), 1) || 0;\n      });\n\n      //store old scales for use in transitions on update\n      x0 = x.copy();\n      y0 = y.copy();\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  chart.dispatch = dispatch;\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.x = function (_) {\n    if (!arguments.length) return getX;\n    getX = _;\n    return chart;\n  };\n  chart.y = function (_) {\n    if (!arguments.length) return getY;\n    getY = _;\n    return chart;\n  };\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.xScale = function (_) {\n    if (!arguments.length) return x;\n    x = _;\n    return chart;\n  };\n  chart.yScale = function (_) {\n    if (!arguments.length) return y;\n    y = _;\n    return chart;\n  };\n  chart.xDomain = function (_) {\n    if (!arguments.length) return xDomain;\n    xDomain = _;\n    return chart;\n  };\n  chart.yDomain = function (_) {\n    if (!arguments.length) return yDomain;\n    yDomain = _;\n    return chart;\n  };\n  chart.xRange = function (_) {\n    if (!arguments.length) return xRange;\n    xRange = _;\n    return chart;\n  };\n  chart.yRange = function (_) {\n    if (!arguments.length) return yRange;\n    yRange = _;\n    return chart;\n  };\n  chart.forceY = function (_) {\n    if (!arguments.length) return forceY;\n    forceY = _;\n    return chart;\n  };\n  chart.stacked = function (_) {\n    if (!arguments.length) return stacked;\n    stacked = _;\n    return chart;\n  };\n  chart.stackOffset = function (_) {\n    if (!arguments.length) return stackOffset;\n    stackOffset = _;\n    return chart;\n  };\n  chart.clipEdge = function (_) {\n    if (!arguments.length) return clipEdge;\n    clipEdge = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    return chart;\n  };\n  chart.barColor = function (_) {\n    if (!arguments.length) return barColor;\n    barColor = nv.utils.getColor(_);\n    return chart;\n  };\n  chart.disabled = function (_) {\n    if (!arguments.length) return disabled;\n    disabled = _;\n    return chart;\n  };\n  chart.id = function (_) {\n    if (!arguments.length) return id;\n    id = _;\n    return chart;\n  };\n  chart.hideable = function (_) {\n    if (!arguments.length) return hideable;\n    hideable = _;\n    return chart;\n  };\n  chart.delay = function (_) {\n    if (!arguments.length) return delay;\n    delay = _;\n    return chart;\n  };\n  chart.groupSpacing = function (_) {\n    if (!arguments.length) return groupSpacing;\n    groupSpacing = _;\n    return chart;\n  };\n\n  //============================================================\n\n  return chart;\n};\nnv.models.multiBarChart = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var multibar = nv.models.multiBar(),\n    xAxis = nv.models.axis(),\n    yAxis = nv.models.axis(),\n    legend = nv.models.legend(),\n    controls = nv.models.legend();\n  var margin = {\n      top: 30,\n      right: 20,\n      bottom: 50,\n      left: 60\n    },\n    width = null,\n    height = null,\n    color = nv.utils.defaultColor(),\n    showControls = true,\n    showLegend = true,\n    showXAxis = true,\n    showYAxis = true,\n    rightAlignYAxis = false,\n    reduceXTicks = true // if false a tick will show for every data point\n    ,\n    staggerLabels = false,\n    rotateLabels = 0,\n    tooltips = true,\n    tooltip = function tooltip(key, x, y, e, graph) {\n      return '<h3>' + key + '</h3>' + '<p>' + y + ' on ' + x + '</p>';\n    },\n    x //can be accessed via chart.xScale()\n    ,\n    y //can be accessed via chart.yScale()\n    ,\n    state = {\n      stacked: false\n    },\n    defaultState = null,\n    noData = \"No Data Available.\",\n    dispatch = d3v3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState'),\n    controlWidth = function controlWidth() {\n      return showControls ? 180 : 0;\n    },\n    transitionDuration = 250;\n  multibar.stacked(false);\n  xAxis.orient('bottom').tickPadding(7).highlightZero(true).showMaxMin(false).tickFormat(function (d) {\n    return d;\n  });\n  yAxis.orient(rightAlignYAxis ? 'right' : 'left').tickFormat(d3v3.format(',.1f'));\n  controls.updateState(false);\n  //============================================================\n\n  //============================================================\n  // Private Variables\n  //------------------------------------------------------------\n\n  var showTooltip = function showTooltip(e, offsetElement) {\n    var left = e.pos[0] + (offsetElement.offsetLeft || 0),\n      top = e.pos[1] + (offsetElement.offsetTop || 0),\n      x = xAxis.tickFormat()(multibar.x()(e.point, e.pointIndex)),\n      y = yAxis.tickFormat()(multibar.y()(e.point, e.pointIndex)),\n      content = tooltip(e.series.key, x, y, e, chart);\n    nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);\n  };\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var container = d3v3.select(this),\n        that = this;\n      var availableWidth = (width || parseInt(container.style('width')) || 960) - margin.left - margin.right,\n        availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n      chart.update = function () {\n        container.transition().duration(transitionDuration).call(chart);\n      };\n      chart.container = this;\n\n      //set state.disabled\n      state.disabled = data.map(function (d) {\n        return !!d.disabled;\n      });\n      if (!defaultState) {\n        var key;\n        defaultState = {};\n        for (key in state) {\n          if (state[key] instanceof Array) defaultState[key] = state[key].slice(0);else defaultState[key] = state[key];\n        }\n      }\n      //------------------------------------------------------------\n      // Display noData message if there's nothing to show.\n\n      if (!data || !data.length || !data.filter(function (d) {\n        return d.values.length;\n      }).length) {\n        var noDataText = container.selectAll('.nv-noData').data([noData]);\n        noDataText.enter().append('text').attr('class', 'nvd3 nv-noData').attr('dy', '-.7em').style('text-anchor', 'middle');\n        noDataText.attr('x', margin.left + availableWidth / 2).attr('y', margin.top + availableHeight / 2).text(function (d) {\n          return d;\n        });\n        return chart;\n      } else {\n        container.selectAll('.nv-noData').remove();\n      }\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Scales\n\n      x = multibar.xScale();\n      y = multibar.yScale();\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = container.selectAll('g.nv-wrap.nv-multiBarWithLegend').data([data]);\n      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multiBarWithLegend').append('g');\n      var g = wrap.select('g');\n      gEnter.append('g').attr('class', 'nv-x nv-axis');\n      gEnter.append('g').attr('class', 'nv-y nv-axis');\n      gEnter.append('g').attr('class', 'nv-barsWrap');\n      gEnter.append('g').attr('class', 'nv-legendWrap');\n      gEnter.append('g').attr('class', 'nv-controlsWrap');\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Legend\n\n      if (showLegend) {\n        legend.width(availableWidth - controlWidth());\n        if (multibar.barColor()) data.forEach(function (series, i) {\n          series.color = d3v3.rgb('#ccc').darker(i * 1.5).toString();\n        });\n        g.select('.nv-legendWrap').datum(data).call(legend);\n        if (margin.top != legend.height()) {\n          margin.top = legend.height();\n          availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n        }\n        g.select('.nv-legendWrap').attr('transform', 'translate(' + controlWidth() + ',' + -margin.top + ')');\n      }\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Controls\n\n      if (showControls) {\n        var controlsData = [{\n          key: 'Grouped',\n          disabled: multibar.stacked()\n        }, {\n          key: 'Stacked',\n          disabled: !multibar.stacked()\n        }];\n        controls.width(controlWidth()).color(['#444', '#444', '#444']);\n        g.select('.nv-controlsWrap').datum(controlsData).attr('transform', 'translate(0,' + -margin.top + ')').call(controls);\n      }\n\n      //------------------------------------------------------------\n\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n      if (rightAlignYAxis) {\n        g.select(\".nv-y.nv-axis\").attr(\"transform\", \"translate(\" + availableWidth + \",0)\");\n      }\n\n      //------------------------------------------------------------\n      // Main Chart Component(s)\n\n      multibar.disabled(data.map(function (series) {\n        return series.disabled;\n      })).width(availableWidth).height(availableHeight).color(data.map(function (d, i) {\n        return d.color || color(d, i);\n      }).filter(function (d, i) {\n        return !data[i].disabled;\n      }));\n      var barsWrap = g.select('.nv-barsWrap').datum(data.filter(function (d) {\n        return !d.disabled;\n      }));\n      barsWrap.transition().call(multibar);\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Axes\n\n      if (showXAxis) {\n        xAxis.scale(x).ticks(availableWidth / 100).tickSize(-availableHeight, 0);\n        g.select('.nv-x.nv-axis').attr('transform', 'translate(0,' + y.range()[0] + ')');\n        g.select('.nv-x.nv-axis').transition().call(xAxis);\n        var xTicks = g.select('.nv-x.nv-axis > g').selectAll('g');\n        xTicks.selectAll('line, text').style('opacity', 1);\n        if (staggerLabels) {\n          var getTranslate = function getTranslate(x, y) {\n            return \"translate(\" + x + \",\" + y + \")\";\n          };\n          var staggerUp = 5,\n            staggerDown = 17; //pixels to stagger by\n          // Issue #140\n          xTicks.selectAll(\"text\").attr('transform', function (d, i, j) {\n            return getTranslate(0, j % 2 == 0 ? staggerUp : staggerDown);\n          });\n          var totalInBetweenTicks = d3v3.selectAll(\".nv-x.nv-axis .nv-wrap g g text\")[0].length;\n          g.selectAll(\".nv-x.nv-axis .nv-axisMaxMin text\").attr(\"transform\", function (d, i) {\n            return getTranslate(0, i === 0 || totalInBetweenTicks % 2 !== 0 ? staggerDown : staggerUp);\n          });\n        }\n        if (reduceXTicks) xTicks.filter(function (d, i) {\n          return i % Math.ceil(data[0].values.length / (availableWidth / 100)) !== 0;\n        }).selectAll('text, line').style('opacity', 0);\n        if (rotateLabels) xTicks.selectAll('.tick text').attr('transform', 'rotate(' + rotateLabels + ' 0,0)').style('text-anchor', rotateLabels > 0 ? 'start' : 'end');\n        g.select('.nv-x.nv-axis').selectAll('g.nv-axisMaxMin text').style('opacity', 1);\n      }\n      if (showYAxis) {\n        yAxis.scale(y).ticks(availableHeight / 36).tickSize(-availableWidth, 0);\n        g.select('.nv-y.nv-axis').transition().call(yAxis);\n      }\n\n      //------------------------------------------------------------\n\n      //============================================================\n      // Event Handling/Dispatching (in chart's scope)\n      //------------------------------------------------------------\n\n      legend.dispatch.on('stateChange', function (newState) {\n        state = newState;\n        dispatch.stateChange(state);\n        chart.update();\n      });\n      controls.dispatch.on('legendClick', function (d, i) {\n        if (!d.disabled) return;\n        controlsData = controlsData.map(function (s) {\n          s.disabled = true;\n          return s;\n        });\n        d.disabled = false;\n        switch (d.key) {\n          case 'Grouped':\n            multibar.stacked(false);\n            break;\n          case 'Stacked':\n            multibar.stacked(true);\n            break;\n        }\n        state.stacked = multibar.stacked();\n        dispatch.stateChange(state);\n        chart.update();\n      });\n      dispatch.on('tooltipShow', function (e) {\n        if (tooltips) showTooltip(e, that.parentNode);\n      });\n\n      // Update chart from a state object passed to event handler\n      dispatch.on('changeState', function (e) {\n        if (typeof e.disabled !== 'undefined') {\n          data.forEach(function (series, i) {\n            series.disabled = e.disabled[i];\n          });\n          state.disabled = e.disabled;\n        }\n        if (typeof e.stacked !== 'undefined') {\n          multibar.stacked(e.stacked);\n          state.stacked = e.stacked;\n        }\n        chart.update();\n      });\n\n      //============================================================\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Event Handling/Dispatching (out of chart's scope)\n  //------------------------------------------------------------\n\n  multibar.dispatch.on('elementMouseover.tooltip', function (e) {\n    e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];\n    dispatch.tooltipShow(e);\n  });\n  multibar.dispatch.on('elementMouseout.tooltip', function (e) {\n    dispatch.tooltipHide(e);\n  });\n  dispatch.on('tooltipHide', function () {\n    if (tooltips) nv.tooltip.cleanup();\n  });\n\n  //============================================================\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  // expose chart's sub-components\n  chart.dispatch = dispatch;\n  chart.multibar = multibar;\n  chart.legend = legend;\n  chart.xAxis = xAxis;\n  chart.yAxis = yAxis;\n  d3v3.rebind(chart, multibar, 'x', 'y', 'xDomain', 'yDomain', 'xRange', 'yRange', 'forceX', 'forceY', 'clipEdge', 'id', 'stacked', 'stackOffset', 'delay', 'barColor', 'groupSpacing');\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    legend.color(color);\n    return chart;\n  };\n  chart.showControls = function (_) {\n    if (!arguments.length) return showControls;\n    showControls = _;\n    return chart;\n  };\n  chart.showLegend = function (_) {\n    if (!arguments.length) return showLegend;\n    showLegend = _;\n    return chart;\n  };\n  chart.showXAxis = function (_) {\n    if (!arguments.length) return showXAxis;\n    showXAxis = _;\n    return chart;\n  };\n  chart.showYAxis = function (_) {\n    if (!arguments.length) return showYAxis;\n    showYAxis = _;\n    return chart;\n  };\n  chart.rightAlignYAxis = function (_) {\n    if (!arguments.length) return rightAlignYAxis;\n    rightAlignYAxis = _;\n    yAxis.orient(_ ? 'right' : 'left');\n    return chart;\n  };\n  chart.reduceXTicks = function (_) {\n    if (!arguments.length) return reduceXTicks;\n    reduceXTicks = _;\n    return chart;\n  };\n  chart.rotateLabels = function (_) {\n    if (!arguments.length) return rotateLabels;\n    rotateLabels = _;\n    return chart;\n  };\n  chart.staggerLabels = function (_) {\n    if (!arguments.length) return staggerLabels;\n    staggerLabels = _;\n    return chart;\n  };\n  chart.tooltip = function (_) {\n    if (!arguments.length) return tooltip;\n    tooltip = _;\n    return chart;\n  };\n  chart.tooltips = function (_) {\n    if (!arguments.length) return tooltips;\n    tooltips = _;\n    return chart;\n  };\n  chart.tooltipContent = function (_) {\n    if (!arguments.length) return tooltip;\n    tooltip = _;\n    return chart;\n  };\n  chart.state = function (_) {\n    if (!arguments.length) return state;\n    state = _;\n    return chart;\n  };\n  chart.defaultState = function (_) {\n    if (!arguments.length) return defaultState;\n    defaultState = _;\n    return chart;\n  };\n  chart.noData = function (_) {\n    if (!arguments.length) return noData;\n    noData = _;\n    return chart;\n  };\n  chart.transitionDuration = function (_) {\n    if (!arguments.length) return transitionDuration;\n    transitionDuration = _;\n    return chart;\n  };\n\n  //============================================================\n\n  return chart;\n};\nnv.models.multiBarHorizontal = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var margin = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    },\n    width = 960,\n    height = 500,\n    id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one\n    ,\n    x = d3v3.scale.ordinal(),\n    y = d3v3.scale.linear(),\n    getX = function getX(d) {\n      return d.x;\n    },\n    getY = function getY(d) {\n      return d.y;\n    },\n    forceY = [0] // 0 is forced by default.. this makes sense for the majority of bar graphs... user can always do chart.forceY([]) to remove\n    ,\n    color = nv.utils.defaultColor(),\n    barColor = null // adding the ability to set the color for each rather than the whole group\n    ,\n    disabled // used in conjunction with barColor to communicate from multiBarHorizontalChart what series are disabled\n    ,\n    stacked = false,\n    showValues = false,\n    showBarLabels = false,\n    valuePadding = 60,\n    valueFormat = d3v3.format(',.2f'),\n    delay = 1200,\n    xDomain,\n    yDomain,\n    xRange,\n    yRange,\n    dispatch = d3v3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout');\n\n  //============================================================\n\n  //============================================================\n  // Private Variables\n  //------------------------------------------------------------\n\n  var x0, y0 //used to store previous scales\n  ;\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var availableWidth = width - margin.left - margin.right,\n        availableHeight = height - margin.top - margin.bottom,\n        container = d3v3.select(this);\n      if (stacked) data = d3v3.layout.stack().offset('zero').values(function (d) {\n        return d.values;\n      }).y(getY)(data);\n\n      //add series index to each data point for reference\n      data.forEach(function (series, i) {\n        series.values.forEach(function (point) {\n          point.series = i;\n        });\n      });\n\n      //------------------------------------------------------------\n      // HACK for negative value stacking\n      if (stacked) data[0].values.map(function (d, i) {\n        var posBase = 0,\n          negBase = 0;\n        data.map(function (d) {\n          var f = d.values[i];\n          f.size = Math.abs(f.y);\n          if (f.y < 0) {\n            f.y1 = negBase - f.size;\n            negBase = negBase - f.size;\n          } else {\n            f.y1 = posBase;\n            posBase = posBase + f.size;\n          }\n        });\n      });\n\n      //------------------------------------------------------------\n      // Setup Scales\n\n      // remap and flatten the data for use in calculating the scales' domains\n      var seriesData = xDomain && yDomain ? [] :\n      // if we know xDomain and yDomain, no need to calculate\n      data.map(function (d) {\n        return d.values.map(function (d, i) {\n          return {\n            x: getX(d, i),\n            y: getY(d, i),\n            y0: d.y0,\n            y1: d.y1\n          };\n        });\n      });\n      x.domain(xDomain || d3v3.merge(seriesData).map(function (d) {\n        return d.x;\n      })).rangeBands(xRange || [0, availableHeight], .1);\n\n      //y   .domain(yDomain || d3v3.extent(d3v3.merge(seriesData).map(function(d) { return d.y + (stacked ? d.y0 : 0) }).concat(forceY)))\n      y.domain(yDomain || d3v3.extent(d3v3.merge(seriesData).map(function (d) {\n        return stacked ? d.y > 0 ? d.y1 + d.y : d.y1 : d.y;\n      }).concat(forceY)));\n      if (showValues && !stacked) y.range(yRange || [y.domain()[0] < 0 ? valuePadding : 0, availableWidth - (y.domain()[1] > 0 ? valuePadding : 0)]);else y.range(yRange || [0, availableWidth]);\n      x0 = x0 || x;\n      y0 = y0 || d3v3.scale.linear().domain(y.domain()).range([y(0), y(0)]);\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = d3v3.select(this).selectAll('g.nv-wrap.nv-multibarHorizontal').data([data]);\n      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multibarHorizontal');\n      var defsEnter = wrapEnter.append('defs');\n      var gEnter = wrapEnter.append('g');\n      var g = wrap.select('g');\n      gEnter.append('g').attr('class', 'nv-groups');\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n      //------------------------------------------------------------\n\n      var groups = wrap.select('.nv-groups').selectAll('.nv-group').data(function (d) {\n        return d;\n      }, function (d, i) {\n        return i;\n      });\n      groups.enter().append('g').style('stroke-opacity', 1e-6).style('fill-opacity', 1e-6);\n      groups.exit().transition().style('stroke-opacity', 1e-6).style('fill-opacity', 1e-6).remove();\n      groups.attr('class', function (d, i) {\n        return 'nv-group nv-series-' + i;\n      }).classed('hover', function (d) {\n        return d.hover;\n      }).style('fill', function (d, i) {\n        return color(d, i);\n      }).style('stroke', function (d, i) {\n        return color(d, i);\n      });\n      groups.transition().style('stroke-opacity', 1).style('fill-opacity', .75);\n      var bars = groups.selectAll('g.nv-bar').data(function (d) {\n        return d.values;\n      });\n      bars.exit().remove();\n      var barsEnter = bars.enter().append('g').attr('transform', function (d, i, j) {\n        return 'translate(' + y0(stacked ? d.y0 : 0) + ',' + (stacked ? 0 : j * x.rangeBand() / data.length + x(getX(d, i))) + ')';\n      });\n      barsEnter.append('rect').attr('width', 0).attr('height', x.rangeBand() / (stacked ? 1 : data.length));\n      bars.on('mouseover', function (d, i) {\n        //TODO: figure out why j works above, but not here\n        d3v3.select(this).classed('hover', true);\n        dispatch.elementMouseover({\n          value: getY(d, i),\n          point: d,\n          series: data[d.series],\n          pos: [y(getY(d, i) + (stacked ? d.y0 : 0)), x(getX(d, i)) + x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length],\n          pointIndex: i,\n          seriesIndex: d.series,\n          e: d3v3.event\n        });\n      }).on('mouseout', function (d, i) {\n        d3v3.select(this).classed('hover', false);\n        dispatch.elementMouseout({\n          value: getY(d, i),\n          point: d,\n          series: data[d.series],\n          pointIndex: i,\n          seriesIndex: d.series,\n          e: d3v3.event\n        });\n      }).on('click', function (d, i) {\n        dispatch.elementClick({\n          value: getY(d, i),\n          point: d,\n          series: data[d.series],\n          pos: [x(getX(d, i)) + x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length, y(getY(d, i) + (stacked ? d.y0 : 0))],\n          // TODO: Figure out why the value appears to be shifted\n          pointIndex: i,\n          seriesIndex: d.series,\n          e: d3v3.event\n        });\n        d3v3.event.stopPropagation();\n      }).on('dblclick', function (d, i) {\n        dispatch.elementDblClick({\n          value: getY(d, i),\n          point: d,\n          series: data[d.series],\n          pos: [x(getX(d, i)) + x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length, y(getY(d, i) + (stacked ? d.y0 : 0))],\n          // TODO: Figure out why the value appears to be shifted\n          pointIndex: i,\n          seriesIndex: d.series,\n          e: d3v3.event\n        });\n        d3v3.event.stopPropagation();\n      });\n      barsEnter.append('text');\n      if (showValues && !stacked) {\n        bars.select('text').attr('text-anchor', function (d, i) {\n          return getY(d, i) < 0 ? 'end' : 'start';\n        }).attr('y', x.rangeBand() / (data.length * 2)).attr('dy', '.32em').text(function (d, i) {\n          return valueFormat(getY(d, i));\n        });\n        bars.transition().select('text').attr('x', function (d, i) {\n          return getY(d, i) < 0 ? -4 : y(getY(d, i)) - y(0) + 4;\n        });\n      } else {\n        bars.selectAll('text').text('');\n      }\n      if (showBarLabels && !stacked) {\n        barsEnter.append('text').classed('nv-bar-label', true);\n        bars.select('text.nv-bar-label').attr('text-anchor', function (d, i) {\n          return getY(d, i) < 0 ? 'start' : 'end';\n        }).attr('y', x.rangeBand() / (data.length * 2)).attr('dy', '.32em').text(function (d, i) {\n          return getX(d, i);\n        });\n        bars.transition().select('text.nv-bar-label').attr('x', function (d, i) {\n          return getY(d, i) < 0 ? y(0) - y(getY(d, i)) + 4 : -4;\n        });\n      } else {\n        bars.selectAll('text.nv-bar-label').text('');\n      }\n      bars.attr('class', function (d, i) {\n        return getY(d, i) < 0 ? 'nv-bar negative' : 'nv-bar positive';\n      });\n      if (barColor) {\n        if (!disabled) disabled = data.map(function () {\n          return true;\n        });\n        bars.style('fill', function (d, i, j) {\n          return d3v3.rgb(barColor(d, i)).darker(disabled.map(function (d, i) {\n            return i;\n          }).filter(function (d, i) {\n            return !disabled[i];\n          })[j]).toString();\n        }).style('stroke', function (d, i, j) {\n          return d3v3.rgb(barColor(d, i)).darker(disabled.map(function (d, i) {\n            return i;\n          }).filter(function (d, i) {\n            return !disabled[i];\n          })[j]).toString();\n        });\n      }\n      if (stacked) bars.transition().attr('transform', function (d, i) {\n        return 'translate(' + y(d.y1) + ',' + x(getX(d, i)) + ')';\n      }).select('rect').attr('width', function (d, i) {\n        return Math.abs(y(getY(d, i) + d.y0) - y(d.y0));\n      }).attr('height', x.rangeBand());else bars.transition().attr('transform', function (d, i) {\n        //TODO: stacked must be all positive or all negative, not both?\n        return 'translate(' + (getY(d, i) < 0 ? y(getY(d, i)) : y(0)) + ',' + (d.series * x.rangeBand() / data.length + x(getX(d, i))) + ')';\n      }).select('rect').attr('height', x.rangeBand() / data.length).attr('width', function (d, i) {\n        return Math.max(Math.abs(y(getY(d, i)) - y(0)), 1);\n      });\n\n      //store old scales for use in transitions on update\n      x0 = x.copy();\n      y0 = y.copy();\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  chart.dispatch = dispatch;\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.x = function (_) {\n    if (!arguments.length) return getX;\n    getX = _;\n    return chart;\n  };\n  chart.y = function (_) {\n    if (!arguments.length) return getY;\n    getY = _;\n    return chart;\n  };\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.xScale = function (_) {\n    if (!arguments.length) return x;\n    x = _;\n    return chart;\n  };\n  chart.yScale = function (_) {\n    if (!arguments.length) return y;\n    y = _;\n    return chart;\n  };\n  chart.xDomain = function (_) {\n    if (!arguments.length) return xDomain;\n    xDomain = _;\n    return chart;\n  };\n  chart.yDomain = function (_) {\n    if (!arguments.length) return yDomain;\n    yDomain = _;\n    return chart;\n  };\n  chart.xRange = function (_) {\n    if (!arguments.length) return xRange;\n    xRange = _;\n    return chart;\n  };\n  chart.yRange = function (_) {\n    if (!arguments.length) return yRange;\n    yRange = _;\n    return chart;\n  };\n  chart.forceY = function (_) {\n    if (!arguments.length) return forceY;\n    forceY = _;\n    return chart;\n  };\n  chart.stacked = function (_) {\n    if (!arguments.length) return stacked;\n    stacked = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    return chart;\n  };\n  chart.barColor = function (_) {\n    if (!arguments.length) return barColor;\n    barColor = nv.utils.getColor(_);\n    return chart;\n  };\n  chart.disabled = function (_) {\n    if (!arguments.length) return disabled;\n    disabled = _;\n    return chart;\n  };\n  chart.id = function (_) {\n    if (!arguments.length) return id;\n    id = _;\n    return chart;\n  };\n  chart.delay = function (_) {\n    if (!arguments.length) return delay;\n    delay = _;\n    return chart;\n  };\n  chart.showValues = function (_) {\n    if (!arguments.length) return showValues;\n    showValues = _;\n    return chart;\n  };\n  chart.showBarLabels = function (_) {\n    if (!arguments.length) return showBarLabels;\n    showBarLabels = _;\n    return chart;\n  };\n  chart.valueFormat = function (_) {\n    if (!arguments.length) return valueFormat;\n    valueFormat = _;\n    return chart;\n  };\n  chart.valuePadding = function (_) {\n    if (!arguments.length) return valuePadding;\n    valuePadding = _;\n    return chart;\n  };\n\n  //============================================================\n\n  return chart;\n};\nnv.models.multiBarHorizontalChart = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var multibar = nv.models.multiBarHorizontal(),\n    xAxis = nv.models.axis(),\n    yAxis = nv.models.axis(),\n    legend = nv.models.legend().height(30),\n    controls = nv.models.legend().height(30);\n  var margin = {\n      top: 30,\n      right: 20,\n      bottom: 50,\n      left: 60\n    },\n    width = null,\n    height = null,\n    color = nv.utils.defaultColor(),\n    showControls = true,\n    showLegend = true,\n    showXAxis = true,\n    showYAxis = true,\n    stacked = false,\n    tooltips = true,\n    tooltip = function tooltip(key, x, y, e, graph) {\n      return '<h3>' + key + ' - ' + x + '</h3>' + '<p>' + y + '</p>';\n    },\n    x //can be accessed via chart.xScale()\n    ,\n    y //can be accessed via chart.yScale()\n    ,\n    state = {\n      stacked: stacked\n    },\n    defaultState = null,\n    noData = 'No Data Available.',\n    dispatch = d3v3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState'),\n    controlWidth = function controlWidth() {\n      return showControls ? 180 : 0;\n    },\n    transitionDuration = 250;\n  multibar.stacked(stacked);\n  xAxis.orient('left').tickPadding(5).highlightZero(false).showMaxMin(false).tickFormat(function (d) {\n    return d;\n  });\n  yAxis.orient('bottom').tickFormat(d3v3.format(',.1f'));\n  controls.updateState(false);\n  //============================================================\n\n  //============================================================\n  // Private Variables\n  //------------------------------------------------------------\n\n  var showTooltip = function showTooltip(e, offsetElement) {\n    var left = e.pos[0] + (offsetElement.offsetLeft || 0),\n      top = e.pos[1] + (offsetElement.offsetTop || 0),\n      x = xAxis.tickFormat()(multibar.x()(e.point, e.pointIndex)),\n      y = yAxis.tickFormat()(multibar.y()(e.point, e.pointIndex)),\n      content = tooltip(e.series.key, x, y, e, chart);\n    nv.tooltip.show([left, top], content, e.value < 0 ? 'e' : 'w', null, offsetElement);\n  };\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var container = d3v3.select(this),\n        that = this;\n      var availableWidth = (width || parseInt(container.style('width')) || 960) - margin.left - margin.right,\n        availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n      chart.update = function () {\n        container.transition().duration(transitionDuration).call(chart);\n      };\n      chart.container = this;\n\n      //set state.disabled\n      state.disabled = data.map(function (d) {\n        return !!d.disabled;\n      });\n      if (!defaultState) {\n        var key;\n        defaultState = {};\n        for (key in state) {\n          if (state[key] instanceof Array) defaultState[key] = state[key].slice(0);else defaultState[key] = state[key];\n        }\n      }\n\n      //------------------------------------------------------------\n      // Display No Data message if there's nothing to show.\n\n      if (!data || !data.length || !data.filter(function (d) {\n        return d.values.length;\n      }).length) {\n        var noDataText = container.selectAll('.nv-noData').data([noData]);\n        noDataText.enter().append('text').attr('class', 'nvd3 nv-noData').attr('dy', '-.7em').style('text-anchor', 'middle');\n        noDataText.attr('x', margin.left + availableWidth / 2).attr('y', margin.top + availableHeight / 2).text(function (d) {\n          return d;\n        });\n        return chart;\n      } else {\n        container.selectAll('.nv-noData').remove();\n      }\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Scales\n\n      x = multibar.xScale();\n      y = multibar.yScale();\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = container.selectAll('g.nv-wrap.nv-multiBarHorizontalChart').data([data]);\n      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multiBarHorizontalChart').append('g');\n      var g = wrap.select('g');\n      gEnter.append('g').attr('class', 'nv-x nv-axis');\n      gEnter.append('g').attr('class', 'nv-y nv-axis').append('g').attr('class', 'nv-zeroLine').append('line');\n      gEnter.append('g').attr('class', 'nv-barsWrap');\n      gEnter.append('g').attr('class', 'nv-legendWrap');\n      gEnter.append('g').attr('class', 'nv-controlsWrap');\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Legend\n\n      if (showLegend) {\n        legend.width(availableWidth - controlWidth());\n        if (multibar.barColor()) data.forEach(function (series, i) {\n          series.color = d3v3.rgb('#ccc').darker(i * 1.5).toString();\n        });\n        g.select('.nv-legendWrap').datum(data).call(legend);\n        if (margin.top != legend.height()) {\n          margin.top = legend.height();\n          availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n        }\n        g.select('.nv-legendWrap').attr('transform', 'translate(' + controlWidth() + ',' + -margin.top + ')');\n      }\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Controls\n\n      if (showControls) {\n        var controlsData = [{\n          key: 'Grouped',\n          disabled: multibar.stacked()\n        }, {\n          key: 'Stacked',\n          disabled: !multibar.stacked()\n        }];\n        controls.width(controlWidth()).color(['#444', '#444', '#444']);\n        g.select('.nv-controlsWrap').datum(controlsData).attr('transform', 'translate(0,' + -margin.top + ')').call(controls);\n      }\n\n      //------------------------------------------------------------\n\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n      //------------------------------------------------------------\n      // Main Chart Component(s)\n\n      multibar.disabled(data.map(function (series) {\n        return series.disabled;\n      })).width(availableWidth).height(availableHeight).color(data.map(function (d, i) {\n        return d.color || color(d, i);\n      }).filter(function (d, i) {\n        return !data[i].disabled;\n      }));\n      var barsWrap = g.select('.nv-barsWrap').datum(data.filter(function (d) {\n        return !d.disabled;\n      }));\n      barsWrap.transition().call(multibar);\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Axes\n\n      if (showXAxis) {\n        xAxis.scale(x).ticks(availableHeight / 24).tickSize(-availableWidth, 0);\n        g.select('.nv-x.nv-axis').transition().call(xAxis);\n        var xTicks = g.select('.nv-x.nv-axis').selectAll('g');\n        xTicks.selectAll('line, text');\n      }\n      if (showYAxis) {\n        yAxis.scale(y).ticks(availableWidth / 100).tickSize(-availableHeight, 0);\n        g.select('.nv-y.nv-axis').attr('transform', 'translate(0,' + availableHeight + ')');\n        g.select('.nv-y.nv-axis').transition().call(yAxis);\n      }\n\n      // Zero line\n      g.select(\".nv-zeroLine line\").attr(\"x1\", y(0)).attr(\"x2\", y(0)).attr(\"y1\", 0).attr(\"y2\", -availableHeight);\n\n      //------------------------------------------------------------\n\n      //============================================================\n      // Event Handling/Dispatching (in chart's scope)\n      //------------------------------------------------------------\n\n      legend.dispatch.on('stateChange', function (newState) {\n        state = newState;\n        dispatch.stateChange(state);\n        chart.update();\n      });\n      controls.dispatch.on('legendClick', function (d, i) {\n        if (!d.disabled) return;\n        controlsData = controlsData.map(function (s) {\n          s.disabled = true;\n          return s;\n        });\n        d.disabled = false;\n        switch (d.key) {\n          case 'Grouped':\n            multibar.stacked(false);\n            break;\n          case 'Stacked':\n            multibar.stacked(true);\n            break;\n        }\n        state.stacked = multibar.stacked();\n        dispatch.stateChange(state);\n        chart.update();\n      });\n      dispatch.on('tooltipShow', function (e) {\n        if (tooltips) showTooltip(e, that.parentNode);\n      });\n\n      // Update chart from a state object passed to event handler\n      dispatch.on('changeState', function (e) {\n        if (typeof e.disabled !== 'undefined') {\n          data.forEach(function (series, i) {\n            series.disabled = e.disabled[i];\n          });\n          state.disabled = e.disabled;\n        }\n        if (typeof e.stacked !== 'undefined') {\n          multibar.stacked(e.stacked);\n          state.stacked = e.stacked;\n        }\n        chart.update();\n      });\n      //============================================================\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Event Handling/Dispatching (out of chart's scope)\n  //------------------------------------------------------------\n\n  multibar.dispatch.on('elementMouseover.tooltip', function (e) {\n    e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];\n    dispatch.tooltipShow(e);\n  });\n  multibar.dispatch.on('elementMouseout.tooltip', function (e) {\n    dispatch.tooltipHide(e);\n  });\n  dispatch.on('tooltipHide', function () {\n    if (tooltips) nv.tooltip.cleanup();\n  });\n\n  //============================================================\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  // expose chart's sub-components\n  chart.dispatch = dispatch;\n  chart.multibar = multibar;\n  chart.legend = legend;\n  chart.xAxis = xAxis;\n  chart.yAxis = yAxis;\n  d3v3.rebind(chart, multibar, 'x', 'y', 'xDomain', 'yDomain', 'xRange', 'yRange', 'forceX', 'forceY', 'clipEdge', 'id', 'delay', 'showValues', 'showBarLabels', 'valueFormat', 'stacked', 'barColor');\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    legend.color(color);\n    return chart;\n  };\n  chart.showControls = function (_) {\n    if (!arguments.length) return showControls;\n    showControls = _;\n    return chart;\n  };\n  chart.showLegend = function (_) {\n    if (!arguments.length) return showLegend;\n    showLegend = _;\n    return chart;\n  };\n  chart.showXAxis = function (_) {\n    if (!arguments.length) return showXAxis;\n    showXAxis = _;\n    return chart;\n  };\n  chart.showYAxis = function (_) {\n    if (!arguments.length) return showYAxis;\n    showYAxis = _;\n    return chart;\n  };\n  chart.tooltip = function (_) {\n    if (!arguments.length) return tooltip;\n    tooltip = _;\n    return chart;\n  };\n  chart.tooltips = function (_) {\n    if (!arguments.length) return tooltips;\n    tooltips = _;\n    return chart;\n  };\n  chart.tooltipContent = function (_) {\n    if (!arguments.length) return tooltip;\n    tooltip = _;\n    return chart;\n  };\n  chart.state = function (_) {\n    if (!arguments.length) return state;\n    state = _;\n    return chart;\n  };\n  chart.defaultState = function (_) {\n    if (!arguments.length) return defaultState;\n    defaultState = _;\n    return chart;\n  };\n  chart.noData = function (_) {\n    if (!arguments.length) return noData;\n    noData = _;\n    return chart;\n  };\n  chart.transitionDuration = function (_) {\n    if (!arguments.length) return transitionDuration;\n    transitionDuration = _;\n    return chart;\n  };\n  //============================================================\n\n  return chart;\n};\nnv.models.multiChart = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var margin = {\n      top: 30,\n      right: 20,\n      bottom: 50,\n      left: 60\n    },\n    color = d3v3.scale.category20().range(),\n    width = null,\n    height = null,\n    showLegend = true,\n    tooltips = true,\n    tooltip = function tooltip(key, x, y, e, graph) {\n      return '<h3>' + key + '</h3>' + '<p>' + y + ' at ' + x + '</p>';\n    },\n    x,\n    y,\n    yDomain1,\n    yDomain2; //can be accessed via chart.lines.[x/y]Scale()\n\n  //============================================================\n  // Private Variables\n  //------------------------------------------------------------\n\n  var x = d3v3.scale.linear(),\n    yScale1 = d3v3.scale.linear(),\n    yScale2 = d3v3.scale.linear(),\n    lines1 = nv.models.line().yScale(yScale1),\n    lines2 = nv.models.line().yScale(yScale2),\n    bars1 = nv.models.multiBar().stacked(false).yScale(yScale1),\n    bars2 = nv.models.multiBar().stacked(false).yScale(yScale2),\n    stack1 = nv.models.stackedArea().yScale(yScale1),\n    stack2 = nv.models.stackedArea().yScale(yScale2),\n    xAxis = nv.models.axis().scale(x).orient('bottom').tickPadding(5),\n    yAxis1 = nv.models.axis().scale(yScale1).orient('left'),\n    yAxis2 = nv.models.axis().scale(yScale2).orient('right'),\n    legend = nv.models.legend().height(30),\n    dispatch = d3v3.dispatch('tooltipShow', 'tooltipHide');\n  var showTooltip = function showTooltip(e, offsetElement) {\n    var left = e.pos[0] + (offsetElement.offsetLeft || 0),\n      top = e.pos[1] + (offsetElement.offsetTop || 0),\n      x = xAxis.tickFormat()(lines1.x()(e.point, e.pointIndex)),\n      y = (e.series.yAxis == 2 ? yAxis2 : yAxis1).tickFormat()(lines1.y()(e.point, e.pointIndex)),\n      content = tooltip(e.series.key, x, y, e, chart);\n    nv.tooltip.show([left, top], content, undefined, undefined, offsetElement.offsetParent);\n  };\n  function chart(selection) {\n    selection.each(function (data) {\n      var container = d3v3.select(this),\n        that = this;\n      chart.update = function () {\n        container.transition().call(chart);\n      };\n      chart.container = this;\n      var availableWidth = (width || parseInt(container.style('width')) || 960) - margin.left - margin.right,\n        availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n      var dataLines1 = data.filter(function (d) {\n        return !d.disabled && d.type == 'line' && d.yAxis == 1;\n      });\n      var dataLines2 = data.filter(function (d) {\n        return !d.disabled && d.type == 'line' && d.yAxis == 2;\n      });\n      var dataBars1 = data.filter(function (d) {\n        return !d.disabled && d.type == 'bar' && d.yAxis == 1;\n      });\n      var dataBars2 = data.filter(function (d) {\n        return !d.disabled && d.type == 'bar' && d.yAxis == 2;\n      });\n      var dataStack1 = data.filter(function (d) {\n        return !d.disabled && d.type == 'area' && d.yAxis == 1;\n      });\n      var dataStack2 = data.filter(function (d) {\n        return !d.disabled && d.type == 'area' && d.yAxis == 2;\n      });\n      var series1 = data.filter(function (d) {\n        return !d.disabled && d.yAxis == 1;\n      }).map(function (d) {\n        return d.values.map(function (d, i) {\n          return {\n            x: d.x,\n            y: d.y\n          };\n        });\n      });\n      var series2 = data.filter(function (d) {\n        return !d.disabled && d.yAxis == 2;\n      }).map(function (d) {\n        return d.values.map(function (d, i) {\n          return {\n            x: d.x,\n            y: d.y\n          };\n        });\n      });\n      x.domain(d3v3.extent(d3v3.merge(series1.concat(series2)), function (d) {\n        return d.x;\n      })).range([0, availableWidth]);\n      var wrap = container.selectAll('g.wrap.multiChart').data([data]);\n      var gEnter = wrap.enter().append('g').attr('class', 'wrap nvd3 multiChart').append('g');\n      gEnter.append('g').attr('class', 'x axis');\n      gEnter.append('g').attr('class', 'y1 axis');\n      gEnter.append('g').attr('class', 'y2 axis');\n      gEnter.append('g').attr('class', 'lines1Wrap');\n      gEnter.append('g').attr('class', 'lines2Wrap');\n      gEnter.append('g').attr('class', 'bars1Wrap');\n      gEnter.append('g').attr('class', 'bars2Wrap');\n      gEnter.append('g').attr('class', 'stack1Wrap');\n      gEnter.append('g').attr('class', 'stack2Wrap');\n      gEnter.append('g').attr('class', 'legendWrap');\n      var g = wrap.select('g');\n      if (showLegend) {\n        legend.width(availableWidth / 2);\n        g.select('.legendWrap').datum(data.map(function (series) {\n          series.originalKey = series.originalKey === undefined ? series.key : series.originalKey;\n          series.key = series.originalKey + (series.yAxis == 1 ? '' : ' (right axis)');\n          return series;\n        })).call(legend);\n        if (margin.top != legend.height()) {\n          margin.top = legend.height();\n          availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n        }\n        g.select('.legendWrap').attr('transform', 'translate(' + availableWidth / 2 + ',' + -margin.top + ')');\n      }\n      lines1.width(availableWidth).height(availableHeight).interpolate(\"monotone\").color(data.map(function (d, i) {\n        return d.color || color[i % color.length];\n      }).filter(function (d, i) {\n        return !data[i].disabled && data[i].yAxis == 1 && data[i].type == 'line';\n      }));\n      lines2.width(availableWidth).height(availableHeight).interpolate(\"monotone\").color(data.map(function (d, i) {\n        return d.color || color[i % color.length];\n      }).filter(function (d, i) {\n        return !data[i].disabled && data[i].yAxis == 2 && data[i].type == 'line';\n      }));\n      bars1.width(availableWidth).height(availableHeight).color(data.map(function (d, i) {\n        return d.color || color[i % color.length];\n      }).filter(function (d, i) {\n        return !data[i].disabled && data[i].yAxis == 1 && data[i].type == 'bar';\n      }));\n      bars2.width(availableWidth).height(availableHeight).color(data.map(function (d, i) {\n        return d.color || color[i % color.length];\n      }).filter(function (d, i) {\n        return !data[i].disabled && data[i].yAxis == 2 && data[i].type == 'bar';\n      }));\n      stack1.width(availableWidth).height(availableHeight).color(data.map(function (d, i) {\n        return d.color || color[i % color.length];\n      }).filter(function (d, i) {\n        return !data[i].disabled && data[i].yAxis == 1 && data[i].type == 'area';\n      }));\n      stack2.width(availableWidth).height(availableHeight).color(data.map(function (d, i) {\n        return d.color || color[i % color.length];\n      }).filter(function (d, i) {\n        return !data[i].disabled && data[i].yAxis == 2 && data[i].type == 'area';\n      }));\n      g.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n      var lines1Wrap = g.select('.lines1Wrap').datum(dataLines1);\n      var bars1Wrap = g.select('.bars1Wrap').datum(dataBars1);\n      var stack1Wrap = g.select('.stack1Wrap').datum(dataStack1);\n      var lines2Wrap = g.select('.lines2Wrap').datum(dataLines2);\n      var bars2Wrap = g.select('.bars2Wrap').datum(dataBars2);\n      var stack2Wrap = g.select('.stack2Wrap').datum(dataStack2);\n      var extraValue1 = dataStack1.length ? dataStack1.map(function (a) {\n        return a.values;\n      }).reduce(function (a, b) {\n        return a.map(function (aVal, i) {\n          return {\n            x: aVal.x,\n            y: aVal.y + b[i].y\n          };\n        });\n      }).concat([{\n        x: 0,\n        y: 0\n      }]) : [];\n      var extraValue2 = dataStack2.length ? dataStack2.map(function (a) {\n        return a.values;\n      }).reduce(function (a, b) {\n        return a.map(function (aVal, i) {\n          return {\n            x: aVal.x,\n            y: aVal.y + b[i].y\n          };\n        });\n      }).concat([{\n        x: 0,\n        y: 0\n      }]) : [];\n      yScale1.domain(yDomain1 || d3v3.extent(d3v3.merge(series1).concat(extraValue1), function (d) {\n        return d.y;\n      })).range([0, availableHeight]);\n      yScale2.domain(yDomain2 || d3v3.extent(d3v3.merge(series2).concat(extraValue2), function (d) {\n        return d.y;\n      })).range([0, availableHeight]);\n      lines1.yDomain(yScale1.domain());\n      bars1.yDomain(yScale1.domain());\n      stack1.yDomain(yScale1.domain());\n      lines2.yDomain(yScale2.domain());\n      bars2.yDomain(yScale2.domain());\n      stack2.yDomain(yScale2.domain());\n      if (dataStack1.length) {\n        d3v3.transition(stack1Wrap).call(stack1);\n      }\n      if (dataStack2.length) {\n        d3v3.transition(stack2Wrap).call(stack2);\n      }\n      if (dataBars1.length) {\n        d3v3.transition(bars1Wrap).call(bars1);\n      }\n      if (dataBars2.length) {\n        d3v3.transition(bars2Wrap).call(bars2);\n      }\n      if (dataLines1.length) {\n        d3v3.transition(lines1Wrap).call(lines1);\n      }\n      if (dataLines2.length) {\n        d3v3.transition(lines2Wrap).call(lines2);\n      }\n      xAxis.ticks(availableWidth / 100).tickSize(-availableHeight, 0);\n      g.select('.x.axis').attr('transform', 'translate(0,' + availableHeight + ')');\n      d3v3.transition(g.select('.x.axis')).call(xAxis);\n      yAxis1.ticks(availableHeight / 36).tickSize(-availableWidth, 0);\n      d3v3.transition(g.select('.y1.axis')).call(yAxis1);\n      yAxis2.ticks(availableHeight / 36).tickSize(-availableWidth, 0);\n      d3v3.transition(g.select('.y2.axis')).call(yAxis2);\n      g.select('.y2.axis').style('opacity', series2.length ? 1 : 0).attr('transform', 'translate(' + x.range()[1] + ',0)');\n      legend.dispatch.on('stateChange', function (newState) {\n        chart.update();\n      });\n      dispatch.on('tooltipShow', function (e) {\n        if (tooltips) showTooltip(e, that.parentNode);\n      });\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Event Handling/Dispatching (out of chart's scope)\n  //------------------------------------------------------------\n\n  lines1.dispatch.on('elementMouseover.tooltip', function (e) {\n    e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];\n    dispatch.tooltipShow(e);\n  });\n  lines1.dispatch.on('elementMouseout.tooltip', function (e) {\n    dispatch.tooltipHide(e);\n  });\n  lines2.dispatch.on('elementMouseover.tooltip', function (e) {\n    e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];\n    dispatch.tooltipShow(e);\n  });\n  lines2.dispatch.on('elementMouseout.tooltip', function (e) {\n    dispatch.tooltipHide(e);\n  });\n  bars1.dispatch.on('elementMouseover.tooltip', function (e) {\n    e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];\n    dispatch.tooltipShow(e);\n  });\n  bars1.dispatch.on('elementMouseout.tooltip', function (e) {\n    dispatch.tooltipHide(e);\n  });\n  bars2.dispatch.on('elementMouseover.tooltip', function (e) {\n    e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];\n    dispatch.tooltipShow(e);\n  });\n  bars2.dispatch.on('elementMouseout.tooltip', function (e) {\n    dispatch.tooltipHide(e);\n  });\n  stack1.dispatch.on('tooltipShow', function (e) {\n    //disable tooltips when value ~= 0\n    //// TODO: consider removing points from voronoi that have 0 value instead of this hack\n    if (!Math.round(stack1.y()(e.point) * 100)) {\n      // 100 will not be good for very small numbers... will have to think about making this valu dynamic, based on data range\n      setTimeout(function () {\n        d3v3.selectAll('.point.hover').classed('hover', false);\n      }, 0);\n      return false;\n    }\n    e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top], dispatch.tooltipShow(e);\n  });\n  stack1.dispatch.on('tooltipHide', function (e) {\n    dispatch.tooltipHide(e);\n  });\n  stack2.dispatch.on('tooltipShow', function (e) {\n    //disable tooltips when value ~= 0\n    //// TODO: consider removing points from voronoi that have 0 value instead of this hack\n    if (!Math.round(stack2.y()(e.point) * 100)) {\n      // 100 will not be good for very small numbers... will have to think about making this valu dynamic, based on data range\n      setTimeout(function () {\n        d3v3.selectAll('.point.hover').classed('hover', false);\n      }, 0);\n      return false;\n    }\n    e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top], dispatch.tooltipShow(e);\n  });\n  stack2.dispatch.on('tooltipHide', function (e) {\n    dispatch.tooltipHide(e);\n  });\n  lines1.dispatch.on('elementMouseover.tooltip', function (e) {\n    e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];\n    dispatch.tooltipShow(e);\n  });\n  lines1.dispatch.on('elementMouseout.tooltip', function (e) {\n    dispatch.tooltipHide(e);\n  });\n  lines2.dispatch.on('elementMouseover.tooltip', function (e) {\n    e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];\n    dispatch.tooltipShow(e);\n  });\n  lines2.dispatch.on('elementMouseout.tooltip', function (e) {\n    dispatch.tooltipHide(e);\n  });\n  dispatch.on('tooltipHide', function () {\n    if (tooltips) nv.tooltip.cleanup();\n  });\n\n  //============================================================\n  // Global getters and setters\n  //------------------------------------------------------------\n\n  chart.dispatch = dispatch;\n  chart.lines1 = lines1;\n  chart.lines2 = lines2;\n  chart.bars1 = bars1;\n  chart.bars2 = bars2;\n  chart.stack1 = stack1;\n  chart.stack2 = stack2;\n  chart.xAxis = xAxis;\n  chart.yAxis1 = yAxis1;\n  chart.yAxis2 = yAxis2;\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.x = function (_) {\n    if (!arguments.length) return getX;\n    getX = _;\n    lines1.x(_);\n    bars1.x(_);\n    return chart;\n  };\n  chart.y = function (_) {\n    if (!arguments.length) return getY;\n    getY = _;\n    lines1.y(_);\n    bars1.y(_);\n    return chart;\n  };\n  chart.yDomain1 = function (_) {\n    if (!arguments.length) return yDomain1;\n    yDomain1 = _;\n    return chart;\n  };\n  chart.yDomain2 = function (_) {\n    if (!arguments.length) return yDomain2;\n    yDomain2 = _;\n    return chart;\n  };\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin = _;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = _;\n    legend.color(_);\n    return chart;\n  };\n  chart.showLegend = function (_) {\n    if (!arguments.length) return showLegend;\n    showLegend = _;\n    return chart;\n  };\n  chart.tooltips = function (_) {\n    if (!arguments.length) return tooltips;\n    tooltips = _;\n    return chart;\n  };\n  chart.tooltipContent = function (_) {\n    if (!arguments.length) return tooltip;\n    tooltip = _;\n    return chart;\n  };\n  return chart;\n};\nnv.models.ohlcBar = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var margin = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    },\n    width = 960,\n    height = 500,\n    id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one\n    ,\n    x = d3v3.scale.linear(),\n    y = d3v3.scale.linear(),\n    getX = function getX(d) {\n      return d.x;\n    },\n    getY = function getY(d) {\n      return d.y;\n    },\n    getOpen = function getOpen(d) {\n      return d.open;\n    },\n    getClose = function getClose(d) {\n      return d.close;\n    },\n    getHigh = function getHigh(d) {\n      return d.high;\n    },\n    getLow = function getLow(d) {\n      return d.low;\n    },\n    forceX = [],\n    forceY = [],\n    padData = false // If true, adds half a data points width to front and back, for lining up a line chart with a bar chart\n    ,\n    clipEdge = true,\n    color = nv.utils.defaultColor(),\n    xDomain,\n    yDomain,\n    xRange,\n    yRange,\n    dispatch = d3v3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout');\n\n  //============================================================\n\n  //============================================================\n  // Private Variables\n  //------------------------------------------------------------\n\n  //TODO: store old scales for transitions\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var availableWidth = width - margin.left - margin.right,\n        availableHeight = height - margin.top - margin.bottom,\n        container = d3v3.select(this);\n\n      //------------------------------------------------------------\n      // Setup Scales\n\n      x.domain(xDomain || d3v3.extent(data[0].values.map(getX).concat(forceX)));\n      if (padData) x.range(xRange || [availableWidth * .5 / data[0].values.length, availableWidth * (data[0].values.length - .5) / data[0].values.length]);else x.range(xRange || [0, availableWidth]);\n      y.domain(yDomain || [d3v3.min(data[0].values.map(getLow).concat(forceY)), d3v3.max(data[0].values.map(getHigh).concat(forceY))]).range(yRange || [availableHeight, 0]);\n\n      // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point\n      if (x.domain()[0] === x.domain()[1]) x.domain()[0] ? x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01]) : x.domain([-1, 1]);\n      if (y.domain()[0] === y.domain()[1]) y.domain()[0] ? y.domain([y.domain()[0] + y.domain()[0] * 0.01, y.domain()[1] - y.domain()[1] * 0.01]) : y.domain([-1, 1]);\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = d3v3.select(this).selectAll('g.nv-wrap.nv-ohlcBar').data([data[0].values]);\n      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-ohlcBar');\n      var defsEnter = wrapEnter.append('defs');\n      var gEnter = wrapEnter.append('g');\n      var g = wrap.select('g');\n      gEnter.append('g').attr('class', 'nv-ticks');\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n      //------------------------------------------------------------\n\n      container.on('click', function (d, i) {\n        dispatch.chartClick({\n          data: d,\n          index: i,\n          pos: d3v3.event,\n          id: id\n        });\n      });\n      defsEnter.append('clipPath').attr('id', 'nv-chart-clip-path-' + id).append('rect');\n      wrap.select('#nv-chart-clip-path-' + id + ' rect').attr('width', availableWidth).attr('height', availableHeight);\n      g.attr('clip-path', clipEdge ? 'url(#nv-chart-clip-path-' + id + ')' : '');\n      var ticks = wrap.select('.nv-ticks').selectAll('.nv-tick').data(function (d) {\n        return d;\n      });\n      ticks.exit().remove();\n      var ticksEnter = ticks.enter().append('path').attr('class', function (d, i, j) {\n        return (getOpen(d, i) > getClose(d, i) ? 'nv-tick negative' : 'nv-tick positive') + ' nv-tick-' + j + '-' + i;\n      }).attr('d', function (d, i) {\n        var w = availableWidth / data[0].values.length * .9;\n        return 'm0,0l0,' + (y(getOpen(d, i)) - y(getHigh(d, i))) + 'l' + -w / 2 + ',0l' + w / 2 + ',0l0,' + (y(getLow(d, i)) - y(getOpen(d, i))) + 'l0,' + (y(getClose(d, i)) - y(getLow(d, i))) + 'l' + w / 2 + ',0l' + -w / 2 + ',0z';\n      }).attr('transform', function (d, i) {\n        return 'translate(' + x(getX(d, i)) + ',' + y(getHigh(d, i)) + ')';\n      })\n      //.attr('fill', function(d,i) { return color[0]; })\n      //.attr('stroke', function(d,i) { return color[0]; })\n      //.attr('x', 0 )\n      //.attr('y', function(d,i) {  return y(Math.max(0, getY(d,i))) })\n      //.attr('height', function(d,i) { return Math.abs(y(getY(d,i)) - y(0)) })\n      .on('mouseover', function (d, i) {\n        d3v3.select(this).classed('hover', true);\n        dispatch.elementMouseover({\n          point: d,\n          series: data[0],\n          pos: [x(getX(d, i)), y(getY(d, i))],\n          // TODO: Figure out why the value appears to be shifted\n          pointIndex: i,\n          seriesIndex: 0,\n          e: d3v3.event\n        });\n      }).on('mouseout', function (d, i) {\n        d3v3.select(this).classed('hover', false);\n        dispatch.elementMouseout({\n          point: d,\n          series: data[0],\n          pointIndex: i,\n          seriesIndex: 0,\n          e: d3v3.event\n        });\n      }).on('click', function (d, i) {\n        dispatch.elementClick({\n          //label: d[label],\n          value: getY(d, i),\n          data: d,\n          index: i,\n          pos: [x(getX(d, i)), y(getY(d, i))],\n          e: d3v3.event,\n          id: id\n        });\n        d3v3.event.stopPropagation();\n      }).on('dblclick', function (d, i) {\n        dispatch.elementDblClick({\n          //label: d[label],\n          value: getY(d, i),\n          data: d,\n          index: i,\n          pos: [x(getX(d, i)), y(getY(d, i))],\n          e: d3v3.event,\n          id: id\n        });\n        d3v3.event.stopPropagation();\n      });\n      ticks.attr('class', function (d, i, j) {\n        return (getOpen(d, i) > getClose(d, i) ? 'nv-tick negative' : 'nv-tick positive') + ' nv-tick-' + j + '-' + i;\n      });\n      d3v3.transition(ticks).attr('transform', function (d, i) {\n        return 'translate(' + x(getX(d, i)) + ',' + y(getHigh(d, i)) + ')';\n      }).attr('d', function (d, i) {\n        var w = availableWidth / data[0].values.length * .9;\n        return 'm0,0l0,' + (y(getOpen(d, i)) - y(getHigh(d, i))) + 'l' + -w / 2 + ',0l' + w / 2 + ',0l0,' + (y(getLow(d, i)) - y(getOpen(d, i))) + 'l0,' + (y(getClose(d, i)) - y(getLow(d, i))) + 'l' + w / 2 + ',0l' + -w / 2 + ',0z';\n      });\n      //.attr('width', (availableWidth / data[0].values.length) * .9 )\n\n      //d3v3.transition(ticks)\n      //.attr('y', function(d,i) {  return y(Math.max(0, getY(d,i))) })\n      //.attr('height', function(d,i) { return Math.abs(y(getY(d,i)) - y(0)) });\n      //.order();  // not sure if this makes any sense for this model\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  chart.dispatch = dispatch;\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.x = function (_) {\n    if (!arguments.length) return getX;\n    getX = _;\n    return chart;\n  };\n  chart.y = function (_) {\n    if (!arguments.length) return getY;\n    getY = _;\n    return chart;\n  };\n  chart.open = function (_) {\n    if (!arguments.length) return getOpen;\n    getOpen = _;\n    return chart;\n  };\n  chart.close = function (_) {\n    if (!arguments.length) return getClose;\n    getClose = _;\n    return chart;\n  };\n  chart.high = function (_) {\n    if (!arguments.length) return getHigh;\n    getHigh = _;\n    return chart;\n  };\n  chart.low = function (_) {\n    if (!arguments.length) return getLow;\n    getLow = _;\n    return chart;\n  };\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.xScale = function (_) {\n    if (!arguments.length) return x;\n    x = _;\n    return chart;\n  };\n  chart.yScale = function (_) {\n    if (!arguments.length) return y;\n    y = _;\n    return chart;\n  };\n  chart.xDomain = function (_) {\n    if (!arguments.length) return xDomain;\n    xDomain = _;\n    return chart;\n  };\n  chart.yDomain = function (_) {\n    if (!arguments.length) return yDomain;\n    yDomain = _;\n    return chart;\n  };\n  chart.xRange = function (_) {\n    if (!arguments.length) return xRange;\n    xRange = _;\n    return chart;\n  };\n  chart.yRange = function (_) {\n    if (!arguments.length) return yRange;\n    yRange = _;\n    return chart;\n  };\n  chart.forceX = function (_) {\n    if (!arguments.length) return forceX;\n    forceX = _;\n    return chart;\n  };\n  chart.forceY = function (_) {\n    if (!arguments.length) return forceY;\n    forceY = _;\n    return chart;\n  };\n  chart.padData = function (_) {\n    if (!arguments.length) return padData;\n    padData = _;\n    return chart;\n  };\n  chart.clipEdge = function (_) {\n    if (!arguments.length) return clipEdge;\n    clipEdge = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    return chart;\n  };\n  chart.id = function (_) {\n    if (!arguments.length) return id;\n    id = _;\n    return chart;\n  };\n\n  //============================================================\n\n  return chart;\n};\nnv.models.pie = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var margin = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    },\n    width = 500,\n    height = 500,\n    getX = function getX(d) {\n      return d.x;\n    },\n    getY = function getY(d) {\n      return d.y;\n    },\n    getDescription = function getDescription(d) {\n      return d.description;\n    },\n    id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one\n    ,\n    color = nv.utils.defaultColor(),\n    valueFormat = d3v3.format(',.2f'),\n    showLabels = true,\n    pieLabelsOutside = true,\n    donutLabelsOutside = false,\n    labelType = \"key\",\n    labelThreshold = .02 //if slice percentage is under this, don't show label\n    ,\n    donut = false,\n    labelSunbeamLayout = false,\n    startAngle = false,\n    endAngle = false,\n    donutRatio = 0.5,\n    dispatch = d3v3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout');\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var availableWidth = width - margin.left - margin.right,\n        availableHeight = height - margin.top - margin.bottom,\n        radius = Math.min(availableWidth, availableHeight) / 2,\n        arcRadius = radius - radius / 5,\n        container = d3v3.select(this);\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      //var wrap = container.selectAll('.nv-wrap.nv-pie').data([data]);\n      var wrap = container.selectAll('.nv-wrap.nv-pie').data(data);\n      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-pie nv-chart-' + id);\n      var gEnter = wrapEnter.append('g');\n      var g = wrap.select('g');\n      gEnter.append('g').attr('class', 'nv-pie');\n      gEnter.append('g').attr('class', 'nv-pieLabels');\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n      g.select('.nv-pie').attr('transform', 'translate(' + availableWidth / 2 + ',' + availableHeight / 2 + ')');\n      g.select('.nv-pieLabels').attr('transform', 'translate(' + availableWidth / 2 + ',' + availableHeight / 2 + ')');\n\n      //------------------------------------------------------------\n\n      container.on('click', function (d, i) {\n        dispatch.chartClick({\n          data: d,\n          index: i,\n          pos: d3v3.event,\n          id: id\n        });\n      });\n      var arc = d3v3.svg.arc().outerRadius(arcRadius);\n      if (startAngle) arc.startAngle(startAngle);\n      if (endAngle) arc.endAngle(endAngle);\n      if (donut) arc.innerRadius(radius * donutRatio);\n\n      // Setup the Pie chart and choose the data element\n      var pie = d3v3.layout.pie().sort(null).value(function (d) {\n        return d.disabled ? 0 : getY(d);\n      });\n      var slices = wrap.select('.nv-pie').selectAll('.nv-slice').data(pie);\n      var pieLabels = wrap.select('.nv-pieLabels').selectAll('.nv-label').data(pie);\n      slices.exit().remove();\n      pieLabels.exit().remove();\n      var ae = slices.enter().append('g').attr('class', 'nv-slice').on('mouseover', function (d, i) {\n        d3v3.select(this).classed('hover', true);\n        dispatch.elementMouseover({\n          label: getX(d.data),\n          value: getY(d.data),\n          point: d.data,\n          pointIndex: i,\n          pos: [d3v3.event.pageX, d3v3.event.pageY],\n          id: id\n        });\n      }).on('mouseout', function (d, i) {\n        d3v3.select(this).classed('hover', false);\n        dispatch.elementMouseout({\n          label: getX(d.data),\n          value: getY(d.data),\n          point: d.data,\n          index: i,\n          id: id\n        });\n      }).on('click', function (d, i) {\n        dispatch.elementClick({\n          label: getX(d.data),\n          value: getY(d.data),\n          point: d.data,\n          index: i,\n          pos: d3v3.event,\n          id: id\n        });\n        d3v3.event.stopPropagation();\n      }).on('dblclick', function (d, i) {\n        dispatch.elementDblClick({\n          label: getX(d.data),\n          value: getY(d.data),\n          point: d.data,\n          index: i,\n          pos: d3v3.event,\n          id: id\n        });\n        d3v3.event.stopPropagation();\n      });\n      slices.attr('fill', function (d, i) {\n        return color(d, i);\n      }).attr('stroke', function (d, i) {\n        return color(d, i);\n      });\n      var paths = ae.append('path').each(function (d) {\n        this._current = d;\n      });\n      //.attr('d', arc);\n\n      slices.select('path').transition().attr('d', arc).attrTween('d', arcTween);\n      if (showLabels) {\n        // This does the normal label\n        var labelsArc = d3v3.svg.arc().innerRadius(0);\n        if (pieLabelsOutside) {\n          labelsArc = arc;\n        }\n        if (donutLabelsOutside) {\n          labelsArc = d3v3.svg.arc().outerRadius(arc.outerRadius());\n        }\n        pieLabels.enter().append(\"g\").classed(\"nv-label\", true).each(function (d, i) {\n          var group = d3v3.select(this);\n          group.attr('transform', function (d) {\n            if (labelSunbeamLayout) {\n              d.outerRadius = arcRadius + 10; // Set Outer Coordinate\n              d.innerRadius = arcRadius + 15; // Set Inner Coordinate\n              var rotateAngle = (d.startAngle + d.endAngle) / 2 * (180 / Math.PI);\n              if ((d.startAngle + d.endAngle) / 2 < Math.PI) {\n                rotateAngle -= 90;\n              } else {\n                rotateAngle += 90;\n              }\n              return 'translate(' + labelsArc.centroid(d) + ') rotate(' + rotateAngle + ')';\n            } else {\n              d.outerRadius = radius + 10; // Set Outer Coordinate\n              d.innerRadius = radius + 15; // Set Inner Coordinate\n              return 'translate(' + labelsArc.centroid(d) + ')';\n            }\n          });\n          group.append('rect').style('stroke', '#fff').style('fill', '#fff').attr(\"rx\", 3).attr(\"ry\", 3);\n          group.append('text').style('text-anchor', labelSunbeamLayout ? (d.startAngle + d.endAngle) / 2 < Math.PI ? 'start' : 'end' : 'middle') //center the text on it's origin or begin/end if orthogonal aligned\n          .style('fill', '#000');\n        });\n        var labelLocationHash = {};\n        var avgHeight = 14;\n        var avgWidth = 140;\n        var createHashKey = function createHashKey(coordinates) {\n          return Math.floor(coordinates[0] / avgWidth) * avgWidth + ',' + Math.floor(coordinates[1] / avgHeight) * avgHeight;\n        };\n        pieLabels.transition().attr('transform', function (d) {\n          if (labelSunbeamLayout) {\n            d.outerRadius = arcRadius + 10; // Set Outer Coordinate\n            d.innerRadius = arcRadius + 15; // Set Inner Coordinate\n            var rotateAngle = (d.startAngle + d.endAngle) / 2 * (180 / Math.PI);\n            if ((d.startAngle + d.endAngle) / 2 < Math.PI) {\n              rotateAngle -= 90;\n            } else {\n              rotateAngle += 90;\n            }\n            return 'translate(' + labelsArc.centroid(d) + ') rotate(' + rotateAngle + ')';\n          } else {\n            d.outerRadius = radius + 10; // Set Outer Coordinate\n            d.innerRadius = radius + 15; // Set Inner Coordinate\n\n            /*\n            Overlapping pie labels are not good. What this attempts to do is, prevent overlapping.\n            Each label location is hashed, and if a hash collision occurs, we assume an overlap.\n            Adjust the label's y-position to remove the overlap.\n            */\n            var center = labelsArc.centroid(d);\n            var hashKey = createHashKey(center);\n            if (labelLocationHash[hashKey]) {\n              center[1] -= avgHeight;\n            }\n            labelLocationHash[createHashKey(center)] = true;\n            return 'translate(' + center + ')';\n          }\n        });\n        pieLabels.select(\".nv-label text\").style('text-anchor', labelSunbeamLayout ? (d.startAngle + d.endAngle) / 2 < Math.PI ? 'start' : 'end' : 'middle') //center the text on it's origin or begin/end if orthogonal aligned\n        .text(function (d, i) {\n          var percent = (d.endAngle - d.startAngle) / (2 * Math.PI);\n          var labelTypes = {\n            \"key\": getX(d.data),\n            \"value\": getY(d.data),\n            \"percent\": d3v3.format('%')(percent)\n          };\n          return d.value && percent > labelThreshold ? labelTypes[labelType] : '';\n        });\n      }\n\n      // Computes the angle of an arc, converting from radians to degrees.\n      function angle(d) {\n        var a = (d.startAngle + d.endAngle) * 90 / Math.PI - 90;\n        return a > 90 ? a - 180 : a;\n      }\n      function arcTween(a) {\n        a.endAngle = isNaN(a.endAngle) ? 0 : a.endAngle;\n        a.startAngle = isNaN(a.startAngle) ? 0 : a.startAngle;\n        if (!donut) a.innerRadius = 0;\n        var i = d3v3.interpolate(this._current, a);\n        this._current = i(0);\n        return function (t) {\n          return arc(i(t));\n        };\n      }\n      function tweenPie(b) {\n        b.innerRadius = 0;\n        var i = d3v3.interpolate({\n          startAngle: 0,\n          endAngle: 0\n        }, b);\n        return function (t) {\n          return arc(i(t));\n        };\n      }\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  chart.dispatch = dispatch;\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.values = function (_) {\n    nv.log(\"pie.values() is no longer supported.\");\n    return chart;\n  };\n  chart.x = function (_) {\n    if (!arguments.length) return getX;\n    getX = _;\n    return chart;\n  };\n  chart.y = function (_) {\n    if (!arguments.length) return getY;\n    getY = d3v3.functor(_);\n    return chart;\n  };\n  chart.description = function (_) {\n    if (!arguments.length) return getDescription;\n    getDescription = _;\n    return chart;\n  };\n  chart.showLabels = function (_) {\n    if (!arguments.length) return showLabels;\n    showLabels = _;\n    return chart;\n  };\n  chart.labelSunbeamLayout = function (_) {\n    if (!arguments.length) return labelSunbeamLayout;\n    labelSunbeamLayout = _;\n    return chart;\n  };\n  chart.donutLabelsOutside = function (_) {\n    if (!arguments.length) return donutLabelsOutside;\n    donutLabelsOutside = _;\n    return chart;\n  };\n  chart.pieLabelsOutside = function (_) {\n    if (!arguments.length) return pieLabelsOutside;\n    pieLabelsOutside = _;\n    return chart;\n  };\n  chart.labelType = function (_) {\n    if (!arguments.length) return labelType;\n    labelType = _;\n    labelType = labelType || \"key\";\n    return chart;\n  };\n  chart.donut = function (_) {\n    if (!arguments.length) return donut;\n    donut = _;\n    return chart;\n  };\n  chart.donutRatio = function (_) {\n    if (!arguments.length) return donutRatio;\n    donutRatio = _;\n    return chart;\n  };\n  chart.startAngle = function (_) {\n    if (!arguments.length) return startAngle;\n    startAngle = _;\n    return chart;\n  };\n  chart.endAngle = function (_) {\n    if (!arguments.length) return endAngle;\n    endAngle = _;\n    return chart;\n  };\n  chart.id = function (_) {\n    if (!arguments.length) return id;\n    id = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    return chart;\n  };\n  chart.valueFormat = function (_) {\n    if (!arguments.length) return valueFormat;\n    valueFormat = _;\n    return chart;\n  };\n  chart.labelThreshold = function (_) {\n    if (!arguments.length) return labelThreshold;\n    labelThreshold = _;\n    return chart;\n  };\n  //============================================================\n\n  return chart;\n};\nnv.models.pieChart = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var pie = nv.models.pie(),\n    legend = nv.models.legend();\n  var margin = {\n      top: 30,\n      right: 20,\n      bottom: 20,\n      left: 20\n    },\n    width = null,\n    height = null,\n    showLegend = true,\n    color = nv.utils.defaultColor(),\n    tooltips = true,\n    tooltip = function tooltip(key, y, e, graph) {\n      return '<h3>' + key + '</h3>' + '<p>' + y + '</p>';\n    },\n    state = {},\n    defaultState = null,\n    noData = \"No Data Available.\",\n    dispatch = d3v3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState');\n\n  //============================================================\n\n  //============================================================\n  // Private Variables\n  //------------------------------------------------------------\n\n  var showTooltip = function showTooltip(e, offsetElement) {\n    var tooltipLabel = pie.description()(e.point) || pie.x()(e.point);\n    var left = e.pos[0] + (offsetElement && offsetElement.offsetLeft || 0),\n      top = e.pos[1] + (offsetElement && offsetElement.offsetTop || 0),\n      y = pie.valueFormat()(pie.y()(e.point)),\n      content = tooltip(tooltipLabel, y, e, chart);\n    nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);\n  };\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var container = d3v3.select(this),\n        that = this;\n      var availableWidth = (width || parseInt(container.style('width')) || 960) - margin.left - margin.right,\n        availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n      chart.update = function () {\n        container.transition().call(chart);\n      };\n      chart.container = this;\n\n      //set state.disabled\n      state.disabled = data.map(function (d) {\n        return !!d.disabled;\n      });\n      if (!defaultState) {\n        var key;\n        defaultState = {};\n        for (key in state) {\n          if (state[key] instanceof Array) defaultState[key] = state[key].slice(0);else defaultState[key] = state[key];\n        }\n      }\n\n      //------------------------------------------------------------\n      // Display No Data message if there's nothing to show.\n\n      if (!data || !data.length) {\n        var noDataText = container.selectAll('.nv-noData').data([noData]);\n        noDataText.enter().append('text').attr('class', 'nvd3 nv-noData').attr('dy', '-.7em').style('text-anchor', 'middle');\n        noDataText.attr('x', margin.left + availableWidth / 2).attr('y', margin.top + availableHeight / 2).text(function (d) {\n          return d;\n        });\n        return chart;\n      } else {\n        container.selectAll('.nv-noData').remove();\n      }\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = container.selectAll('g.nv-wrap.nv-pieChart').data([data]);\n      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-pieChart').append('g');\n      var g = wrap.select('g');\n      gEnter.append('g').attr('class', 'nv-pieWrap');\n      gEnter.append('g').attr('class', 'nv-legendWrap');\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Legend\n\n      if (showLegend) {\n        legend.width(availableWidth).key(pie.x());\n        wrap.select('.nv-legendWrap').datum(data).call(legend);\n        if (margin.top != legend.height()) {\n          margin.top = legend.height();\n          availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n        }\n        wrap.select('.nv-legendWrap').attr('transform', 'translate(0,' + -margin.top + ')');\n      }\n\n      //------------------------------------------------------------\n\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n      //------------------------------------------------------------\n      // Main Chart Component(s)\n\n      pie.width(availableWidth).height(availableHeight);\n      var pieWrap = g.select('.nv-pieWrap').datum([data]);\n      d3v3.transition(pieWrap).call(pie);\n\n      //------------------------------------------------------------\n\n      //============================================================\n      // Event Handling/Dispatching (in chart's scope)\n      //------------------------------------------------------------\n\n      legend.dispatch.on('stateChange', function (newState) {\n        state = newState;\n        dispatch.stateChange(state);\n        chart.update();\n      });\n      pie.dispatch.on('elementMouseout.tooltip', function (e) {\n        dispatch.tooltipHide(e);\n      });\n\n      // Update chart from a state object passed to event handler\n      dispatch.on('changeState', function (e) {\n        if (typeof e.disabled !== 'undefined') {\n          data.forEach(function (series, i) {\n            series.disabled = e.disabled[i];\n          });\n          state.disabled = e.disabled;\n        }\n        chart.update();\n      });\n\n      //============================================================\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Event Handling/Dispatching (out of chart's scope)\n  //------------------------------------------------------------\n\n  pie.dispatch.on('elementMouseover.tooltip', function (e) {\n    e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];\n    dispatch.tooltipShow(e);\n  });\n  dispatch.on('tooltipShow', function (e) {\n    if (tooltips) showTooltip(e);\n  });\n  dispatch.on('tooltipHide', function () {\n    if (tooltips) nv.tooltip.cleanup();\n  });\n\n  //============================================================\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  // expose chart's sub-components\n  chart.legend = legend;\n  chart.dispatch = dispatch;\n  chart.pie = pie;\n  d3v3.rebind(chart, pie, 'valueFormat', 'values', 'x', 'y', 'description', 'id', 'showLabels', 'donutLabelsOutside', 'pieLabelsOutside', 'labelType', 'donut', 'donutRatio', 'labelThreshold');\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    legend.color(color);\n    pie.color(color);\n    return chart;\n  };\n  chart.showLegend = function (_) {\n    if (!arguments.length) return showLegend;\n    showLegend = _;\n    return chart;\n  };\n  chart.tooltips = function (_) {\n    if (!arguments.length) return tooltips;\n    tooltips = _;\n    return chart;\n  };\n  chart.tooltipContent = function (_) {\n    if (!arguments.length) return tooltip;\n    tooltip = _;\n    return chart;\n  };\n  chart.state = function (_) {\n    if (!arguments.length) return state;\n    state = _;\n    return chart;\n  };\n  chart.defaultState = function (_) {\n    if (!arguments.length) return defaultState;\n    defaultState = _;\n    return chart;\n  };\n  chart.noData = function (_) {\n    if (!arguments.length) return noData;\n    noData = _;\n    return chart;\n  };\n\n  //============================================================\n\n  return chart;\n};\nnv.models.scatter = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var margin = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    },\n    width = 960,\n    height = 500,\n    color = nv.utils.defaultColor() // chooses color\n    ,\n    id = Math.floor(Math.random() * 100000) //Create semi-unique ID incase user doesn't select one\n    ,\n    x = d3v3.scale.linear(),\n    y = d3v3.scale.linear(),\n    z = d3v3.scale.linear() //linear because d3v3.svg.shape.size is treated as area\n    ,\n    getX = function getX(d) {\n      return d.x;\n    } // accessor to get the x value\n    ,\n    getY = function getY(d) {\n      return d.y;\n    } // accessor to get the y value\n    ,\n    getSize = function getSize(d) {\n      return d.size || 1;\n    } // accessor to get the point size\n    ,\n    getShape = function getShape(d) {\n      return d.shape || 'circle';\n    } // accessor to get point shape\n    ,\n    onlyCircles = true // Set to false to use shapes\n    ,\n    forceX = [] // List of numbers to Force into the X scale (ie. 0, or a max / min, etc.)\n    ,\n    forceY = [] // List of numbers to Force into the Y scale\n    ,\n    forceSize = [] // List of numbers to Force into the Size scale\n    ,\n    interactive = true // If true, plots a voronoi overlay for advanced point intersection\n    ,\n    pointKey = null,\n    pointActive = function pointActive(d) {\n      return !d.notActive;\n    } // any points that return false will be filtered out\n    ,\n    padData = false // If true, adds half a data points width to front and back, for lining up a line chart with a bar chart\n    ,\n    padDataOuter = .1 //outerPadding to imitate ordinal scale outer padding\n    ,\n    clipEdge = false // if true, masks points within x and y scale\n    ,\n    clipVoronoi = true // if true, masks each point with a circle... can turn off to slightly increase performance\n    ,\n    clipRadius = function clipRadius() {\n      return 25;\n    } // function to get the radius for voronoi point clips\n    ,\n    xDomain = null // Override x domain (skips the calculation from data)\n    ,\n    yDomain = null // Override y domain\n    ,\n    xRange = null // Override x range\n    ,\n    yRange = null // Override y range\n    ,\n    sizeDomain = null // Override point size domain\n    ,\n    sizeRange = null,\n    singlePoint = false,\n    dispatch = d3v3.dispatch('elementClick', 'elementMouseover', 'elementMouseout'),\n    useVoronoi = true;\n\n  //============================================================\n\n  //============================================================\n  // Private Variables\n  //------------------------------------------------------------\n\n  var x0,\n    y0,\n    z0 // used to store previous scales\n    ,\n    timeoutID,\n    needsUpdate = false // Flag for when the points are visually updating, but the interactive layer is behind, to disable tooltips\n  ;\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var availableWidth = width - margin.left - margin.right,\n        availableHeight = height - margin.top - margin.bottom,\n        container = d3v3.select(this);\n\n      //add series index to each data point for reference\n      data.forEach(function (series, i) {\n        series.values.forEach(function (point) {\n          point.series = i;\n        });\n      });\n\n      //------------------------------------------------------------\n      // Setup Scales\n\n      // remap and flatten the data for use in calculating the scales' domains\n      var seriesData = xDomain && yDomain && sizeDomain ? [] :\n      // if we know xDomain and yDomain and sizeDomain, no need to calculate.... if Size is constant remember to set sizeDomain to speed up performance\n      d3v3.merge(data.map(function (d) {\n        return d.values.map(function (d, i) {\n          return {\n            x: getX(d, i),\n            y: getY(d, i),\n            size: getSize(d, i)\n          };\n        });\n      }));\n      x.domain(xDomain || d3v3.extent(seriesData.map(function (d) {\n        return d.x;\n      }).concat(forceX)));\n      if (padData && data[0]) x.range(xRange || [(availableWidth * padDataOuter + availableWidth) / (2 * data[0].values.length), availableWidth - availableWidth * (1 + padDataOuter) / (2 * data[0].values.length)]);\n      //x.range([availableWidth * .5 / data[0].values.length, availableWidth * (data[0].values.length - .5)  / data[0].values.length ]);\n      else x.range(xRange || [0, availableWidth]);\n      y.domain(yDomain || d3v3.extent(seriesData.map(function (d) {\n        return d.y;\n      }).concat(forceY))).range(yRange || [availableHeight, 0]);\n      z.domain(sizeDomain || d3v3.extent(seriesData.map(function (d) {\n        return d.size;\n      }).concat(forceSize))).range(sizeRange || [16, 256]);\n\n      // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point\n      if (x.domain()[0] === x.domain()[1] || y.domain()[0] === y.domain()[1]) singlePoint = true;\n      if (x.domain()[0] === x.domain()[1]) x.domain()[0] ? x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01]) : x.domain([-1, 1]);\n      if (y.domain()[0] === y.domain()[1]) y.domain()[0] ? y.domain([y.domain()[0] - y.domain()[0] * 0.01, y.domain()[1] + y.domain()[1] * 0.01]) : y.domain([-1, 1]);\n      if (isNaN(x.domain()[0])) {\n        x.domain([-1, 1]);\n      }\n      if (isNaN(y.domain()[0])) {\n        y.domain([-1, 1]);\n      }\n      x0 = x0 || x;\n      y0 = y0 || y;\n      z0 = z0 || z;\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = container.selectAll('g.nv-wrap.nv-scatter').data([data]);\n      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-scatter nv-chart-' + id + (singlePoint ? ' nv-single-point' : ''));\n      var defsEnter = wrapEnter.append('defs');\n      var gEnter = wrapEnter.append('g');\n      var g = wrap.select('g');\n      gEnter.append('g').attr('class', 'nv-groups');\n      gEnter.append('g').attr('class', 'nv-point-paths');\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n      //------------------------------------------------------------\n\n      defsEnter.append('clipPath').attr('id', 'nv-edge-clip-' + id).append('rect');\n      wrap.select('#nv-edge-clip-' + id + ' rect').attr('width', availableWidth).attr('height', availableHeight > 0 ? availableHeight : 0);\n      g.attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + id + ')' : '');\n      function updateInteractiveLayer() {\n        if (!interactive) return false;\n        var eventElements;\n        var vertices = d3v3.merge(data.map(function (group, groupIndex) {\n          return group.values.map(function (point, pointIndex) {\n            // *Adding noise to make duplicates very unlikely\n            // *Injecting series and point index for reference\n            /* *Adding a 'jitter' to the points, because there's an issue in d3v3.geom.voronoi.\n            */\n            var pX = getX(point, pointIndex);\n            var pY = getY(point, pointIndex);\n            return [x(pX) + Math.random() * 1e-7, y(pY) + Math.random() * 1e-7, groupIndex, pointIndex, point]; //temp hack to add noise untill I think of a better way so there are no duplicates\n          }).filter(function (pointArray, pointIndex) {\n            return pointActive(pointArray[4], pointIndex); // Issue #237.. move filter to after map, so pointIndex is correct!\n          });\n        }));\n\n        //inject series and point index for reference into voronoi\n        if (useVoronoi === true) {\n          if (clipVoronoi) {\n            var pointClipsEnter = wrap.select('defs').selectAll('.nv-point-clips').data([id]).enter();\n            pointClipsEnter.append('clipPath').attr('class', 'nv-point-clips').attr('id', 'nv-points-clip-' + id);\n            var pointClips = wrap.select('#nv-points-clip-' + id).selectAll('circle').data(vertices);\n            pointClips.enter().append('circle').attr('r', clipRadius);\n            pointClips.exit().remove();\n            pointClips.attr('cx', function (d) {\n              return d[0];\n            }).attr('cy', function (d) {\n              return d[1];\n            });\n            wrap.select('.nv-point-paths').attr('clip-path', 'url(#nv-points-clip-' + id + ')');\n          }\n          if (vertices.length) {\n            // Issue #283 - Adding 2 dummy points to the voronoi b/c voronoi requires min 3 points to work\n            vertices.push([x.range()[0] - 20, y.range()[0] - 20, null, null]);\n            vertices.push([x.range()[1] + 20, y.range()[1] + 20, null, null]);\n            vertices.push([x.range()[0] - 20, y.range()[0] + 20, null, null]);\n            vertices.push([x.range()[1] + 20, y.range()[1] - 20, null, null]);\n          }\n          var bounds = d3v3.geom.polygon([[-10, -10], [-10, height + 10], [width + 10, height + 10], [width + 10, -10]]);\n          var voronoi = d3v3.geom.voronoi(vertices).map(function (d, i) {\n            return {\n              'data': bounds.clip(d),\n              'series': vertices[i][2],\n              'point': vertices[i][3]\n            };\n          });\n          var pointPaths = wrap.select('.nv-point-paths').selectAll('path').data(voronoi);\n          pointPaths.enter().append('path').attr('class', function (d, i) {\n            return 'nv-path-' + i;\n          });\n          pointPaths.exit().remove();\n          pointPaths.attr('d', function (d) {\n            if (!d || !d.data || d.data.length === 0) return 'M 0 0';else return 'M' + d.data.join('L') + 'Z';\n          });\n          var mouseEventCallback = function mouseEventCallback(d, mDispatch) {\n            if (needsUpdate) return 0;\n            var series = data[d.series];\n            if (typeof series === 'undefined') return;\n            var point = series.values[d.point];\n            mDispatch({\n              point: point,\n              series: series,\n              pos: [x(getX(point, d.point)) + margin.left, y(getY(point, d.point)) + margin.top],\n              seriesIndex: d.series,\n              pointIndex: d.point\n            });\n          };\n          pointPaths.on('click', function (d) {\n            mouseEventCallback(d, dispatch.elementClick);\n          }).on('mouseover', function (d) {\n            mouseEventCallback(d, dispatch.elementMouseover);\n          }).on('mouseout', function (d, i) {\n            mouseEventCallback(d, dispatch.elementMouseout);\n          });\n        } else {\n          /*\n          // bring data in form needed for click handlers\n          var dataWithPoints = vertices.map(function(d, i) {\n              return {\n                'data': d,\n                'series': vertices[i][2],\n                'point': vertices[i][3]\n              }\n            });\n           */\n\n          // add event handlers to points instead voronoi paths\n          wrap.select('.nv-groups').selectAll('.nv-group').selectAll('.nv-point')\n          //.data(dataWithPoints)\n          //.style('pointer-events', 'auto') // recativate events, disabled by css\n          .on('click', function (d, i) {\n            //nv.log('test', d, i);\n            if (needsUpdate || !data[d.series]) return 0; //check if this is a dummy point\n            var series = data[d.series],\n              point = series.values[i];\n            dispatch.elementClick({\n              point: point,\n              series: series,\n              pos: [x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top],\n              seriesIndex: d.series,\n              pointIndex: i\n            });\n          }).on('mouseover', function (d, i) {\n            if (needsUpdate || !data[d.series]) return 0; //check if this is a dummy point\n            var series = data[d.series],\n              point = series.values[i];\n            dispatch.elementMouseover({\n              point: point,\n              series: series,\n              pos: [x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top],\n              seriesIndex: d.series,\n              pointIndex: i\n            });\n          }).on('mouseout', function (d, i) {\n            if (needsUpdate || !data[d.series]) return 0; //check if this is a dummy point\n            var series = data[d.series],\n              point = series.values[i];\n            dispatch.elementMouseout({\n              point: point,\n              series: series,\n              seriesIndex: d.series,\n              pointIndex: i\n            });\n          });\n        }\n        needsUpdate = false;\n      }\n      needsUpdate = true;\n      var groups = wrap.select('.nv-groups').selectAll('.nv-group').data(function (d) {\n        return d;\n      }, function (d) {\n        return d.key;\n      });\n      groups.enter().append('g').style('stroke-opacity', 1e-6).style('fill-opacity', 1e-6);\n      groups.exit().remove();\n      groups.attr('class', function (d, i) {\n        return 'nv-group nv-series-' + i;\n      }).classed('hover', function (d) {\n        return d.hover;\n      });\n      groups.transition().style('fill', function (d, i) {\n        return color(d, i);\n      }).style('stroke', function (d, i) {\n        return color(d, i);\n      }).style('stroke-opacity', 1).style('fill-opacity', .5);\n      if (onlyCircles) {\n        var points = groups.selectAll('circle.nv-point').data(function (d) {\n          return d.values;\n        }, pointKey);\n        points.enter().append('circle').style('fill', function (d, i) {\n          return d.color;\n        }).style('stroke', function (d, i) {\n          return d.color;\n        }).attr('cx', function (d, i) {\n          return nv.utils.NaNtoZero(x0(getX(d, i)));\n        }).attr('cy', function (d, i) {\n          return nv.utils.NaNtoZero(y0(getY(d, i)));\n        }).attr('r', function (d, i) {\n          return Math.sqrt(z(getSize(d, i)) / Math.PI);\n        });\n        points.exit().remove();\n        groups.exit().selectAll('path.nv-point').transition().attr('cx', function (d, i) {\n          return nv.utils.NaNtoZero(x(getX(d, i)));\n        }).attr('cy', function (d, i) {\n          return nv.utils.NaNtoZero(y(getY(d, i)));\n        }).remove();\n        points.each(function (d, i) {\n          d3v3.select(this).classed('nv-point', true).classed('nv-point-' + i, true).classed('hover', false);\n        });\n        points.transition().attr('cx', function (d, i) {\n          return nv.utils.NaNtoZero(x(getX(d, i)));\n        }).attr('cy', function (d, i) {\n          return nv.utils.NaNtoZero(y(getY(d, i)));\n        }).attr('r', function (d, i) {\n          return Math.sqrt(z(getSize(d, i)) / Math.PI);\n        });\n      } else {\n        var points = groups.selectAll('path.nv-point').data(function (d) {\n          return d.values;\n        });\n        points.enter().append('path').style('fill', function (d, i) {\n          return d.color;\n        }).style('stroke', function (d, i) {\n          return d.color;\n        }).attr('transform', function (d, i) {\n          return 'translate(' + x0(getX(d, i)) + ',' + y0(getY(d, i)) + ')';\n        }).attr('d', d3v3.svg.symbol().type(getShape).size(function (d, i) {\n          return z(getSize(d, i));\n        }));\n        points.exit().remove();\n        groups.exit().selectAll('path.nv-point').transition().attr('transform', function (d, i) {\n          return 'translate(' + x(getX(d, i)) + ',' + y(getY(d, i)) + ')';\n        }).remove();\n        points.each(function (d, i) {\n          d3v3.select(this).classed('nv-point', true).classed('nv-point-' + i, true).classed('hover', false);\n        });\n        points.transition().attr('transform', function (d, i) {\n          //nv.log(d,i,getX(d,i), x(getX(d,i)));\n          return 'translate(' + x(getX(d, i)) + ',' + y(getY(d, i)) + ')';\n        }).attr('d', d3v3.svg.symbol().type(getShape).size(function (d, i) {\n          return z(getSize(d, i));\n        }));\n      }\n\n      // Delay updating the invisible interactive layer for smoother animation\n      clearTimeout(timeoutID); // stop repeat calls to updateInteractiveLayer\n      timeoutID = setTimeout(updateInteractiveLayer, 300);\n      //updateInteractiveLayer();\n\n      //store old scales for use in transitions on update\n      x0 = x.copy();\n      y0 = y.copy();\n      z0 = z.copy();\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Event Handling/Dispatching (out of chart's scope)\n  //------------------------------------------------------------\n  chart.clearHighlights = function () {\n    //Remove the 'hover' class from all highlighted points.\n    d3v3.selectAll(\".nv-chart-\" + id + \" .nv-point.hover\").classed(\"hover\", false);\n  };\n  chart.highlightPoint = function (seriesIndex, pointIndex, isHoverOver) {\n    d3v3.select(\".nv-chart-\" + id + \" .nv-series-\" + seriesIndex + \" .nv-point-\" + pointIndex).classed(\"hover\", isHoverOver);\n  };\n  dispatch.on('elementMouseover.point', function (d) {\n    if (interactive) chart.highlightPoint(d.seriesIndex, d.pointIndex, true);\n  });\n  dispatch.on('elementMouseout.point', function (d) {\n    if (interactive) chart.highlightPoint(d.seriesIndex, d.pointIndex, false);\n  });\n\n  //============================================================\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  chart.dispatch = dispatch;\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.x = function (_) {\n    if (!arguments.length) return getX;\n    getX = d3v3.functor(_);\n    return chart;\n  };\n  chart.y = function (_) {\n    if (!arguments.length) return getY;\n    getY = d3v3.functor(_);\n    return chart;\n  };\n  chart.size = function (_) {\n    if (!arguments.length) return getSize;\n    getSize = d3v3.functor(_);\n    return chart;\n  };\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.xScale = function (_) {\n    if (!arguments.length) return x;\n    x = _;\n    return chart;\n  };\n  chart.yScale = function (_) {\n    if (!arguments.length) return y;\n    y = _;\n    return chart;\n  };\n  chart.zScale = function (_) {\n    if (!arguments.length) return z;\n    z = _;\n    return chart;\n  };\n  chart.xDomain = function (_) {\n    if (!arguments.length) return xDomain;\n    xDomain = _;\n    return chart;\n  };\n  chart.yDomain = function (_) {\n    if (!arguments.length) return yDomain;\n    yDomain = _;\n    return chart;\n  };\n  chart.sizeDomain = function (_) {\n    if (!arguments.length) return sizeDomain;\n    sizeDomain = _;\n    return chart;\n  };\n  chart.xRange = function (_) {\n    if (!arguments.length) return xRange;\n    xRange = _;\n    return chart;\n  };\n  chart.yRange = function (_) {\n    if (!arguments.length) return yRange;\n    yRange = _;\n    return chart;\n  };\n  chart.sizeRange = function (_) {\n    if (!arguments.length) return sizeRange;\n    sizeRange = _;\n    return chart;\n  };\n  chart.forceX = function (_) {\n    if (!arguments.length) return forceX;\n    forceX = _;\n    return chart;\n  };\n  chart.forceY = function (_) {\n    if (!arguments.length) return forceY;\n    forceY = _;\n    return chart;\n  };\n  chart.forceSize = function (_) {\n    if (!arguments.length) return forceSize;\n    forceSize = _;\n    return chart;\n  };\n  chart.interactive = function (_) {\n    if (!arguments.length) return interactive;\n    interactive = _;\n    return chart;\n  };\n  chart.pointKey = function (_) {\n    if (!arguments.length) return pointKey;\n    pointKey = _;\n    return chart;\n  };\n  chart.pointActive = function (_) {\n    if (!arguments.length) return pointActive;\n    pointActive = _;\n    return chart;\n  };\n  chart.padData = function (_) {\n    if (!arguments.length) return padData;\n    padData = _;\n    return chart;\n  };\n  chart.padDataOuter = function (_) {\n    if (!arguments.length) return padDataOuter;\n    padDataOuter = _;\n    return chart;\n  };\n  chart.clipEdge = function (_) {\n    if (!arguments.length) return clipEdge;\n    clipEdge = _;\n    return chart;\n  };\n  chart.clipVoronoi = function (_) {\n    if (!arguments.length) return clipVoronoi;\n    clipVoronoi = _;\n    return chart;\n  };\n  chart.useVoronoi = function (_) {\n    if (!arguments.length) return useVoronoi;\n    useVoronoi = _;\n    if (useVoronoi === false) {\n      clipVoronoi = false;\n    }\n    return chart;\n  };\n  chart.clipRadius = function (_) {\n    if (!arguments.length) return clipRadius;\n    clipRadius = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    return chart;\n  };\n  chart.shape = function (_) {\n    if (!arguments.length) return getShape;\n    getShape = _;\n    return chart;\n  };\n  chart.onlyCircles = function (_) {\n    if (!arguments.length) return onlyCircles;\n    onlyCircles = _;\n    return chart;\n  };\n  chart.id = function (_) {\n    if (!arguments.length) return id;\n    id = _;\n    return chart;\n  };\n  chart.singlePoint = function (_) {\n    if (!arguments.length) return singlePoint;\n    singlePoint = _;\n    return chart;\n  };\n\n  //============================================================\n\n  return chart;\n};\nnv.models.scatterChart = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var scatter = nv.models.scatter(),\n    xAxis = nv.models.axis(),\n    yAxis = nv.models.axis(),\n    legend = nv.models.legend(),\n    controls = nv.models.legend(),\n    distX = nv.models.distribution(),\n    distY = nv.models.distribution();\n  var margin = {\n      top: 30,\n      right: 20,\n      bottom: 50,\n      left: 75\n    },\n    width = null,\n    height = null,\n    color = nv.utils.defaultColor(),\n    x = d3v3.fisheye ? d3v3.fisheye.scale(d3v3.scale.linear).distortion(0) : scatter.xScale(),\n    y = d3v3.fisheye ? d3v3.fisheye.scale(d3v3.scale.linear).distortion(0) : scatter.yScale(),\n    xPadding = 0,\n    yPadding = 0,\n    showDistX = false,\n    showDistY = false,\n    showLegend = true,\n    showXAxis = true,\n    showYAxis = true,\n    rightAlignYAxis = false,\n    showControls = !!d3v3.fisheye,\n    fisheye = 0,\n    pauseFisheye = false,\n    tooltips = true,\n    tooltipX = function tooltipX(key, x, y) {\n      return '<strong>' + x + '</strong>';\n    },\n    tooltipY = function tooltipY(key, x, y) {\n      return '<strong>' + y + '</strong>';\n    },\n    tooltip = null,\n    state = {},\n    defaultState = null,\n    dispatch = d3v3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState'),\n    noData = \"No Data Available.\",\n    transitionDuration = 250;\n  scatter.xScale(x).yScale(y);\n  xAxis.orient('bottom').tickPadding(10);\n  yAxis.orient(rightAlignYAxis ? 'right' : 'left').tickPadding(10);\n  distX.axis('x');\n  distY.axis('y');\n  controls.updateState(false);\n\n  //============================================================\n\n  //============================================================\n  // Private Variables\n  //------------------------------------------------------------\n\n  var x0, y0;\n  var showTooltip = function showTooltip(e, offsetElement) {\n    //TODO: make tooltip style an option between single or dual on axes (maybe on all charts with axes?)\n\n    var left = e.pos[0] + (offsetElement.offsetLeft || 0),\n      top = e.pos[1] + (offsetElement.offsetTop || 0),\n      leftX = e.pos[0] + (offsetElement.offsetLeft || 0),\n      topX = y.range()[0] + margin.top + (offsetElement.offsetTop || 0),\n      leftY = x.range()[0] + margin.left + (offsetElement.offsetLeft || 0),\n      topY = e.pos[1] + (offsetElement.offsetTop || 0),\n      xVal = xAxis.tickFormat()(scatter.x()(e.point, e.pointIndex)),\n      yVal = yAxis.tickFormat()(scatter.y()(e.point, e.pointIndex));\n    if (tooltipX != null) nv.tooltip.show([leftX, topX], tooltipX(e.series.key, xVal, yVal, e, chart), 'n', 1, offsetElement, 'x-nvtooltip');\n    if (tooltipY != null) nv.tooltip.show([leftY, topY], tooltipY(e.series.key, xVal, yVal, e, chart), 'e', 1, offsetElement, 'y-nvtooltip');\n    if (tooltip != null) nv.tooltip.show([left, top], tooltip(e.series.key, xVal, yVal, e, chart), e.value < 0 ? 'n' : 's', null, offsetElement);\n  };\n  var controlsData = [{\n    key: 'Magnify',\n    disabled: true\n  }];\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var container = d3v3.select(this),\n        that = this;\n      var availableWidth = (width || parseInt(container.style('width')) || 960) - margin.left - margin.right,\n        availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n      chart.update = function () {\n        container.transition().duration(transitionDuration).call(chart);\n      };\n      chart.container = this;\n\n      //set state.disabled\n      state.disabled = data.map(function (d) {\n        return !!d.disabled;\n      });\n      if (!defaultState) {\n        var key;\n        defaultState = {};\n        for (key in state) {\n          if (state[key] instanceof Array) defaultState[key] = state[key].slice(0);else defaultState[key] = state[key];\n        }\n      }\n\n      //------------------------------------------------------------\n      // Display noData message if there's nothing to show.\n\n      if (!data || !data.length || !data.filter(function (d) {\n        return d.values.length;\n      }).length) {\n        var noDataText = container.selectAll('.nv-noData').data([noData]);\n        noDataText.enter().append('text').attr('class', 'nvd3 nv-noData').attr('dy', '-.7em').style('text-anchor', 'middle');\n        noDataText.attr('x', margin.left + availableWidth / 2).attr('y', margin.top + availableHeight / 2).text(function (d) {\n          return d;\n        });\n        return chart;\n      } else {\n        container.selectAll('.nv-noData').remove();\n      }\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Scales\n\n      x0 = x0 || x;\n      y0 = y0 || y;\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = container.selectAll('g.nv-wrap.nv-scatterChart').data([data]);\n      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-scatterChart nv-chart-' + scatter.id());\n      var gEnter = wrapEnter.append('g');\n      var g = wrap.select('g');\n\n      // background for pointer events\n      gEnter.append('rect').attr('class', 'nvd3 nv-background');\n      gEnter.append('g').attr('class', 'nv-x nv-axis');\n      gEnter.append('g').attr('class', 'nv-y nv-axis');\n      gEnter.append('g').attr('class', 'nv-scatterWrap');\n      gEnter.append('g').attr('class', 'nv-distWrap');\n      gEnter.append('g').attr('class', 'nv-legendWrap');\n      gEnter.append('g').attr('class', 'nv-controlsWrap');\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Legend\n\n      if (showLegend) {\n        var legendWidth = showControls ? availableWidth / 2 : availableWidth;\n        legend.width(legendWidth);\n        wrap.select('.nv-legendWrap').datum(data).call(legend);\n        if (margin.top != legend.height()) {\n          margin.top = legend.height();\n          availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n        }\n        wrap.select('.nv-legendWrap').attr('transform', 'translate(' + (availableWidth - legendWidth) + ',' + -margin.top + ')');\n      }\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Controls\n\n      if (showControls) {\n        controls.width(180).color(['#444']);\n        g.select('.nv-controlsWrap').datum(controlsData).attr('transform', 'translate(0,' + -margin.top + ')').call(controls);\n      }\n\n      //------------------------------------------------------------\n\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n      if (rightAlignYAxis) {\n        g.select(\".nv-y.nv-axis\").attr(\"transform\", \"translate(\" + availableWidth + \",0)\");\n      }\n\n      //------------------------------------------------------------\n      // Main Chart Component(s)\n\n      scatter.width(availableWidth).height(availableHeight).color(data.map(function (d, i) {\n        return d.color || color(d, i);\n      }).filter(function (d, i) {\n        return !data[i].disabled;\n      }));\n      if (xPadding !== 0) scatter.xDomain(null);\n      if (yPadding !== 0) scatter.yDomain(null);\n      wrap.select('.nv-scatterWrap').datum(data.filter(function (d) {\n        return !d.disabled;\n      })).call(scatter);\n\n      //Adjust for x and y padding\n      if (xPadding !== 0) {\n        var xRange = x.domain()[1] - x.domain()[0];\n        scatter.xDomain([x.domain()[0] - xPadding * xRange, x.domain()[1] + xPadding * xRange]);\n      }\n      if (yPadding !== 0) {\n        var yRange = y.domain()[1] - y.domain()[0];\n        scatter.yDomain([y.domain()[0] - yPadding * yRange, y.domain()[1] + yPadding * yRange]);\n      }\n\n      //Only need to update the scatter again if x/yPadding changed the domain.\n      if (yPadding !== 0 || xPadding !== 0) {\n        wrap.select('.nv-scatterWrap').datum(data.filter(function (d) {\n          return !d.disabled;\n        })).call(scatter);\n      }\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Axes\n      if (showXAxis) {\n        xAxis.scale(x).ticks(xAxis.ticks() && xAxis.ticks().length ? xAxis.ticks() : availableWidth / 100).tickSize(-availableHeight, 0);\n        g.select('.nv-x.nv-axis').attr('transform', 'translate(0,' + y.range()[0] + ')').call(xAxis);\n      }\n      if (showYAxis) {\n        yAxis.scale(y).ticks(yAxis.ticks() && yAxis.ticks().length ? yAxis.ticks() : availableHeight / 36).tickSize(-availableWidth, 0);\n        g.select('.nv-y.nv-axis').call(yAxis);\n      }\n      if (showDistX) {\n        distX.getData(scatter.x()).scale(x).width(availableWidth).color(data.map(function (d, i) {\n          return d.color || color(d, i);\n        }).filter(function (d, i) {\n          return !data[i].disabled;\n        }));\n        gEnter.select('.nv-distWrap').append('g').attr('class', 'nv-distributionX');\n        g.select('.nv-distributionX').attr('transform', 'translate(0,' + y.range()[0] + ')').datum(data.filter(function (d) {\n          return !d.disabled;\n        })).call(distX);\n      }\n      if (showDistY) {\n        distY.getData(scatter.y()).scale(y).width(availableHeight).color(data.map(function (d, i) {\n          return d.color || color(d, i);\n        }).filter(function (d, i) {\n          return !data[i].disabled;\n        }));\n        gEnter.select('.nv-distWrap').append('g').attr('class', 'nv-distributionY');\n        g.select('.nv-distributionY').attr('transform', 'translate(' + (rightAlignYAxis ? availableWidth : -distY.size()) + ',0)').datum(data.filter(function (d) {\n          return !d.disabled;\n        })).call(distY);\n      }\n\n      //------------------------------------------------------------\n\n      if (d3v3.fisheye) {\n        g.select('.nv-background').attr('width', availableWidth).attr('height', availableHeight);\n        g.select('.nv-background').on('mousemove', updateFisheye);\n        g.select('.nv-background').on('click', function () {\n          pauseFisheye = !pauseFisheye;\n        });\n        scatter.dispatch.on('elementClick.freezeFisheye', function () {\n          pauseFisheye = !pauseFisheye;\n        });\n      }\n      function updateFisheye() {\n        if (pauseFisheye) {\n          g.select('.nv-point-paths').style('pointer-events', 'all');\n          return false;\n        }\n        g.select('.nv-point-paths').style('pointer-events', 'none');\n        var mouse = d3v3.mouse(this);\n        x.distortion(fisheye).focus(mouse[0]);\n        y.distortion(fisheye).focus(mouse[1]);\n        g.select('.nv-scatterWrap').call(scatter);\n        if (showXAxis) g.select('.nv-x.nv-axis').call(xAxis);\n        if (showYAxis) g.select('.nv-y.nv-axis').call(yAxis);\n        g.select('.nv-distributionX').datum(data.filter(function (d) {\n          return !d.disabled;\n        })).call(distX);\n        g.select('.nv-distributionY').datum(data.filter(function (d) {\n          return !d.disabled;\n        })).call(distY);\n      }\n\n      //============================================================\n      // Event Handling/Dispatching (in chart's scope)\n      //------------------------------------------------------------\n\n      controls.dispatch.on('legendClick', function (d, i) {\n        d.disabled = !d.disabled;\n        fisheye = d.disabled ? 0 : 2.5;\n        g.select('.nv-background').style('pointer-events', d.disabled ? 'none' : 'all');\n        g.select('.nv-point-paths').style('pointer-events', d.disabled ? 'all' : 'none');\n        if (d.disabled) {\n          x.distortion(fisheye).focus(0);\n          y.distortion(fisheye).focus(0);\n          g.select('.nv-scatterWrap').call(scatter);\n          g.select('.nv-x.nv-axis').call(xAxis);\n          g.select('.nv-y.nv-axis').call(yAxis);\n        } else {\n          pauseFisheye = false;\n        }\n        chart.update();\n      });\n      legend.dispatch.on('stateChange', function (newState) {\n        state.disabled = newState.disabled;\n        dispatch.stateChange(state);\n        chart.update();\n      });\n      scatter.dispatch.on('elementMouseover.tooltip', function (e) {\n        d3v3.select('.nv-chart-' + scatter.id() + ' .nv-series-' + e.seriesIndex + ' .nv-distx-' + e.pointIndex).attr('y1', function (d, i) {\n          return e.pos[1] - availableHeight;\n        });\n        d3v3.select('.nv-chart-' + scatter.id() + ' .nv-series-' + e.seriesIndex + ' .nv-disty-' + e.pointIndex).attr('x2', e.pos[0] + distX.size());\n        e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];\n        dispatch.tooltipShow(e);\n      });\n      dispatch.on('tooltipShow', function (e) {\n        if (tooltips) showTooltip(e, that.parentNode);\n      });\n\n      // Update chart from a state object passed to event handler\n      dispatch.on('changeState', function (e) {\n        if (typeof e.disabled !== 'undefined') {\n          data.forEach(function (series, i) {\n            series.disabled = e.disabled[i];\n          });\n          state.disabled = e.disabled;\n        }\n        chart.update();\n      });\n\n      //============================================================\n\n      //store old scales for use in transitions on update\n      x0 = x.copy();\n      y0 = y.copy();\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Event Handling/Dispatching (out of chart's scope)\n  //------------------------------------------------------------\n\n  scatter.dispatch.on('elementMouseout.tooltip', function (e) {\n    dispatch.tooltipHide(e);\n    d3v3.select('.nv-chart-' + scatter.id() + ' .nv-series-' + e.seriesIndex + ' .nv-distx-' + e.pointIndex).attr('y1', 0);\n    d3v3.select('.nv-chart-' + scatter.id() + ' .nv-series-' + e.seriesIndex + ' .nv-disty-' + e.pointIndex).attr('x2', distY.size());\n  });\n  dispatch.on('tooltipHide', function () {\n    if (tooltips) nv.tooltip.cleanup();\n  });\n\n  //============================================================\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  // expose chart's sub-components\n  chart.dispatch = dispatch;\n  chart.scatter = scatter;\n  chart.legend = legend;\n  chart.controls = controls;\n  chart.xAxis = xAxis;\n  chart.yAxis = yAxis;\n  chart.distX = distX;\n  chart.distY = distY;\n  d3v3.rebind(chart, scatter, 'id', 'interactive', 'pointActive', 'x', 'y', 'shape', 'size', 'xScale', 'yScale', 'zScale', 'xDomain', 'yDomain', 'xRange', 'yRange', 'sizeDomain', 'sizeRange', 'forceX', 'forceY', 'forceSize', 'clipVoronoi', 'clipRadius', 'useVoronoi');\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    legend.color(color);\n    distX.color(color);\n    distY.color(color);\n    return chart;\n  };\n  chart.showDistX = function (_) {\n    if (!arguments.length) return showDistX;\n    showDistX = _;\n    return chart;\n  };\n  chart.showDistY = function (_) {\n    if (!arguments.length) return showDistY;\n    showDistY = _;\n    return chart;\n  };\n  chart.showControls = function (_) {\n    if (!arguments.length) return showControls;\n    showControls = _;\n    return chart;\n  };\n  chart.showLegend = function (_) {\n    if (!arguments.length) return showLegend;\n    showLegend = _;\n    return chart;\n  };\n  chart.showXAxis = function (_) {\n    if (!arguments.length) return showXAxis;\n    showXAxis = _;\n    return chart;\n  };\n  chart.showYAxis = function (_) {\n    if (!arguments.length) return showYAxis;\n    showYAxis = _;\n    return chart;\n  };\n  chart.rightAlignYAxis = function (_) {\n    if (!arguments.length) return rightAlignYAxis;\n    rightAlignYAxis = _;\n    yAxis.orient(_ ? 'right' : 'left');\n    return chart;\n  };\n  chart.fisheye = function (_) {\n    if (!arguments.length) return fisheye;\n    fisheye = _;\n    return chart;\n  };\n  chart.xPadding = function (_) {\n    if (!arguments.length) return xPadding;\n    xPadding = _;\n    return chart;\n  };\n  chart.yPadding = function (_) {\n    if (!arguments.length) return yPadding;\n    yPadding = _;\n    return chart;\n  };\n  chart.tooltips = function (_) {\n    if (!arguments.length) return tooltips;\n    tooltips = _;\n    return chart;\n  };\n  chart.tooltipContent = function (_) {\n    if (!arguments.length) return tooltip;\n    tooltip = _;\n    return chart;\n  };\n  chart.tooltipXContent = function (_) {\n    if (!arguments.length) return tooltipX;\n    tooltipX = _;\n    return chart;\n  };\n  chart.tooltipYContent = function (_) {\n    if (!arguments.length) return tooltipY;\n    tooltipY = _;\n    return chart;\n  };\n  chart.state = function (_) {\n    if (!arguments.length) return state;\n    state = _;\n    return chart;\n  };\n  chart.defaultState = function (_) {\n    if (!arguments.length) return defaultState;\n    defaultState = _;\n    return chart;\n  };\n  chart.noData = function (_) {\n    if (!arguments.length) return noData;\n    noData = _;\n    return chart;\n  };\n  chart.transitionDuration = function (_) {\n    if (!arguments.length) return transitionDuration;\n    transitionDuration = _;\n    return chart;\n  };\n\n  //============================================================\n\n  return chart;\n};\nnv.models.scatterPlusLineChart = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var scatter = nv.models.scatter(),\n    xAxis = nv.models.axis(),\n    yAxis = nv.models.axis(),\n    legend = nv.models.legend(),\n    controls = nv.models.legend(),\n    distX = nv.models.distribution(),\n    distY = nv.models.distribution();\n  var margin = {\n      top: 30,\n      right: 20,\n      bottom: 50,\n      left: 75\n    },\n    width = null,\n    height = null,\n    color = nv.utils.defaultColor(),\n    x = d3v3.fisheye ? d3v3.fisheye.scale(d3v3.scale.linear).distortion(0) : scatter.xScale(),\n    y = d3v3.fisheye ? d3v3.fisheye.scale(d3v3.scale.linear).distortion(0) : scatter.yScale(),\n    showDistX = false,\n    showDistY = false,\n    showLegend = true,\n    showXAxis = true,\n    showYAxis = true,\n    rightAlignYAxis = false,\n    showControls = !!d3v3.fisheye,\n    fisheye = 0,\n    pauseFisheye = false,\n    tooltips = true,\n    tooltipX = function tooltipX(key, x, y) {\n      return '<strong>' + x + '</strong>';\n    },\n    tooltipY = function tooltipY(key, x, y) {\n      return '<strong>' + y + '</strong>';\n    },\n    tooltip = function tooltip(key, x, y, date) {\n      return '<h3>' + key + '</h3>' + '<p>' + date + '</p>';\n    },\n    state = {},\n    defaultState = null,\n    dispatch = d3v3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState'),\n    noData = \"No Data Available.\",\n    transitionDuration = 250;\n  scatter.xScale(x).yScale(y);\n  xAxis.orient('bottom').tickPadding(10);\n  yAxis.orient(rightAlignYAxis ? 'right' : 'left').tickPadding(10);\n  distX.axis('x');\n  distY.axis('y');\n  controls.updateState(false);\n  //============================================================\n\n  //============================================================\n  // Private Variables\n  //------------------------------------------------------------\n\n  var x0, y0;\n  var showTooltip = function showTooltip(e, offsetElement) {\n    //TODO: make tooltip style an option between single or dual on axes (maybe on all charts with axes?)\n\n    var left = e.pos[0] + (offsetElement.offsetLeft || 0),\n      top = e.pos[1] + (offsetElement.offsetTop || 0),\n      leftX = e.pos[0] + (offsetElement.offsetLeft || 0),\n      topX = y.range()[0] + margin.top + (offsetElement.offsetTop || 0),\n      leftY = x.range()[0] + margin.left + (offsetElement.offsetLeft || 0),\n      topY = e.pos[1] + (offsetElement.offsetTop || 0),\n      xVal = xAxis.tickFormat()(scatter.x()(e.point, e.pointIndex)),\n      yVal = yAxis.tickFormat()(scatter.y()(e.point, e.pointIndex));\n    if (tooltipX != null) nv.tooltip.show([leftX, topX], tooltipX(e.series.key, xVal, yVal, e, chart), 'n', 1, offsetElement, 'x-nvtooltip');\n    if (tooltipY != null) nv.tooltip.show([leftY, topY], tooltipY(e.series.key, xVal, yVal, e, chart), 'e', 1, offsetElement, 'y-nvtooltip');\n    if (tooltip != null) nv.tooltip.show([left, top], tooltip(e.series.key, xVal, yVal, e.point.tooltip, e, chart), e.value < 0 ? 'n' : 's', null, offsetElement);\n  };\n  var controlsData = [{\n    key: 'Magnify',\n    disabled: true\n  }];\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var container = d3v3.select(this),\n        that = this;\n      var availableWidth = (width || parseInt(container.style('width')) || 960) - margin.left - margin.right,\n        availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n      chart.update = function () {\n        container.transition().duration(transitionDuration).call(chart);\n      };\n      chart.container = this;\n\n      //set state.disabled\n      state.disabled = data.map(function (d) {\n        return !!d.disabled;\n      });\n      if (!defaultState) {\n        var key;\n        defaultState = {};\n        for (key in state) {\n          if (state[key] instanceof Array) defaultState[key] = state[key].slice(0);else defaultState[key] = state[key];\n        }\n      }\n\n      //------------------------------------------------------------\n      // Display noData message if there's nothing to show.\n\n      if (!data || !data.length || !data.filter(function (d) {\n        return d.values.length;\n      }).length) {\n        var noDataText = container.selectAll('.nv-noData').data([noData]);\n        noDataText.enter().append('text').attr('class', 'nvd3 nv-noData').attr('dy', '-.7em').style('text-anchor', 'middle');\n        noDataText.attr('x', margin.left + availableWidth / 2).attr('y', margin.top + availableHeight / 2).text(function (d) {\n          return d;\n        });\n        return chart;\n      } else {\n        container.selectAll('.nv-noData').remove();\n      }\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Scales\n\n      x = scatter.xScale();\n      y = scatter.yScale();\n      x0 = x0 || x;\n      y0 = y0 || y;\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = container.selectAll('g.nv-wrap.nv-scatterChart').data([data]);\n      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-scatterChart nv-chart-' + scatter.id());\n      var gEnter = wrapEnter.append('g');\n      var g = wrap.select('g');\n\n      // background for pointer events\n      gEnter.append('rect').attr('class', 'nvd3 nv-background').style(\"pointer-events\", \"none\");\n      gEnter.append('g').attr('class', 'nv-x nv-axis');\n      gEnter.append('g').attr('class', 'nv-y nv-axis');\n      gEnter.append('g').attr('class', 'nv-scatterWrap');\n      gEnter.append('g').attr('class', 'nv-regressionLinesWrap');\n      gEnter.append('g').attr('class', 'nv-distWrap');\n      gEnter.append('g').attr('class', 'nv-legendWrap');\n      gEnter.append('g').attr('class', 'nv-controlsWrap');\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n      if (rightAlignYAxis) {\n        g.select(\".nv-y.nv-axis\").attr(\"transform\", \"translate(\" + availableWidth + \",0)\");\n      }\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Legend\n\n      if (showLegend) {\n        legend.width(availableWidth / 2);\n        wrap.select('.nv-legendWrap').datum(data).call(legend);\n        if (margin.top != legend.height()) {\n          margin.top = legend.height();\n          availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n        }\n        wrap.select('.nv-legendWrap').attr('transform', 'translate(' + availableWidth / 2 + ',' + -margin.top + ')');\n      }\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Controls\n\n      if (showControls) {\n        controls.width(180).color(['#444']);\n        g.select('.nv-controlsWrap').datum(controlsData).attr('transform', 'translate(0,' + -margin.top + ')').call(controls);\n      }\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Main Chart Component(s)\n\n      scatter.width(availableWidth).height(availableHeight).color(data.map(function (d, i) {\n        return d.color || color(d, i);\n      }).filter(function (d, i) {\n        return !data[i].disabled;\n      }));\n      wrap.select('.nv-scatterWrap').datum(data.filter(function (d) {\n        return !d.disabled;\n      })).call(scatter);\n      wrap.select('.nv-regressionLinesWrap').attr('clip-path', 'url(#nv-edge-clip-' + scatter.id() + ')');\n      var regWrap = wrap.select('.nv-regressionLinesWrap').selectAll('.nv-regLines').data(function (d) {\n        return d;\n      });\n      regWrap.enter().append('g').attr('class', 'nv-regLines');\n      var regLine = regWrap.selectAll('.nv-regLine').data(function (d) {\n        return [d];\n      });\n      var regLineEnter = regLine.enter().append('line').attr('class', 'nv-regLine').style('stroke-opacity', 0);\n      regLine.transition().attr('x1', x.range()[0]).attr('x2', x.range()[1]).attr('y1', function (d, i) {\n        return y(x.domain()[0] * d.slope + d.intercept);\n      }).attr('y2', function (d, i) {\n        return y(x.domain()[1] * d.slope + d.intercept);\n      }).style('stroke', function (d, i, j) {\n        return color(d, j);\n      }).style('stroke-opacity', function (d, i) {\n        return d.disabled || typeof d.slope === 'undefined' || typeof d.intercept === 'undefined' ? 0 : 1;\n      });\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Axes\n\n      if (showXAxis) {\n        xAxis.scale(x).ticks(xAxis.ticks() ? xAxis.ticks() : availableWidth / 100).tickSize(-availableHeight, 0);\n        g.select('.nv-x.nv-axis').attr('transform', 'translate(0,' + y.range()[0] + ')').call(xAxis);\n      }\n      if (showYAxis) {\n        yAxis.scale(y).ticks(yAxis.ticks() ? yAxis.ticks() : availableHeight / 36).tickSize(-availableWidth, 0);\n        g.select('.nv-y.nv-axis').call(yAxis);\n      }\n      if (showDistX) {\n        distX.getData(scatter.x()).scale(x).width(availableWidth).color(data.map(function (d, i) {\n          return d.color || color(d, i);\n        }).filter(function (d, i) {\n          return !data[i].disabled;\n        }));\n        gEnter.select('.nv-distWrap').append('g').attr('class', 'nv-distributionX');\n        g.select('.nv-distributionX').attr('transform', 'translate(0,' + y.range()[0] + ')').datum(data.filter(function (d) {\n          return !d.disabled;\n        })).call(distX);\n      }\n      if (showDistY) {\n        distY.getData(scatter.y()).scale(y).width(availableHeight).color(data.map(function (d, i) {\n          return d.color || color(d, i);\n        }).filter(function (d, i) {\n          return !data[i].disabled;\n        }));\n        gEnter.select('.nv-distWrap').append('g').attr('class', 'nv-distributionY');\n        g.select('.nv-distributionY').attr('transform', 'translate(' + (rightAlignYAxis ? availableWidth : -distY.size()) + ',0)').datum(data.filter(function (d) {\n          return !d.disabled;\n        })).call(distY);\n      }\n\n      //------------------------------------------------------------\n\n      if (d3v3.fisheye) {\n        g.select('.nv-background').attr('width', availableWidth).attr('height', availableHeight);\n        g.select('.nv-background').on('mousemove', updateFisheye);\n        g.select('.nv-background').on('click', function () {\n          pauseFisheye = !pauseFisheye;\n        });\n        scatter.dispatch.on('elementClick.freezeFisheye', function () {\n          pauseFisheye = !pauseFisheye;\n        });\n      }\n      function updateFisheye() {\n        if (pauseFisheye) {\n          g.select('.nv-point-paths').style('pointer-events', 'all');\n          return false;\n        }\n        g.select('.nv-point-paths').style('pointer-events', 'none');\n        var mouse = d3v3.mouse(this);\n        x.distortion(fisheye).focus(mouse[0]);\n        y.distortion(fisheye).focus(mouse[1]);\n        g.select('.nv-scatterWrap').datum(data.filter(function (d) {\n          return !d.disabled;\n        })).call(scatter);\n        if (showXAxis) g.select('.nv-x.nv-axis').call(xAxis);\n        if (showYAxis) g.select('.nv-y.nv-axis').call(yAxis);\n        g.select('.nv-distributionX').datum(data.filter(function (d) {\n          return !d.disabled;\n        })).call(distX);\n        g.select('.nv-distributionY').datum(data.filter(function (d) {\n          return !d.disabled;\n        })).call(distY);\n      }\n\n      //============================================================\n      // Event Handling/Dispatching (in chart's scope)\n      //------------------------------------------------------------\n\n      controls.dispatch.on('legendClick', function (d, i) {\n        d.disabled = !d.disabled;\n        fisheye = d.disabled ? 0 : 2.5;\n        g.select('.nv-background').style('pointer-events', d.disabled ? 'none' : 'all');\n        g.select('.nv-point-paths').style('pointer-events', d.disabled ? 'all' : 'none');\n        if (d.disabled) {\n          x.distortion(fisheye).focus(0);\n          y.distortion(fisheye).focus(0);\n          g.select('.nv-scatterWrap').call(scatter);\n          g.select('.nv-x.nv-axis').call(xAxis);\n          g.select('.nv-y.nv-axis').call(yAxis);\n        } else {\n          pauseFisheye = false;\n        }\n        chart.update();\n      });\n      legend.dispatch.on('stateChange', function (newState) {\n        state = newState;\n        dispatch.stateChange(state);\n        chart.update();\n      });\n      scatter.dispatch.on('elementMouseover.tooltip', function (e) {\n        d3v3.select('.nv-chart-' + scatter.id() + ' .nv-series-' + e.seriesIndex + ' .nv-distx-' + e.pointIndex).attr('y1', e.pos[1] - availableHeight);\n        d3v3.select('.nv-chart-' + scatter.id() + ' .nv-series-' + e.seriesIndex + ' .nv-disty-' + e.pointIndex).attr('x2', e.pos[0] + distX.size());\n        e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];\n        dispatch.tooltipShow(e);\n      });\n      dispatch.on('tooltipShow', function (e) {\n        if (tooltips) showTooltip(e, that.parentNode);\n      });\n\n      // Update chart from a state object passed to event handler\n      dispatch.on('changeState', function (e) {\n        if (typeof e.disabled !== 'undefined') {\n          data.forEach(function (series, i) {\n            series.disabled = e.disabled[i];\n          });\n          state.disabled = e.disabled;\n        }\n        chart.update();\n      });\n\n      //============================================================\n\n      //store old scales for use in transitions on update\n      x0 = x.copy();\n      y0 = y.copy();\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Event Handling/Dispatching (out of chart's scope)\n  //------------------------------------------------------------\n\n  scatter.dispatch.on('elementMouseout.tooltip', function (e) {\n    dispatch.tooltipHide(e);\n    d3v3.select('.nv-chart-' + scatter.id() + ' .nv-series-' + e.seriesIndex + ' .nv-distx-' + e.pointIndex).attr('y1', 0);\n    d3v3.select('.nv-chart-' + scatter.id() + ' .nv-series-' + e.seriesIndex + ' .nv-disty-' + e.pointIndex).attr('x2', distY.size());\n  });\n  dispatch.on('tooltipHide', function () {\n    if (tooltips) nv.tooltip.cleanup();\n  });\n\n  //============================================================\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  // expose chart's sub-components\n  chart.dispatch = dispatch;\n  chart.scatter = scatter;\n  chart.legend = legend;\n  chart.controls = controls;\n  chart.xAxis = xAxis;\n  chart.yAxis = yAxis;\n  chart.distX = distX;\n  chart.distY = distY;\n  d3v3.rebind(chart, scatter, 'id', 'interactive', 'pointActive', 'x', 'y', 'shape', 'size', 'xScale', 'yScale', 'zScale', 'xDomain', 'yDomain', 'xRange', 'yRange', 'sizeDomain', 'sizeRange', 'forceX', 'forceY', 'forceSize', 'clipVoronoi', 'clipRadius', 'useVoronoi');\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    legend.color(color);\n    distX.color(color);\n    distY.color(color);\n    return chart;\n  };\n  chart.showDistX = function (_) {\n    if (!arguments.length) return showDistX;\n    showDistX = _;\n    return chart;\n  };\n  chart.showDistY = function (_) {\n    if (!arguments.length) return showDistY;\n    showDistY = _;\n    return chart;\n  };\n  chart.showControls = function (_) {\n    if (!arguments.length) return showControls;\n    showControls = _;\n    return chart;\n  };\n  chart.showLegend = function (_) {\n    if (!arguments.length) return showLegend;\n    showLegend = _;\n    return chart;\n  };\n  chart.showXAxis = function (_) {\n    if (!arguments.length) return showXAxis;\n    showXAxis = _;\n    return chart;\n  };\n  chart.showYAxis = function (_) {\n    if (!arguments.length) return showYAxis;\n    showYAxis = _;\n    return chart;\n  };\n  chart.rightAlignYAxis = function (_) {\n    if (!arguments.length) return rightAlignYAxis;\n    rightAlignYAxis = _;\n    yAxis.orient(_ ? 'right' : 'left');\n    return chart;\n  };\n  chart.fisheye = function (_) {\n    if (!arguments.length) return fisheye;\n    fisheye = _;\n    return chart;\n  };\n  chart.tooltips = function (_) {\n    if (!arguments.length) return tooltips;\n    tooltips = _;\n    return chart;\n  };\n  chart.tooltipContent = function (_) {\n    if (!arguments.length) return tooltip;\n    tooltip = _;\n    return chart;\n  };\n  chart.tooltipXContent = function (_) {\n    if (!arguments.length) return tooltipX;\n    tooltipX = _;\n    return chart;\n  };\n  chart.tooltipYContent = function (_) {\n    if (!arguments.length) return tooltipY;\n    tooltipY = _;\n    return chart;\n  };\n  chart.state = function (_) {\n    if (!arguments.length) return state;\n    state = _;\n    return chart;\n  };\n  chart.defaultState = function (_) {\n    if (!arguments.length) return defaultState;\n    defaultState = _;\n    return chart;\n  };\n  chart.noData = function (_) {\n    if (!arguments.length) return noData;\n    noData = _;\n    return chart;\n  };\n  chart.transitionDuration = function (_) {\n    if (!arguments.length) return transitionDuration;\n    transitionDuration = _;\n    return chart;\n  };\n\n  //============================================================\n\n  return chart;\n};\nnv.models.sparkline = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var margin = {\n      top: 2,\n      right: 0,\n      bottom: 2,\n      left: 0\n    },\n    width = 400,\n    height = 32,\n    animate = true,\n    x = d3v3.scale.linear(),\n    y = d3v3.scale.linear(),\n    getX = function getX(d) {\n      return d.x;\n    },\n    getY = function getY(d) {\n      return d.y;\n    },\n    color = nv.utils.getColor(['#000']),\n    xDomain,\n    yDomain,\n    xRange,\n    yRange;\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var availableWidth = width - margin.left - margin.right,\n        availableHeight = height - margin.top - margin.bottom,\n        container = d3v3.select(this);\n\n      //------------------------------------------------------------\n      // Setup Scales\n\n      x.domain(xDomain || d3v3.extent(data, getX)).range(xRange || [0, availableWidth]);\n      y.domain(yDomain || d3v3.extent(data, getY)).range(yRange || [availableHeight, 0]);\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = container.selectAll('g.nv-wrap.nv-sparkline').data([data]);\n      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-sparkline');\n      var gEnter = wrapEnter.append('g');\n      var g = wrap.select('g');\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n      //------------------------------------------------------------\n\n      var paths = wrap.selectAll('path').data(function (d) {\n        return [d];\n      });\n      paths.enter().append('path');\n      paths.exit().remove();\n      paths.style('stroke', function (d, i) {\n        return d.color || color(d, i);\n      }).attr('d', d3v3.svg.line().x(function (d, i) {\n        return x(getX(d, i));\n      }).y(function (d, i) {\n        return y(getY(d, i));\n      }));\n\n      // TODO: Add CURRENT data point (Need Min, Mac, Current / Most recent)\n      var points = wrap.selectAll('circle.nv-point').data(function (data) {\n        var yValues = data.map(function (d, i) {\n          return getY(d, i);\n        });\n        function pointIndex(index) {\n          if (index != -1) {\n            var result = data[index];\n            result.pointIndex = index;\n            return result;\n          } else {\n            return null;\n          }\n        }\n        var maxPoint = pointIndex(yValues.lastIndexOf(y.domain()[1])),\n          minPoint = pointIndex(yValues.indexOf(y.domain()[0])),\n          currentPoint = pointIndex(yValues.length - 1);\n        return [minPoint, maxPoint, currentPoint].filter(function (d) {\n          return d != null;\n        });\n      });\n      points.enter().append('circle');\n      points.exit().remove();\n      points.attr('cx', function (d, i) {\n        return x(getX(d, d.pointIndex));\n      }).attr('cy', function (d, i) {\n        return y(getY(d, d.pointIndex));\n      }).attr('r', 2).attr('class', function (d, i) {\n        return getX(d, d.pointIndex) == x.domain()[1] ? 'nv-point nv-currentValue' : getY(d, d.pointIndex) == y.domain()[0] ? 'nv-point nv-minValue' : 'nv-point nv-maxValue';\n      });\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.x = function (_) {\n    if (!arguments.length) return getX;\n    getX = d3v3.functor(_);\n    return chart;\n  };\n  chart.y = function (_) {\n    if (!arguments.length) return getY;\n    getY = d3v3.functor(_);\n    return chart;\n  };\n  chart.xScale = function (_) {\n    if (!arguments.length) return x;\n    x = _;\n    return chart;\n  };\n  chart.yScale = function (_) {\n    if (!arguments.length) return y;\n    y = _;\n    return chart;\n  };\n  chart.xDomain = function (_) {\n    if (!arguments.length) return xDomain;\n    xDomain = _;\n    return chart;\n  };\n  chart.yDomain = function (_) {\n    if (!arguments.length) return yDomain;\n    yDomain = _;\n    return chart;\n  };\n  chart.xRange = function (_) {\n    if (!arguments.length) return xRange;\n    xRange = _;\n    return chart;\n  };\n  chart.yRange = function (_) {\n    if (!arguments.length) return yRange;\n    yRange = _;\n    return chart;\n  };\n  chart.animate = function (_) {\n    if (!arguments.length) return animate;\n    animate = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    return chart;\n  };\n\n  //============================================================\n\n  return chart;\n};\nnv.models.sparklinePlus = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var sparkline = nv.models.sparkline();\n  var margin = {\n      top: 15,\n      right: 100,\n      bottom: 10,\n      left: 50\n    },\n    width = null,\n    height = null,\n    x,\n    y,\n    index = [],\n    paused = false,\n    xTickFormat = d3v3.format(',r'),\n    yTickFormat = d3v3.format(',.2f'),\n    showValue = true,\n    alignValue = true,\n    rightAlignValue = false,\n    noData = \"No Data Available.\";\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var container = d3v3.select(this);\n      var availableWidth = (width || parseInt(container.style('width')) || 960) - margin.left - margin.right,\n        availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n      chart.update = function () {\n        chart(selection);\n      };\n      chart.container = this;\n\n      //------------------------------------------------------------\n      // Display No Data message if there's nothing to show.\n\n      if (!data || !data.length) {\n        var noDataText = container.selectAll('.nv-noData').data([noData]);\n        noDataText.enter().append('text').attr('class', 'nvd3 nv-noData').attr('dy', '-.7em').style('text-anchor', 'middle');\n        noDataText.attr('x', margin.left + availableWidth / 2).attr('y', margin.top + availableHeight / 2).text(function (d) {\n          return d;\n        });\n        return chart;\n      } else {\n        container.selectAll('.nv-noData').remove();\n      }\n      var currentValue = sparkline.y()(data[data.length - 1], data.length - 1);\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Scales\n\n      x = sparkline.xScale();\n      y = sparkline.yScale();\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = container.selectAll('g.nv-wrap.nv-sparklineplus').data([data]);\n      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-sparklineplus');\n      var gEnter = wrapEnter.append('g');\n      var g = wrap.select('g');\n      gEnter.append('g').attr('class', 'nv-sparklineWrap');\n      gEnter.append('g').attr('class', 'nv-valueWrap');\n      gEnter.append('g').attr('class', 'nv-hoverArea');\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Main Chart Component(s)\n\n      var sparklineWrap = g.select('.nv-sparklineWrap');\n      sparkline.width(availableWidth).height(availableHeight);\n      sparklineWrap.call(sparkline);\n\n      //------------------------------------------------------------\n\n      var valueWrap = g.select('.nv-valueWrap');\n      var value = valueWrap.selectAll('.nv-currentValue').data([currentValue]);\n      value.enter().append('text').attr('class', 'nv-currentValue').attr('dx', rightAlignValue ? -8 : 8).attr('dy', '.9em').style('text-anchor', rightAlignValue ? 'end' : 'start');\n      value.attr('x', availableWidth + (rightAlignValue ? margin.right : 0)).attr('y', alignValue ? function (d) {\n        return y(d);\n      } : 0).style('fill', sparkline.color()(data[data.length - 1], data.length - 1)).text(yTickFormat(currentValue));\n      gEnter.select('.nv-hoverArea').append('rect').on('mousemove', sparklineHover).on('click', function () {\n        paused = !paused;\n      }).on('mouseout', function () {\n        index = [];\n        updateValueLine();\n      });\n      //.on('mouseout', function() { index = null; updateValueLine(); });\n\n      g.select('.nv-hoverArea rect').attr('transform', function (d) {\n        return 'translate(' + -margin.left + ',' + -margin.top + ')';\n      }).attr('width', availableWidth + margin.left + margin.right).attr('height', availableHeight + margin.top);\n      function updateValueLine() {\n        //index is currently global (within the chart), may or may not keep it that way\n        if (paused) return;\n        var hoverValue = g.selectAll('.nv-hoverValue').data(index);\n        var hoverEnter = hoverValue.enter().append('g').attr('class', 'nv-hoverValue').style('stroke-opacity', 0).style('fill-opacity', 0);\n        hoverValue.exit().transition().duration(250).style('stroke-opacity', 0).style('fill-opacity', 0).remove();\n        hoverValue.attr('transform', function (d) {\n          return 'translate(' + x(sparkline.x()(data[d], d)) + ',0)';\n        }).transition().duration(250).style('stroke-opacity', 1).style('fill-opacity', 1);\n        if (!index.length) return;\n        hoverEnter.append('line').attr('x1', 0).attr('y1', -margin.top).attr('x2', 0).attr('y2', availableHeight);\n        hoverEnter.append('text').attr('class', 'nv-xValue').attr('x', -6).attr('y', -margin.top).attr('text-anchor', 'end').attr('dy', '.9em');\n        g.select('.nv-hoverValue .nv-xValue').text(xTickFormat(sparkline.x()(data[index[0]], index[0])));\n        hoverEnter.append('text').attr('class', 'nv-yValue').attr('x', 6).attr('y', -margin.top).attr('text-anchor', 'start').attr('dy', '.9em');\n        g.select('.nv-hoverValue .nv-yValue').text(yTickFormat(sparkline.y()(data[index[0]], index[0])));\n      }\n      function sparklineHover() {\n        if (paused) return;\n        var pos = d3v3.mouse(this)[0] - margin.left;\n        function getClosestIndex(data, x) {\n          var distance = Math.abs(sparkline.x()(data[0], 0) - x);\n          var closestIndex = 0;\n          for (var i = 0; i < data.length; i++) {\n            if (Math.abs(sparkline.x()(data[i], i) - x) < distance) {\n              distance = Math.abs(sparkline.x()(data[i], i) - x);\n              closestIndex = i;\n            }\n          }\n          return closestIndex;\n        }\n        index = [getClosestIndex(data, Math.round(x.invert(pos)))];\n        updateValueLine();\n      }\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  // expose chart's sub-components\n  chart.sparkline = sparkline;\n  d3v3.rebind(chart, sparkline, 'x', 'y', 'xScale', 'yScale', 'color');\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.xTickFormat = function (_) {\n    if (!arguments.length) return xTickFormat;\n    xTickFormat = _;\n    return chart;\n  };\n  chart.yTickFormat = function (_) {\n    if (!arguments.length) return yTickFormat;\n    yTickFormat = _;\n    return chart;\n  };\n  chart.showValue = function (_) {\n    if (!arguments.length) return showValue;\n    showValue = _;\n    return chart;\n  };\n  chart.alignValue = function (_) {\n    if (!arguments.length) return alignValue;\n    alignValue = _;\n    return chart;\n  };\n  chart.rightAlignValue = function (_) {\n    if (!arguments.length) return rightAlignValue;\n    rightAlignValue = _;\n    return chart;\n  };\n  chart.noData = function (_) {\n    if (!arguments.length) return noData;\n    noData = _;\n    return chart;\n  };\n\n  //============================================================\n\n  return chart;\n};\nnv.models.stackedArea = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var margin = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    },\n    width = 960,\n    height = 500,\n    color = nv.utils.defaultColor() // a function that computes the color\n    ,\n    id = Math.floor(Math.random() * 100000) //Create semi-unique ID incase user doesn't selet one\n    ,\n    getX = function getX(d) {\n      return d.x;\n    } // accessor to get the x value from a data point\n    ,\n    getY = function getY(d) {\n      return d.y;\n    } // accessor to get the y value from a data point\n    ,\n    style = 'stack',\n    offset = 'zero',\n    order = 'default',\n    interpolate = 'linear' // controls the line interpolation\n    ,\n    clipEdge = false // if true, masks lines within x and y scale\n    ,\n    x //can be accessed via chart.xScale()\n    ,\n    y //can be accessed via chart.yScale()\n    ,\n    scatter = nv.models.scatter(),\n    dispatch = d3v3.dispatch('tooltipShow', 'tooltipHide', 'areaClick', 'areaMouseover', 'areaMouseout');\n  scatter.size(2.2) // default size\n  .sizeDomain([2.2, 2.2]) // all the same size by default\n  ;\n\n  /************************************\n   * offset:\n   *   'wiggle' (stream)\n   *   'zero' (stacked)\n   *   'expand' (normalize to 100%)\n   *   'silhouette' (simple centered)\n   *\n   * order:\n   *   'inside-out' (stream)\n   *   'default' (input order)\n   ************************************/\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var availableWidth = width - margin.left - margin.right,\n        availableHeight = height - margin.top - margin.bottom,\n        container = d3v3.select(this);\n\n      //------------------------------------------------------------\n      // Setup Scales\n\n      x = scatter.xScale();\n      y = scatter.yScale();\n\n      //------------------------------------------------------------\n\n      var dataRaw = data;\n      // Injecting point index into each point because d3v3.layout.stack().out does not give index\n      data.forEach(function (aseries, i) {\n        aseries.seriesIndex = i;\n        aseries.values = aseries.values.map(function (d, j) {\n          d.index = j;\n          d.seriesIndex = i;\n          return d;\n        });\n      });\n      var dataFiltered = data.filter(function (series) {\n        return !series.disabled;\n      });\n      data = d3v3.layout.stack().order(order).offset(offset).values(function (d) {\n        return d.values;\n      }) //TODO: make values customizeable in EVERY model in this fashion\n      .x(getX).y(getY).out(function (d, y0, y) {\n        var yHeight = getY(d) === 0 ? 0 : y;\n        d.display = {\n          y: yHeight,\n          y0: y0\n        };\n      })(dataFiltered);\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = container.selectAll('g.nv-wrap.nv-stackedarea').data([data]);\n      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-stackedarea');\n      var defsEnter = wrapEnter.append('defs');\n      var gEnter = wrapEnter.append('g');\n      var g = wrap.select('g');\n      gEnter.append('g').attr('class', 'nv-areaWrap');\n      gEnter.append('g').attr('class', 'nv-scatterWrap');\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n      //------------------------------------------------------------\n\n      scatter.width(availableWidth).height(availableHeight).x(getX).y(function (d) {\n        return d.display.y + d.display.y0;\n      }).forceY([0]).color(data.map(function (d, i) {\n        return d.color || color(d, d.seriesIndex);\n      }));\n      var scatterWrap = g.select('.nv-scatterWrap').datum(data);\n      scatterWrap.call(scatter);\n      defsEnter.append('clipPath').attr('id', 'nv-edge-clip-' + id).append('rect');\n      wrap.select('#nv-edge-clip-' + id + ' rect').attr('width', availableWidth).attr('height', availableHeight);\n      g.attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + id + ')' : '');\n      var area = d3v3.svg.area().x(function (d, i) {\n        return x(getX(d, i));\n      }).y0(function (d) {\n        return y(d.display.y0);\n      }).y1(function (d) {\n        return y(d.display.y + d.display.y0);\n      }).interpolate(interpolate);\n      var zeroArea = d3v3.svg.area().x(function (d, i) {\n        return x(getX(d, i));\n      }).y0(function (d) {\n        return y(d.display.y0);\n      }).y1(function (d) {\n        return y(d.display.y0);\n      });\n      var path = g.select('.nv-areaWrap').selectAll('path.nv-area').data(function (d) {\n        return d;\n      });\n      path.enter().append('path').attr('class', function (d, i) {\n        return 'nv-area nv-area-' + i;\n      }).attr('d', function (d, i) {\n        return zeroArea(d.values, d.seriesIndex);\n      }).on('mouseover', function (d, i) {\n        d3v3.select(this).classed('hover', true);\n        dispatch.areaMouseover({\n          point: d,\n          series: d.key,\n          pos: [d3v3.event.pageX, d3v3.event.pageY],\n          seriesIndex: d.seriesIndex\n        });\n      }).on('mouseout', function (d, i) {\n        d3v3.select(this).classed('hover', false);\n        dispatch.areaMouseout({\n          point: d,\n          series: d.key,\n          pos: [d3v3.event.pageX, d3v3.event.pageY],\n          seriesIndex: d.seriesIndex\n        });\n      }).on('click', function (d, i) {\n        d3v3.select(this).classed('hover', false);\n        dispatch.areaClick({\n          point: d,\n          series: d.key,\n          pos: [d3v3.event.pageX, d3v3.event.pageY],\n          seriesIndex: d.seriesIndex\n        });\n      });\n      path.exit().remove();\n      path.style('fill', function (d, i) {\n        return d.color || color(d, d.seriesIndex);\n      }).style('stroke', function (d, i) {\n        return d.color || color(d, d.seriesIndex);\n      });\n      path.transition().attr('d', function (d, i) {\n        return area(d.values, i);\n      });\n\n      //============================================================\n      // Event Handling/Dispatching (in chart's scope)\n      //------------------------------------------------------------\n\n      scatter.dispatch.on('elementMouseover.area', function (e) {\n        g.select('.nv-chart-' + id + ' .nv-area-' + e.seriesIndex).classed('hover', true);\n      });\n      scatter.dispatch.on('elementMouseout.area', function (e) {\n        g.select('.nv-chart-' + id + ' .nv-area-' + e.seriesIndex).classed('hover', false);\n      });\n\n      //============================================================\n      //Special offset functions\n      chart.d3_stackedOffset_stackPercent = function (stackData) {\n        var n = stackData.length,\n          //How many series\n          m = stackData[0].length,\n          //how many points per series\n          k = 1 / n,\n          i,\n          j,\n          o,\n          y0 = [];\n        for (j = 0; j < m; ++j) {\n          //Looping through all points\n          for (i = 0, o = 0; i < dataRaw.length; i++)\n          //looping through series'\n          o += getY(dataRaw[i].values[j]); //total value of all points at a certian point in time.\n\n          if (o) for (i = 0; i < n; i++) stackData[i][j][1] /= o;else for (i = 0; i < n; i++) stackData[i][j][1] = k;\n        }\n        for (j = 0; j < m; ++j) y0[j] = 0;\n        return y0;\n      };\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Event Handling/Dispatching (out of chart's scope)\n  //------------------------------------------------------------\n\n  scatter.dispatch.on('elementClick.area', function (e) {\n    dispatch.areaClick(e);\n  });\n  scatter.dispatch.on('elementMouseover.tooltip', function (e) {\n    e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top], dispatch.tooltipShow(e);\n  });\n  scatter.dispatch.on('elementMouseout.tooltip', function (e) {\n    dispatch.tooltipHide(e);\n  });\n\n  //============================================================\n\n  //============================================================\n  // Global getters and setters\n  //------------------------------------------------------------\n\n  chart.dispatch = dispatch;\n  chart.scatter = scatter;\n  d3v3.rebind(chart, scatter, 'interactive', 'size', 'xScale', 'yScale', 'zScale', 'xDomain', 'yDomain', 'xRange', 'yRange', 'sizeDomain', 'forceX', 'forceY', 'forceSize', 'clipVoronoi', 'useVoronoi', 'clipRadius', 'highlightPoint', 'clearHighlights');\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.x = function (_) {\n    if (!arguments.length) return getX;\n    getX = d3v3.functor(_);\n    return chart;\n  };\n  chart.y = function (_) {\n    if (!arguments.length) return getY;\n    getY = d3v3.functor(_);\n    return chart;\n  };\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.clipEdge = function (_) {\n    if (!arguments.length) return clipEdge;\n    clipEdge = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    return chart;\n  };\n  chart.offset = function (_) {\n    if (!arguments.length) return offset;\n    offset = _;\n    return chart;\n  };\n  chart.order = function (_) {\n    if (!arguments.length) return order;\n    order = _;\n    return chart;\n  };\n\n  //shortcut for offset + order\n  chart.style = function (_) {\n    if (!arguments.length) return style;\n    style = _;\n    switch (style) {\n      case 'stack':\n        chart.offset('zero');\n        chart.order('default');\n        break;\n      case 'stream':\n        chart.offset('wiggle');\n        chart.order('inside-out');\n        break;\n      case 'stream-center':\n        chart.offset('silhouette');\n        chart.order('inside-out');\n        break;\n      case 'expand':\n        chart.offset('expand');\n        chart.order('default');\n        break;\n      case 'stack_percent':\n        chart.offset(chart.d3_stackedOffset_stackPercent);\n        chart.order('default');\n        break;\n    }\n    return chart;\n  };\n  chart.interpolate = function (_) {\n    if (!arguments.length) return interpolate;\n    interpolate = _;\n    return chart;\n  };\n  //============================================================\n\n  return chart;\n};\nnv.models.stackedAreaChart = function () {\n  \"use strict\";\n\n  //============================================================\n  // Public Variables with Default Settings\n  //------------------------------------------------------------\n  var stacked = nv.models.stackedArea(),\n    xAxis = nv.models.axis(),\n    yAxis = nv.models.axis(),\n    legend = nv.models.legend(),\n    controls = nv.models.legend(),\n    interactiveLayer = nv.interactiveGuideline();\n  var margin = {\n      top: 30,\n      right: 25,\n      bottom: 50,\n      left: 60\n    },\n    width = null,\n    height = null,\n    color = nv.utils.defaultColor() // a function that takes in d, i and returns color\n    ,\n    showControls = true,\n    showLegend = true,\n    showXAxis = true,\n    showYAxis = true,\n    rightAlignYAxis = false,\n    useInteractiveGuideline = false,\n    tooltips = true,\n    tooltip = function tooltip(key, x, y, e, graph) {\n      return '<h3>' + key + '</h3>' + '<p>' + y + ' on ' + x + '</p>';\n    },\n    x //can be accessed via chart.xScale()\n    ,\n    y //can be accessed via chart.yScale()\n    ,\n    yAxisTickFormat = d3v3.format(',.2f'),\n    state = {\n      style: stacked.style()\n    },\n    defaultState = null,\n    noData = 'No Data Available.',\n    dispatch = d3v3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState'),\n    controlWidth = 250,\n    cData = ['Stacked', 'Stream', 'Expanded'],\n    controlLabels = {},\n    transitionDuration = 250;\n  xAxis.orient('bottom').tickPadding(7);\n  yAxis.orient(rightAlignYAxis ? 'right' : 'left');\n  controls.updateState(false);\n  //============================================================\n\n  //============================================================\n  // Private Variables\n  //------------------------------------------------------------\n\n  var showTooltip = function showTooltip(e, offsetElement) {\n    var left = e.pos[0] + (offsetElement.offsetLeft || 0),\n      top = e.pos[1] + (offsetElement.offsetTop || 0),\n      x = xAxis.tickFormat()(stacked.x()(e.point, e.pointIndex)),\n      y = yAxis.tickFormat()(stacked.y()(e.point, e.pointIndex)),\n      content = tooltip(e.series.key, x, y, e, chart);\n    nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);\n  };\n\n  //============================================================\n\n  function chart(selection) {\n    selection.each(function (data) {\n      var container = d3v3.select(this),\n        that = this;\n      var availableWidth = (width || parseInt(container.style('width')) || 960) - margin.left - margin.right,\n        availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n      chart.update = function () {\n        container.transition().duration(transitionDuration).call(chart);\n      };\n      chart.container = this;\n\n      //set state.disabled\n      state.disabled = data.map(function (d) {\n        return !!d.disabled;\n      });\n      if (!defaultState) {\n        var key;\n        defaultState = {};\n        for (key in state) {\n          if (state[key] instanceof Array) defaultState[key] = state[key].slice(0);else defaultState[key] = state[key];\n        }\n      }\n\n      //------------------------------------------------------------\n      // Display No Data message if there's nothing to show.\n\n      if (!data || !data.length || !data.filter(function (d) {\n        return d.values.length;\n      }).length) {\n        var noDataText = container.selectAll('.nv-noData').data([noData]);\n        noDataText.enter().append('text').attr('class', 'nvd3 nv-noData').attr('dy', '-.7em').style('text-anchor', 'middle');\n        noDataText.attr('x', margin.left + availableWidth / 2).attr('y', margin.top + availableHeight / 2).text(function (d) {\n          return d;\n        });\n        return chart;\n      } else {\n        container.selectAll('.nv-noData').remove();\n      }\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Scales\n\n      x = stacked.xScale();\n      y = stacked.yScale();\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup containers and skeleton of chart\n\n      var wrap = container.selectAll('g.nv-wrap.nv-stackedAreaChart').data([data]);\n      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-stackedAreaChart').append('g');\n      var g = wrap.select('g');\n      gEnter.append(\"rect\").style(\"opacity\", 0);\n      gEnter.append('g').attr('class', 'nv-x nv-axis');\n      gEnter.append('g').attr('class', 'nv-y nv-axis');\n      gEnter.append('g').attr('class', 'nv-stackedWrap');\n      gEnter.append('g').attr('class', 'nv-legendWrap');\n      gEnter.append('g').attr('class', 'nv-controlsWrap');\n      gEnter.append('g').attr('class', 'nv-interactive');\n      g.select(\"rect\").attr(\"width\", availableWidth).attr(\"height\", availableHeight);\n      //------------------------------------------------------------\n      // Legend\n\n      if (showLegend) {\n        var legendWidth = showControls ? availableWidth - controlWidth : availableWidth;\n        legend.width(legendWidth);\n        g.select('.nv-legendWrap').datum(data).call(legend);\n        if (margin.top != legend.height()) {\n          margin.top = legend.height();\n          availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n        }\n        g.select('.nv-legendWrap').attr('transform', 'translate(' + (availableWidth - legendWidth) + ',' + -margin.top + ')');\n      }\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Controls\n\n      if (showControls) {\n        var controlsData = [{\n          key: controlLabels.stacked || 'Stacked',\n          metaKey: 'Stacked',\n          disabled: stacked.style() != 'stack',\n          style: 'stack'\n        }, {\n          key: controlLabels.stream || 'Stream',\n          metaKey: 'Stream',\n          disabled: stacked.style() != 'stream',\n          style: 'stream'\n        }, {\n          key: controlLabels.expanded || 'Expanded',\n          metaKey: 'Expanded',\n          disabled: stacked.style() != 'expand',\n          style: 'expand'\n        }, {\n          key: controlLabels.stack_percent || 'Stack %',\n          metaKey: 'Stack_Percent',\n          disabled: stacked.style() != 'stack_percent',\n          style: 'stack_percent'\n        }];\n        controlWidth = cData.length / 3 * 260;\n        controlsData = controlsData.filter(function (d) {\n          return cData.indexOf(d.metaKey) !== -1;\n        });\n        controls.width(controlWidth).color(['#444', '#444', '#444']);\n        g.select('.nv-controlsWrap').datum(controlsData).call(controls);\n        if (margin.top != Math.max(controls.height(), legend.height())) {\n          margin.top = Math.max(controls.height(), legend.height());\n          availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n        }\n        g.select('.nv-controlsWrap').attr('transform', 'translate(0,' + -margin.top + ')');\n      }\n\n      //------------------------------------------------------------\n\n      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n      if (rightAlignYAxis) {\n        g.select(\".nv-y.nv-axis\").attr(\"transform\", \"translate(\" + availableWidth + \",0)\");\n      }\n\n      //------------------------------------------------------------\n      // Main Chart Component(s)\n\n      //------------------------------------------------------------\n      //Set up interactive layer\n      if (useInteractiveGuideline) {\n        interactiveLayer.width(availableWidth).height(availableHeight).margin({\n          left: margin.left,\n          top: margin.top\n        }).svgContainer(container).xScale(x);\n        wrap.select(\".nv-interactive\").call(interactiveLayer);\n      }\n      stacked.width(availableWidth).height(availableHeight);\n      var stackedWrap = g.select('.nv-stackedWrap').datum(data);\n      stackedWrap.transition().call(stacked);\n\n      //------------------------------------------------------------\n\n      //------------------------------------------------------------\n      // Setup Axes\n\n      if (showXAxis) {\n        xAxis.scale(x).ticks(availableWidth / 100).tickSize(-availableHeight, 0);\n        g.select('.nv-x.nv-axis').attr('transform', 'translate(0,' + availableHeight + ')');\n        g.select('.nv-x.nv-axis').transition().duration(0).call(xAxis);\n      }\n      if (showYAxis) {\n        yAxis.scale(y).ticks(stacked.offset() == 'wiggle' ? 0 : availableHeight / 36).tickSize(-availableWidth, 0).setTickFormat(stacked.style() == 'expand' || stacked.style() == 'stack_percent' ? d3v3.format('%') : yAxisTickFormat);\n        g.select('.nv-y.nv-axis').transition().duration(0).call(yAxis);\n      }\n\n      //------------------------------------------------------------\n\n      //============================================================\n      // Event Handling/Dispatching (in chart's scope)\n      //------------------------------------------------------------\n\n      stacked.dispatch.on('areaClick.toggle', function (e) {\n        if (data.filter(function (d) {\n          return !d.disabled;\n        }).length === 1) data.forEach(function (d) {\n          d.disabled = false;\n        });else data.forEach(function (d, i) {\n          d.disabled = i != e.seriesIndex;\n        });\n        state.disabled = data.map(function (d) {\n          return !!d.disabled;\n        });\n        dispatch.stateChange(state);\n        chart.update();\n      });\n      legend.dispatch.on('stateChange', function (newState) {\n        state.disabled = newState.disabled;\n        dispatch.stateChange(state);\n        chart.update();\n      });\n      controls.dispatch.on('legendClick', function (d, i) {\n        if (!d.disabled) return;\n        controlsData = controlsData.map(function (s) {\n          s.disabled = true;\n          return s;\n        });\n        d.disabled = false;\n        stacked.style(d.style);\n        state.style = stacked.style();\n        dispatch.stateChange(state);\n        chart.update();\n      });\n      interactiveLayer.dispatch.on('elementMousemove', function (e) {\n        stacked.clearHighlights();\n        var singlePoint,\n          pointIndex,\n          pointXLocation,\n          allData = [];\n        data.filter(function (series, i) {\n          series.seriesIndex = i;\n          return !series.disabled;\n        }).forEach(function (series, i) {\n          pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());\n          stacked.highlightPoint(i, pointIndex, true);\n          var point = series.values[pointIndex];\n          if (typeof point === 'undefined') return;\n          if (typeof singlePoint === 'undefined') singlePoint = point;\n          if (typeof pointXLocation === 'undefined') pointXLocation = chart.xScale()(chart.x()(point, pointIndex));\n\n          //If we are in 'expand' mode, use the stacked percent value instead of raw value.\n          var tooltipValue = stacked.style() == 'expand' ? point.display.y : chart.y()(point, pointIndex);\n          allData.push({\n            key: series.key,\n            value: tooltipValue,\n            color: color(series, series.seriesIndex),\n            stackedValue: point.display\n          });\n        });\n        allData.reverse();\n\n        //Highlight the tooltip entry based on which stack the mouse is closest to.\n        if (allData.length > 2) {\n          var yValue = chart.yScale().invert(e.mouseY);\n          var yDistMax = Infinity,\n            indexToHighlight = null;\n          allData.forEach(function (series, i) {\n            //To handle situation where the stacked area chart is negative, we need to use absolute values\n            //when checking if the mouse Y value is within the stack area.\n            yValue = Math.abs(yValue);\n            var stackedY0 = Math.abs(series.stackedValue.y0);\n            var stackedY = Math.abs(series.stackedValue.y);\n            if (yValue >= stackedY0 && yValue <= stackedY + stackedY0) {\n              indexToHighlight = i;\n              return;\n            }\n          });\n          if (indexToHighlight != null) allData[indexToHighlight].highlight = true;\n        }\n        var xValue = xAxis.tickFormat()(chart.x()(singlePoint, pointIndex));\n\n        //If we are in 'expand' mode, force the format to be a percentage.\n        var valueFormatter = stacked.style() == 'expand' ? function (d, i) {\n          return d3v3.format(\".1%\")(d);\n        } : function (d, i) {\n          return yAxis.tickFormat()(d);\n        };\n        interactiveLayer.tooltip.position({\n          left: pointXLocation + margin.left,\n          top: e.mouseY + margin.top\n        }).chartContainer(that.parentNode).enabled(tooltips).valueFormatter(valueFormatter).data({\n          value: xValue,\n          series: allData\n        })();\n        interactiveLayer.renderGuideLine(pointXLocation);\n      });\n      interactiveLayer.dispatch.on(\"elementMouseout\", function (e) {\n        dispatch.tooltipHide();\n        stacked.clearHighlights();\n      });\n      dispatch.on('tooltipShow', function (e) {\n        if (tooltips) showTooltip(e, that.parentNode);\n      });\n\n      // Update chart from a state object passed to event handler\n      dispatch.on('changeState', function (e) {\n        if (typeof e.disabled !== 'undefined' && data.length === e.disabled.length) {\n          data.forEach(function (series, i) {\n            series.disabled = e.disabled[i];\n          });\n          state.disabled = e.disabled;\n        }\n        if (typeof e.style !== 'undefined') {\n          stacked.style(e.style);\n        }\n        chart.update();\n      });\n    });\n    return chart;\n  }\n\n  //============================================================\n  // Event Handling/Dispatching (out of chart's scope)\n  //------------------------------------------------------------\n\n  stacked.dispatch.on('tooltipShow', function (e) {\n    //disable tooltips when value ~= 0\n    //// TODO: consider removing points from voronoi that have 0 value instead of this hack\n    /*\n    if (!Math.round(stacked.y()(e.point) * 100)) {  // 100 will not be good for very small numbers... will have to think about making this valu dynamic, based on data range\n      setTimeout(function() { d3v3.selectAll('.point.hover').classed('hover', false) }, 0);\n      return false;\n    }\n    */\n\n    e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top], dispatch.tooltipShow(e);\n  });\n  stacked.dispatch.on('tooltipHide', function (e) {\n    dispatch.tooltipHide(e);\n  });\n  dispatch.on('tooltipHide', function () {\n    if (tooltips) nv.tooltip.cleanup();\n  });\n\n  //============================================================\n\n  //============================================================\n  // Expose Public Variables\n  //------------------------------------------------------------\n\n  // expose chart's sub-components\n  chart.dispatch = dispatch;\n  chart.stacked = stacked;\n  chart.legend = legend;\n  chart.controls = controls;\n  chart.xAxis = xAxis;\n  chart.yAxis = yAxis;\n  chart.interactiveLayer = interactiveLayer;\n  d3v3.rebind(chart, stacked, 'x', 'y', 'size', 'xScale', 'yScale', 'xDomain', 'yDomain', 'xRange', 'yRange', 'sizeDomain', 'interactive', 'useVoronoi', 'offset', 'order', 'style', 'clipEdge', 'forceX', 'forceY', 'forceSize', 'interpolate');\n  chart.options = nv.utils.optionsFunc.bind(chart);\n  chart.margin = function (_) {\n    if (!arguments.length) return margin;\n    margin.top = typeof _.top != 'undefined' ? _.top : margin.top;\n    margin.right = typeof _.right != 'undefined' ? _.right : margin.right;\n    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n    margin.left = typeof _.left != 'undefined' ? _.left : margin.left;\n    return chart;\n  };\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n  chart.color = function (_) {\n    if (!arguments.length) return color;\n    color = nv.utils.getColor(_);\n    legend.color(color);\n    stacked.color(color);\n    return chart;\n  };\n  chart.showControls = function (_) {\n    if (!arguments.length) return showControls;\n    showControls = _;\n    return chart;\n  };\n  chart.showLegend = function (_) {\n    if (!arguments.length) return showLegend;\n    showLegend = _;\n    return chart;\n  };\n  chart.showXAxis = function (_) {\n    if (!arguments.length) return showXAxis;\n    showXAxis = _;\n    return chart;\n  };\n  chart.showYAxis = function (_) {\n    if (!arguments.length) return showYAxis;\n    showYAxis = _;\n    return chart;\n  };\n  chart.rightAlignYAxis = function (_) {\n    if (!arguments.length) return rightAlignYAxis;\n    rightAlignYAxis = _;\n    yAxis.orient(_ ? 'right' : 'left');\n    return chart;\n  };\n  chart.useInteractiveGuideline = function (_) {\n    if (!arguments.length) return useInteractiveGuideline;\n    useInteractiveGuideline = _;\n    if (_ === true) {\n      chart.interactive(false);\n      chart.useVoronoi(false);\n    }\n    return chart;\n  };\n  chart.tooltip = function (_) {\n    if (!arguments.length) return tooltip;\n    tooltip = _;\n    return chart;\n  };\n  chart.tooltips = function (_) {\n    if (!arguments.length) return tooltips;\n    tooltips = _;\n    return chart;\n  };\n  chart.tooltipContent = function (_) {\n    if (!arguments.length) return tooltip;\n    tooltip = _;\n    return chart;\n  };\n  chart.state = function (_) {\n    if (!arguments.length) return state;\n    state = _;\n    return chart;\n  };\n  chart.defaultState = function (_) {\n    if (!arguments.length) return defaultState;\n    defaultState = _;\n    return chart;\n  };\n  chart.noData = function (_) {\n    if (!arguments.length) return noData;\n    noData = _;\n    return chart;\n  };\n  chart.transitionDuration = function (_) {\n    if (!arguments.length) return transitionDuration;\n    transitionDuration = _;\n    return chart;\n  };\n  chart.controlsData = function (_) {\n    if (!arguments.length) return cData;\n    cData = _;\n    return chart;\n  };\n  chart.controlLabels = function (_) {\n    if (!arguments.length) return controlLabels;\n    if (_typeof(_) !== 'object') return controlLabels;\n    controlLabels = _;\n    return chart;\n  };\n  yAxis.setTickFormat = yAxis.tickFormat;\n  yAxis.tickFormat = function (_) {\n    if (!arguments.length) return yAxisTickFormat;\n    yAxisTickFormat = _;\n    return yAxis;\n  };\n\n  //============================================================\n\n  return chart;\n};\nexport default nv;"],"names":[],"sourceRoot":""}